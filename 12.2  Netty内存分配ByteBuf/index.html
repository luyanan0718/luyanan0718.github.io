<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="4. Pooled 池化内存分配1. PooledByteBufAllocator 简述现在开始, 我们来分析Pooled 池化内存的分配原理, 我们首先还是先找到 AbstractByteBufAllocator 的子类 PooledByteBufAllocator  实现的分配内存的两个方法. newDirectBuffer()方法和 newHeapBuffer()方法： 1234567891">
<meta property="og:type" content="article">
<meta property="og:title" content="12">
<meta property="og:url" content="http://luyanan.com/12.2%20%20Netty%E5%86%85%E5%AD%98%E5%88%86%E9%85%8DByteBuf/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="4. Pooled 池化内存分配1. PooledByteBufAllocator 简述现在开始, 我们来分析Pooled 池化内存的分配原理, 我们首先还是先找到 AbstractByteBufAllocator 的子类 PooledByteBufAllocator  实现的分配内存的两个方法. newDirectBuffer()方法和 newHeapBuffer()方法： 1234567891">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20191007173949.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191008220148.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191010211930.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191010224444.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191010225320.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011103228.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011103351.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011104117.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011112610.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011120814.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011120905.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011120943.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011121137.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011140957.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011144649.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011153603.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011154018.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191011155250.png">
<meta property="article:published_time" content="2021-03-02T05:51:37.927Z">
<meta property="article:modified_time" content="2021-03-02T05:42:51.621Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Python, Rust, C++, Go, 爬虫, 深度学习, 服务研发, 对象存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20191007173949.png">

<link rel="canonical" href="http://luyanan.com/12.2%20%20Netty%E5%86%85%E5%AD%98%E5%88%86%E9%85%8DByteBuf/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>12 | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/12.2%20%20Netty%E5%86%85%E5%AD%98%E5%88%86%E9%85%8DByteBuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          12
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-02 13:51:37 / 修改时间：13:42:51" itemprop="dateCreated datePublished" datetime="2021-03-02T13:51:37+08:00">2021-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="4-Pooled-池化内存分配"><a href="#4-Pooled-池化内存分配" class="headerlink" title="4. Pooled 池化内存分配"></a>4. Pooled 池化内存分配</h2><h3 id="1-PooledByteBufAllocator-简述"><a href="#1-PooledByteBufAllocator-简述" class="headerlink" title="1. PooledByteBufAllocator 简述"></a>1. PooledByteBufAllocator 简述</h3><p>现在开始, 我们来分析Pooled 池化内存的分配原理, 我们首先还是先找到 AbstractByteBufAllocator 的子类 PooledByteBufAllocator  实现的分配内存的两个方法. newDirectBuffer()方法和 newHeapBuffer()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PoolThreadCache cache = threadCache.get();</span><br><span class="line">        PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = cache.heapArena;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf;</span><br><span class="line">        <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf = heapArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf = <span class="keyword">new</span> UnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PoolThreadCache cache = threadCache.get();</span><br><span class="line">        PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf;</span><br><span class="line">        <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">                buf = UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf = <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这两个方法大体结构上是一样的. 我们以newDirectBuffer 为例简单的分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">            buf = UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf = <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先,我们看到它是通过 threadCache.get() 拿到一个类型为PoolThreadCache 的cache 对象, 然后, 通过  cache 拿到 PoolArena 对象, 最终会调用 directArena.allocate()  方法分配 ByteBuf. 这个地方大家可能会看的比较懵, 我们来详细分析一下，我们跟进到  threadCache  对象其实是PoolThreadLocalCache 类型的变量, 跟进到 PoolThreadLocalCache 的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThreadLocalCache</span> <span class="keyword">extends</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">PoolThreadCache</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> PoolThreadCache <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class="line">            <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(</span><br><span class="line">                    heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(PoolThreadCache threadCache)</span> </span>&#123;</span><br><span class="line">            threadCache.free();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> &lt;T&gt; <span class="function">PoolArena&lt;T&gt; <span class="title">leastUsedArena</span><span class="params">(PoolArena&lt;T&gt;[] arenas)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (arenas == <span class="keyword">null</span> || arenas.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PoolArena&lt;T&gt; minArena = arenas[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arenas.length; i++) &#123;</span><br><span class="line">                PoolArena&lt;T&gt; arena = arenas[i];</span><br><span class="line">                <span class="keyword">if</span> (arena.numThreadCaches.get() &lt; minArena.numThreadCaches.get()) &#123;</span><br><span class="line">                    minArena = arena;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> minArena;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>从名字上来看, 我们发现PoolThreadLocalCache 的initialValue()  方法就是用来初始化PoolThreadLocalCache  的, 首先就调用了leastUsedArena() 方法分别获取类型为 PoolArena 的 heapArena 对象和directArena 对象. 然后把heapArena 对象和directArena 对象 当做参数出传递到了 PoolThreadLocalCache  的构造器中, 那么  heapArena 对象和directArena 对象 是在哪里被初始化的呢? 我们查找一下发现在PooledByteBufAllocator 的 构造器中调用 newArenaArray() 方法给heapArenas 和directArenas 赋值了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(preferDirect);</span><br><span class="line">     threadCache = <span class="keyword">new</span> PoolThreadLocalCache();</span><br><span class="line">     <span class="keyword">this</span>.tinyCacheSize = tinyCacheSize;</span><br><span class="line">     <span class="keyword">this</span>.smallCacheSize = smallCacheSize;</span><br><span class="line">     <span class="keyword">this</span>.normalCacheSize = normalCacheSize;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (nHeapArena &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;nHeapArena: &quot;</span> + nHeapArena + <span class="string">&quot; (expected: &gt;= 0)&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (nDirectArena &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;nDirectArea: &quot;</span> + nDirectArena + <span class="string">&quot; (expected: &gt;= 0)&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> pageShifts = validateAndCalculatePageShifts(pageSize);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (nHeapArena &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         heapArenas = newArenaArray(nHeapArena);</span><br><span class="line">         List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(heapArenas.length);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapArenas.length; i ++) &#123;</span><br><span class="line">             PoolArena.HeapArena arena = <span class="keyword">new</span> PoolArena.HeapArena(<span class="keyword">this</span>, pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">             heapArenas[i] = arena;</span><br><span class="line">             metrics.add(arena);</span><br><span class="line">         &#125;</span><br><span class="line">         heapArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         heapArenas = <span class="keyword">null</span>;</span><br><span class="line">         heapArenaMetrics = Collections.emptyList();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (nDirectArena &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         directArenas = newArenaArray(nDirectArena);</span><br><span class="line">         List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(directArenas.length);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directArenas.length; i ++) &#123;</span><br><span class="line">             PoolArena.DirectArena arena = <span class="keyword">new</span> PoolArena.DirectArena(</span><br><span class="line">                     <span class="keyword">this</span>, pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">             directArenas[i] = arena;</span><br><span class="line">             metrics.add(arena);</span><br><span class="line">         &#125;</span><br><span class="line">         directArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         directArenas = <span class="keyword">null</span>;</span><br><span class="line">         directArenaMetrics = Collections.emptyList();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>进去到newArenaArray() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; PoolArena&lt;T&gt;[] newArenaArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PoolArena[size];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是创建一个固定大小的 PoolArena 数组, 数组大小由传入的参数 数 nHeapArena 和 nDirectArena 来决定, 我们再回到PooledByteBufAllocator 的构造器源码, 看 nHeapArena 和 nDirectArena 是怎么初始化的, 我们找到了PooledByteBufAllocator 的重载构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(preferDirect, DEFAULT_NUM_HEAP_ARENA, DEFAULT_NUM_DIRECT_ARENA, DEFAULT_PAGE_SIZE, DEFAULT_MAX_ORDER);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现, nHeapArena 和 nDirectArena  是通过  DEFAULT_NUM_HEAP_ARENA, DEFAULT_NUM_DIRECT_ARENA 这两个常量默认赋值的, 再继续跟进常量的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_NUM_HEAP_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">              SystemPropertyUtil.getInt(</span><br><span class="line">                      <span class="string">&quot;io.netty.allocator.numHeapArenas&quot;</span>,</span><br><span class="line">                      (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                              defaultMinNumArena,</span><br><span class="line">                              runtime.maxMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br><span class="line">      DEFAULT_NUM_DIRECT_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">              SystemPropertyUtil.getInt(</span><br><span class="line">                      <span class="string">&quot;io.netty.allocator.numDirectArenas&quot;</span>,</span><br><span class="line">                      (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                              defaultMinNumArena,</span><br><span class="line">                              PlatformDependent.maxDirectMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p>到这里为止 , 我们才知道 nHeapArena 和 nDirectArena 的默认赋值, 默认是分配CPU 核数*2, 也就是把 defaultMinNumArena的值赋值给 nHeapArena 和 nDirectArena . 那么Netty 为什么这样设计呢? 其实主要目的就是为了保证Netty 中的每一个线程任务都可以有一个独享的 Arena, 保证在每个线程分配内存的是是不用加锁的.</p>
<p>基于上面的分析, 我们知道 Arena 有HeapArena 和 DirectArena , 这里我们统称为Arena . 假设我们有四个线程, 那么对应会分配四个 Arena , 在创建ByteBuf 的时候, 首先通过 PoolThreadCache 获取Arena  对象并 赋值给其成员变量, 然后, 每个线程通过PoolThreadCache  调用get 方法的时候会拿到它底层的Arena , 也就是说 EventLoop1 拿到 Arena1,  EventLoop2拿到 Arena2, 以此类推, 如下图所示：</p>
<p> <img src="http://files.luyanan.com//img/20191007173949.png"></p>
<p>那么PoolThreadCache 除了可以只在Arena  上进行内存分配，还可以在他底层维护ByteBuf 缓存列表进行分配.举个例子: 我们通过PooledByteBufAllocator 去创建了一个1024字节大小的ByteBuf, 当我们用完释放之后, 我们可能会在其他地方继续分配1024 字节大小的ByteBuf. 这个时候, 其实不需要要在 Arena  上进行内存分配, 而是直接通过 PoolThreadCache 中维护的ByteBuf 的缓存列表直接拿过来返回, 那么, 在  PooledByteBufAllocator 中维护三种规定大小的缓存列表, 分别是三个值 tinyCacheSize、smallCacheSize、normalCacheSize：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledByteBufAllocator</span> <span class="keyword">extends</span> <span class="title">AbstractByteBufAllocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(PooledByteBufAllocator.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_HEAP_ARENA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_DIRECT_ARENA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_ORDER; <span class="comment">// 8192 &lt;&lt; 11 = 16 MiB per chunk</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TINY_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SMALL_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NORMAL_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CACHED_BUFFER_CAPACITY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_TRIM_INTERVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CHUNK_SIZE = (<span class="keyword">int</span>) (((<span class="keyword">long</span>) Integer.MAX_VALUE + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> defaultPageSize = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.pageSize&quot;</span>, <span class="number">8192</span>);</span><br><span class="line">        Throwable pageSizeFallbackCause = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            validateAndCalculatePageShifts(defaultPageSize);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            pageSizeFallbackCause = t;</span><br><span class="line">            defaultPageSize = <span class="number">8192</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DEFAULT_PAGE_SIZE = defaultPageSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> defaultMaxOrder = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.maxOrder&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        Throwable maxOrderFallbackCause = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            validateAndCalculateChunkSize(DEFAULT_PAGE_SIZE, defaultMaxOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            maxOrderFallbackCause = t;</span><br><span class="line">            defaultMaxOrder = <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DEFAULT_MAX_ORDER = defaultMaxOrder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine reasonable default for nHeapArena and nDirectArena.</span></span><br><span class="line">        <span class="comment">// Assuming each arena has 3 chunks, the pool should not consume more than 50% of max memory.</span></span><br><span class="line">        <span class="keyword">final</span> Runtime runtime = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use 2 * cores by default to reduce condition as we use 2 * cores for the number of EventLoops</span></span><br><span class="line">        <span class="comment">// in NIO and EPOLL as well. If we choose a smaller number we will run into hotspots as allocation and</span></span><br><span class="line">        <span class="comment">// deallocation needs to be synchronized on the PoolArena.</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/3888</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> defaultMinNumArena = runtime.availableProcessors() * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> defaultChunkSize = DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER;</span><br><span class="line">        DEFAULT_NUM_HEAP_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">                SystemPropertyUtil.getInt(</span><br><span class="line">                        <span class="string">&quot;io.netty.allocator.numHeapArenas&quot;</span>,</span><br><span class="line">                        (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                                defaultMinNumArena,</span><br><span class="line">                                runtime.maxMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br><span class="line">        DEFAULT_NUM_DIRECT_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">                SystemPropertyUtil.getInt(</span><br><span class="line">                        <span class="string">&quot;io.netty.allocator.numDirectArenas&quot;</span>,</span><br><span class="line">                        (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                                defaultMinNumArena,</span><br><span class="line">                                PlatformDependent.maxDirectMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache sizes</span></span><br><span class="line">        DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.tinyCacheSize&quot;</span>, <span class="number">512</span>);</span><br><span class="line">        DEFAULT_SMALL_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.smallCacheSize&quot;</span>, <span class="number">256</span>);</span><br><span class="line">        DEFAULT_NORMAL_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.normalCacheSize&quot;</span>, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 32 kb is the default maximum capacity of the cached buffer. Similar to what is explained in</span></span><br><span class="line">        <span class="comment">// &#x27;Scalable memory allocation using jemalloc&#x27;</span></span><br><span class="line">        DEFAULT_MAX_CACHED_BUFFER_CAPACITY = SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.maxCachedBufferCapacity&quot;</span>, <span class="number">32</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the number of threshold of allocations when cached entries will be freed up if not frequently used</span></span><br><span class="line">        DEFAULT_CACHE_TRIM_INTERVAL = SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.cacheTrimInterval&quot;</span>, <span class="number">8192</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.numHeapArenas: &#123;&#125;&quot;</span>, DEFAULT_NUM_HEAP_ARENA);</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.numDirectArenas: &#123;&#125;&quot;</span>, DEFAULT_NUM_DIRECT_ARENA);</span><br><span class="line">            <span class="keyword">if</span> (pageSizeFallbackCause == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;-Dio.netty.allocator.pageSize: &#123;&#125;&quot;</span>, DEFAULT_PAGE_SIZE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;-Dio.netty.allocator.pageSize: &#123;&#125;&quot;</span>, DEFAULT_PAGE_SIZE, pageSizeFallbackCause);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxOrderFallbackCause == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;-Dio.netty.allocator.maxOrder: &#123;&#125;&quot;</span>, DEFAULT_MAX_ORDER);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;-Dio.netty.allocator.maxOrder: &#123;&#125;&quot;</span>, DEFAULT_MAX_ORDER, maxOrderFallbackCause);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.chunkSize: &#123;&#125;&quot;</span>, DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER);</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.tinyCacheSize: &#123;&#125;&quot;</span>, DEFAULT_TINY_CACHE_SIZE);</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.smallCacheSize: &#123;&#125;&quot;</span>, DEFAULT_SMALL_CACHE_SIZE);</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.normalCacheSize: &#123;&#125;&quot;</span>, DEFAULT_NORMAL_CACHE_SIZE);</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.maxCachedBufferCapacity: &#123;&#125;&quot;</span>, DEFAULT_MAX_CACHED_BUFFER_CAPACITY);</span><br><span class="line">            logger.debug(<span class="string">&quot;-Dio.netty.allocator.cacheTrimInterval: &#123;&#125;&quot;</span>, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PooledByteBufAllocator DEFAULT =</span><br><span class="line">            <span class="keyword">new</span> PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt;[] heapArenas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt;[] directArenas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> tinyCacheSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> smallCacheSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> normalCacheSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolArenaMetric&gt; heapArenaMetrics;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolArenaMetric&gt; directArenaMetrics;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolThreadLocalCache threadCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(preferDirect, DEFAULT_NUM_HEAP_ARENA, DEFAULT_NUM_DIRECT_ARENA, DEFAULT_PAGE_SIZE, DEFAULT_MAX_ORDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>, nHeapArena, nDirectArena, pageSize, maxOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder,</span><br><span class="line">                DEFAULT_TINY_CACHE_SIZE, DEFAULT_SMALL_CACHE_SIZE, DEFAULT_NORMAL_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"> ..............   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们看到, 在 PooledByteBufAllocator 的构造器中, 分 别 赋 值 了 tinyCacheSize=512 ， smallCacheSize=256 ，<br>normalCacheSize=64。通过这样一种方式，Netty 中给我们预创建固定规格的内存池，大大提高了内存分配的性能。</p>
<h3 id="2-DirectArena-内存分配流程"><a href="#2-DirectArena-内存分配流程" class="headerlink" title="2. DirectArena 内存分配流程"></a>2. DirectArena 内存分配流程</h3><p>Arena 分配内存的基本流程有三个步骤:</p>
<ol>
<li>从对象池中拿到 PooledByteBuf 进行复用</li>
<li>从缓存中进行内存分配</li>
<li>从内存堆中进行内存分配</li>
</ol>
<p>我们以directBuff 为例, 首先来看从对象池中拿到 PooledByteBuf  对象进行复用的情况, 我们依旧跟进到 PooledByteBufAllocator 的 newDirectBuffer()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">       PoolThreadCache cache = threadCache.get();</span><br><span class="line">       PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">       ByteBuf buf;</span><br><span class="line">       <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">           buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">               buf = UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               buf = <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>上面的PoolArena 我们已经清楚, 现在我们直接跟进到 PoolArena 的allocate()  方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">    allocate(cache, buf, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在这个地方其实就非常清晰了, 首先调用 newByteBuf()  方法拿到一个PooledByteBuf 对象, 接下来通过 allocate()  方法在线程私有的 PoolThreadCache 中分配一块内存, 然后buf 里面的内存地址之类的值进行初始化,我们跟进到  newByteBuf()  看一下, 选择 DirectArena 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">           <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>我们发现首先判断是否支持 Unsafe, 默认情况下一般是支持 Unsafe 的, 虽然我们继续进入到 PooledUnsafeDirectByteBuf 的 newInstance()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">PooledByteBuf</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;PooledUnsafeDirectByteBuf&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;PooledUnsafeDirectByteBuf&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PooledUnsafeDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;PooledUnsafeDirectByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PooledUnsafeDirectByteBuf(handle, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">        buf.reuse(maxCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义, 我看到首先就是从 RECYCLER (也就是内存回收站) 对象的 get() 方法中拿到一个buf, 从上面的代码片段来看, RECYCLER 对象实现了一个newObject() 方法, 当回收站里面没有可用的buf时就会去创建一个新的buf. 因为创建的buf 可能是从回收站拿出来的 , 复用前需要重置,因此继续往下看就会调用buf 的reuse()  方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Method must be called before reuse this &#123;<span class="doctag">@link</span> PooledByteBufAllocator&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reuse</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">     maxCapacity(maxCapacity);</span><br><span class="line">     setRefCnt(<span class="number">1</span>);</span><br><span class="line">     setIndex0(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     discardMarks();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现 reuse() 就是对所有的参数重新归为初始状态, 到这里我们已经清楚从内存池获取buf 对象的全过程. 那么接下来, 再回到PoolArena 的 allocate()方法. 看看真实的内存是如何分配出来的, buf 的内存分配主要有两种情况: 分别是:从缓存中进行内存分配和从内存堆中进行内存分配, 我们来看代码, 进入 allocate() 方法具体逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">       <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize</span></span><br><span class="line">           <span class="keyword">int</span> tableIdx;</span><br><span class="line">           PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">           <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">           <span class="keyword">if</span> (tiny) &#123; <span class="comment">// &lt; 512</span></span><br><span class="line">               <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                   <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               tableIdx = tinyIdx(normCapacity);</span><br><span class="line">               table = tinySubpagePools;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                   <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               tableIdx = smallIdx(normCapacity);</span><br><span class="line">               table = smallSubpagePools;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Synchronize on the head. This is needed as &#123;<span class="doctag">@link</span> PoolChunk#allocateSubpage(int)&#125; and</span></span><br><span class="line"><span class="comment">            * &#123;<span class="doctag">@link</span> PoolChunk#free(long)&#125; may modify the doubly linked list as well.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">               <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">               <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                   <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                   <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                   <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                   s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">                       allocationsTiny.increment();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       allocationsSmall.increment();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">               <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">           allocateHuge(buf, reqCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑看起来非常复杂, 其实大部分的逻辑基本上都是判断不同的规格大小, 从其对应的缓存中获取内存, 如果所有的规格都不满足, 那就直接调用allocateHuge()  方法进行真实的内存分配.</p>
<h3 id="3-内存池的内存规格"><a href="#3-内存池的内存规格" class="headerlink" title="3. 内存池的内存规格"></a>3. 内存池的内存规格</h3><p>在前面的源码分析中, 关于内存规格大小我们应该还有些印象, 其实在Netty 内存池中主要设置了四种规格大小的内存: </p>
<ul>
<li><p>tiny 是指0-512byte 之间的规格大小</p>
</li>
<li><p>small 是指512byte - 8kb 之间的规格大小</p>
</li>
<li><p>normal 是指8kb - 16MB 之间的规格大小</p>
</li>
<li><p>buge 是指16MB 以上的</p>
<p>为什么Netty 会选择这些值作为一个分界点呢? 其实在Netty 底层还有一个内存单位的封装. 为了更高效的管理内存, 避免内存浪费, 把每一个区间的内存规格都做了细分. 默认情况下, Netty 将内存规格分为四个部分. Netty 中所有的内存申请是以Chunk 为单位向内存申请的, 大小为16M， 后续的内存分配都是在这个Chunk里面的操作. 8KB 对应的是一个Page, 一个Chunk 会以Page 为单位进行切分. 8KB 对应的Chunk 被划分为2048个Page. 小于8K的对应的是SubPage. 例如: 我们申请的是一段内存空间只有1K , 却给我们分配了一个Page, 显然另外7K 就会被浪费, 所以继续把Page 进行划分, 节省空间 . 如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191008220148.png"></p>
</li>
</ul>
<p>至此, 小伙伴应该已经非常清楚Netty的内存池缓存管理机制了. </p>
<h3 id="4-命中缓存的分配"><a href="#4-命中缓存的分配" class="headerlink" title="4. 命中缓存的分配"></a>4. 命中缓存的分配</h3><p>前面我们简单分析了directArena 内容分配大概流程, 知道其先命中缓存, 如果命中不到, 则去分配一款连续内存. 现在带大家剖析命中缓存的相关逻辑. 前面我们也讲到 PoolThreadCache 中维护了三个缓存数组(实际上是六个, 这<br>里 仅 仅 以 Direct 为 例 , Heap 类 型 的 逻 辑 是 一 样 的 ): tinySubPageDirectCaches, smallSubPageDirectCaches, 和<br>normalDirectCaches 分别代表 tiny 类型, small 类型和 normal 类型的缓存数组）。这三个数组保存在 PoolThreadCache<br>的成员变量中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThreadCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是在构造方法中进行了初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PoolThreadCache(PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena, PoolArena&lt;ByteBuffer&gt; directArena,</span><br><span class="line">                    <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span><br><span class="line">                    <span class="keyword">int</span> maxCachedBufferCapacity, <span class="keyword">int</span> freeSweepAllocationThreshold) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tinySubPageDirectCaches = createSubPageCaches(</span><br><span class="line">                    tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line">            smallSubPageDirectCaches = createSubPageCaches(</span><br><span class="line">                    smallCacheSize, directArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"></span><br><span class="line">            numShiftsNormalDirect = log2(directArena.pageSize);</span><br><span class="line">            normalDirectCaches = createNormalCaches(</span><br><span class="line">                    normalCacheSize, maxCachedBufferCapacity, directArena);</span><br><span class="line"></span><br><span class="line">            directArena.numThreadCaches.getAndIncrement();</span><br><span class="line">        &#125; </span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们以tiny 类型为例 跟到createSubPageCaches 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createSubPageCaches(</span><br><span class="line">           <span class="keyword">int</span> cacheSize, <span class="keyword">int</span> numCaches, SizeClass sizeClass) &#123;</span><br><span class="line">       <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">           MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[numCaches];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> maybe use cacheSize / cache.length</span></span><br><span class="line">               cache[i] = <span class="keyword">new</span> SubPageMemoryRegionCache&lt;T&gt;(cacheSize, sizeClass);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> cache;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从代码来看, 其实就是创建了一个缓存数组, 这个缓存数组的长度, 也就是 numCaches, 在不同的类型, 这个长度不一样 . tiny类型长度是32,small 类型长度为4, normal 类型长度为3.我们知道， 缓存数组中每个节点代表一个缓存对象, 里面维护一个队列. 队列大小由PooledByteBufAllocator 类 中 的 tinyCacheSize, smallCacheSize, normalCacheSize 属性决定的。其中每个缓存对象, 队列中缓存的ByteBuf 大小的固定的. netty 将每种缓存区类型分为了不同的长度规格 ,而每个缓存中的队列缓存的Bytebuf的长度, 都是同一个规格的长度, 而缓冲区数组的长度, 就是规格的数量. 比如: 在 tiny 类型中, Netty将其长度为了32个规格, 每个规格都是16的整数倍, 也就是包含0Byte、16Byte、32Byte、48Byte、64Byte，96Byte…总共32种规格. 而在其缓存数组tinySubPageDirectCaches 中, 这每一种规格代表数组中的一个缓存对象缓存的ByteBuf的大小, 我们以tinySubPageDirectCaches[1]为例,(这里下标选择1是因为下标为0的规格是0Byte, 其实就代表一个空的缓存, 这里不进行举例). 在  <code>tinySubPageDirectCaches[1]</code>  的缓存对象中所缓存的ByteBuf的缓存长度是16Byte, tinySubPageDirectCaches[2] 中缓存的ByteBuf 长度为32Byte. 以此类推, tinySubPageDirectCaches[31]中缓存的 ByteBuf 长度为 496Byte。其具体类型规则的配置如下:<br>tiny:总共 32 个规格, 均是 16 的整数倍, 0Byte, 16Byte, 32Byte, 48Byte, 64Byte, 80Byte, 96Byte……496Byte；</p>
<p>small:4 种规格, 512Byte, 1KB, 2KB, 4KB；</p>
<p>normal: 3种规格, 8KB、16KB、32KB;</p>
<p> 如此我们得出结论PoolThreadCache 中缓存数组的数据结构如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191010211930.png"></p>
<p>在基本了解缓存数组的数据结构后, 我们再继续剖析在缓存中分配内存的逻辑. 回到到 PoolArena 的 allocate() 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">    <span class="comment">//  规格化</span></span><br><span class="line">    <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize</span></span><br><span class="line">        <span class="keyword">int</span> tableIdx;</span><br><span class="line">        PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">        <span class="comment">// 判断是不是tiny</span></span><br><span class="line">        <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">        <span class="keyword">if</span> (tiny) &#123; <span class="comment">// &lt; 512</span></span><br><span class="line">            <span class="comment">// 缓存分配</span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过tinyIdx 拿到tableIdx</span></span><br><span class="line">            tableIdx = tinyIdx(normCapacity);</span><br><span class="line">            <span class="comment">// subpage 的数组</span></span><br><span class="line">            table = tinySubpagePools;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tableIdx = smallIdx(normCapacity);</span><br><span class="line">            table = smallSubpagePools;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到对应的节点</span></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Synchronize on the head. This is needed as &#123;<span class="doctag">@link</span> PoolChunk#allocateSubpage(int)&#125; and</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> PoolChunk#free(long)&#125; may modify the doubly linked list as well.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">            <span class="comment">// 默认情况下head的next 也是自身</span></span><br><span class="line">            <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">                    allocationsTiny.increment();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    allocationsSmall.increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">        <span class="comment">// 首先在缓存上进行内存分配</span></span><br><span class="line">        <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">            <span class="comment">// 分配成功. 返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分配不成功, 做实际的内存分配</span></span><br><span class="line">        allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">        <span class="comment">// 大于这个值, 就不在缓存上分配</span></span><br><span class="line">        allocateHuge(buf, reqCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是通过normalizeCapacity()  方法进行内存规格化, 我们跟到normalizeCapacity 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">normalizeCapacity</span><span class="params">(<span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (reqCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;capacity: &quot;</span> + reqCapacity + <span class="string">&quot; (expected: 0+)&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (reqCapacity &gt;= chunkSize) &#123;</span><br><span class="line">           <span class="keyword">return</span> reqCapacity;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 &gt; tiny</span></span><br><span class="line">       <span class="keyword">if</span> (!isTiny(reqCapacity)) &#123; <span class="comment">// &gt;= 512</span></span><br><span class="line">           <span class="comment">// Doubled</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 找一个2的幂次方数值, 确保数值大小等于reqCapacity</span></span><br><span class="line">           <span class="keyword">int</span> normalizedCapacity = reqCapacity;</span><br><span class="line">           normalizedCapacity --;</span><br><span class="line">           normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">1</span>;</span><br><span class="line">           normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">2</span>;</span><br><span class="line">           normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">4</span>;</span><br><span class="line">           normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">8</span>;</span><br><span class="line">           normalizedCapacity |= normalizedCapacity &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">           normalizedCapacity ++;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (normalizedCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               normalizedCapacity &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> normalizedCapacity;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Quantum-spaced</span></span><br><span class="line">    <span class="comment">// 如果是16 的倍数 , </span></span><br><span class="line">       <span class="keyword">if</span> ((reqCapacity &amp; <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> reqCapacity;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是16的倍数, 变成最大小于当前值的值+ 16</span></span><br><span class="line">       <span class="keyword">return</span> (reqCapacity &amp; ~<span class="number">15</span>) + <span class="number">16</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> 上面代码中 <code>if (!isTiny(reqCapacity))</code> 代表如果大于tiny 类型的大小，也就是512, 则会找一个2的幂次方的数值, 确保这个数值大小等于reqCapacity。如果是tiny , 则继续往下 <code> if ((reqCapacity &amp; 15) == 0)</code>, 这里判断如果是16 的倍数, 则直接返回 . 如果不是16的倍数, 则返回(reqCapacity &amp; ~15) + 16 , 也就是变成最小大于当前值的16 的倍数值。从上面规格化逻辑看出, 这里将缓存大小规格化成固定大小, 确保每个缓存对象缓存的ByteBuf 容量统一. 回到allocate() 方法, ： if(isTinyOrSmall(normCapacity)) 这里是根据规格化后的大小判断是否是tiny 或者small类型, 我们跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capacity &lt; pageSize</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isTinyOrSmall</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (normCapacity &amp; subpageOverflowMask) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是判断如果normCapacity 小于一个page 的大小, 则就是8KB 代表其是tiny 或者small.</p>
<p>继续看allocate() 方法，如果当前大小是tiny 或者small, 则 isTiny(normCapacity)判断是否是 tiny 类型,跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normCapacity &lt; 512</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTiny</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (normCapacity &amp; <span class="number">0xFFFFFE00</span>) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是判断如果小于512, 就认为是tiny.</p>
<p>再继续看 allocate() 方法, 如果是tiny, 则通过 cache.allocateTiny(this, buf, reqCapacity, normCapacity)在缓存上分配. 我们就以tiny 类型为例, 分析在缓存上分配ByteBuf 的流, allocateTiny 是缓存分配的入口. 我们跟进去: 进入到了PoolThreadCache 的 allocateTiny()方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocateTiny</span><span class="params">(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allocate(cacheForTiny(area, normCapacity), buf, reqCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个方法cacheForTiny(area, normCapacity), 这个方法的作用是根据normCapacity 找到tiny类型缓存数组中的一个缓存对象, 我们跟进去cacheForTiny方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForTiny(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = PoolArena.tinyIdx(normCapacity);</span><br><span class="line">      <span class="keyword">if</span> (area.isDirect()) &#123;</span><br><span class="line">          <span class="keyword">return</span> cache(tinySubPageDirectCaches, idx);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache(tinySubPageHeapCaches, idx);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>PoolArena.tinyIdx(normCapacity)是找到tiny类型缓存数组的下标, 继续跟进到 tinyIdx 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tinyIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> normCapacity &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里相当于直接将 normCapacity 除以16, 通过前面的内容我们知道，  tiny 类型缓存数组中的每个元素规格化的数据都是16的倍数, 所以通过这种方式可以找到其下标, 如果是16Byte 会拿到下标为1的元素， 如果是32Byte 会拿到下标为2的元素.</p>
<p>回到acheForTiny()方法中： if (area.isDirect()) 这里是判断是否分配堆外内存, 因为我们是按照堆外内存进行举例的, 所以这里是true, 再继续跟到到 cache(tinySubPageDirectCaches, idx)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MemoryRegionCache&lt;T&gt; <span class="title">cache</span><span class="params">(MemoryRegionCache&lt;T&gt;[] cache, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span> || idx &gt; cache.length - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache[idx];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到直接通过下标的方式拿到了缓存数组中的对象, 回到到 PoolThreadCache 的 allocateTiny()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocateTiny</span><span class="params">(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allocate(cacheForTiny(area, normCapacity), buf, reqCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到了缓存对象后, 我们跟到 <code>allocate(cacheForTiny(area, normCapacity), buf, reqCapacity)</code>  方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// no cache found so just return false here</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> allocated = cache.allocate(buf, reqCapacity);</span><br><span class="line">      <span class="keyword">if</span> (++ allocations &gt;= freeSweepAllocationThreshold) &#123;</span><br><span class="line">          allocations = <span class="number">0</span>;</span><br><span class="line">          trim();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> allocated;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>分析上面的代码, 看到cache.allocate(buf, reqCapacity) 进行继续分配, 再继续往里跟, 来到内部类MemoryRegionCache 的 allocate(PooledByteBuf buf, int reqCapacity)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Allocate something out of the cache if possible and remove the entry from the cache.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">         Entry&lt;T&gt; entry = queue.poll();</span><br><span class="line">         <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         initBuf(entry.chunk, entry.handle, buf, reqCapacity);</span><br><span class="line">         entry.recycle();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// allocations is not thread-safe which is fine as this is only called from the same thread all time.</span></span><br><span class="line">         ++ allocations;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法, 首先通过 queue.poll()这种方式弹出一个Entry, 我们之前分析过MemoryRegionCache 维护这一个队列, 而队列中的每一个值是一个entry, 我们简单来看一下Entry 这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle;</span><br><span class="line">          PoolChunk&lt;T&gt; chunk;</span><br><span class="line">          <span class="keyword">long</span> handle = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          Entry(Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle) &#123;</span><br><span class="line">              <span class="keyword">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              chunk = <span class="keyword">null</span>;</span><br><span class="line">              handle = -<span class="number">1</span>;</span><br><span class="line">              recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p> 我们重点关注 chunk 和handler 这两个属性,     chunk 代表一块连续的内存, 我们之前简单介绍过, Netty 是通过chunk 为单位进行内存分配的. handler 相当于一个指针, 可以唯一定位到chunk 里面的一块连续的内存. 这样, 通过chunk和handler 就可以定位到ByteBuf 中的指定的一块连续的内存, 有关ByteBuf 相关的读写， 都会在这块内存中进行, 现在再回到MemoryRegionCache 的 allocate(PooledByteBuf buf,int reqCapacity)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Allocate something out of the cache if possible and remove the entry from the cache.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">     Entry&lt;T&gt; entry = queue.poll();</span><br><span class="line">     <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     initBuf(entry.chunk, entry.handle, buf, reqCapacity);</span><br><span class="line">     entry.recycle();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// allocations is not thread-safe which is fine as this is only called from the same thread all time.</span></span><br><span class="line">     ++ allocations;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>弹出entry后, 通过<code>initBuf(entry.chunk, entry.handle, buf, reqCapacity)</code>  这种方式给ByteBuf 初始化， 这里参数传入我们刚才分析过的 当前的entry的chunk 和handler, 因为我们分析的 tiny 类型的缓存对象是SubPageMemoryRegionCache 类型, 所以继续回到SubPageMemoryRegionCache 类的initBuf(entry.chunk, entry.handle, buf, reqCapacity)方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">        chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的chunk 调用了了 initBufWithSubpage(buf, handle, reqCapacity)方法, 其实就是PoolChunk 类中的方法, 我们继续initBufWithSubpage() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">      initBufWithSubpage(buf, handle, bitmapIdx(handle), reqCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>上面代码中, 调用了 bitmapIdx()方法, 有关 bitmapIdx()方法相关的逻辑, 会再后面进行剖析,这里继续往里看, 看 initBufWithSubpage 的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> bitmapIdx, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> bitmapIdx != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"></span><br><span class="line">      PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">      <span class="keyword">assert</span> subpage.doNotDestroy;</span><br><span class="line">      <span class="keyword">assert</span> reqCapacity &lt;= subpage.elemSize;</span><br><span class="line"></span><br><span class="line">      buf.init(</span><br><span class="line">          <span class="keyword">this</span>, handle,</span><br><span class="line">          runOffset(memoryMapIdx) + (bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>) * subpage.elemSize, reqCapacity, subpage.elemSize,</span><br><span class="line">          arena.parent.threadCache());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们先关注 init()  方法, 因为我们是以PooledUnsafeDirectByteBuf 为例,所以这里走的是PooledUnsafeDirectByteBuf 的  init() 方法, 进入init() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;ByteBuffer&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength,</span></span></span><br><span class="line"><span class="function"><span class="params">            PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.init(chunk, handle, offset, length, maxLength, cache);</span><br><span class="line">      initMemoryAddress();</span><br><span class="line">  &#125;	</span><br></pre></td></tr></table></figure>

<p>首先调用了父类的init()  方法，继续跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">assert</span> chunk != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">      <span class="keyword">this</span>.handle = handle;</span><br><span class="line">      memory = chunk.memory;</span><br><span class="line">      <span class="keyword">this</span>.offset = offset;</span><br><span class="line">      <span class="keyword">this</span>.length = length;</span><br><span class="line">      <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">      tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是将PooledUnsafeDirectByteBuf 的各个属性进行了初始化:</p>
<p>this.chunk = chunk 这里初始化了 chunk, 代表当前的 ByteBuf 是在哪一块内存中分配的。</p>
<p>this.handle = handle 这里初始化了 handle, 代表当前的 ByteBuf 是这块内存的哪个连续内存。</p>
<p>有关 offset 和 length, 我们会在之后再分析, 在这里我们只需要知道, 通过缓存分配 ByteBuf, 我们只需要通过一个chunk 和 handle, 就可以确定一块内存，以上就是通过缓存分配 ByteBuf 对象的全过程。</p>
<p>现在，我们回到 MemoryRegionCache 的 allocate(PooledByteBuf buf, int reqCapacity)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">           Entry&lt;T&gt; entry = queue.poll();</span><br><span class="line">           <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           initBuf(entry.chunk, entry.handle, buf, reqCapacity);</span><br><span class="line">           entry.recycle();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// allocations is not thread-safe which is fine as this is only called from the same thread all time.</span></span><br><span class="line">           ++ allocations;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>分析完了initBuf() 方法，再继续往下看, entry.recycle() 这步是将 entry 对象进行回收, 因为entry 对象弹出后没有在被引用，可能gc 会将entry 对象进行回收, netty为了将对象进行循环利用, 就将其对象放在回收站进行回收,我们跟进到recycle() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              chunk = <span class="keyword">null</span>;</span><br><span class="line">              handle = -<span class="number">1</span>;</span><br><span class="line">              recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>chunk = null  和handler = -1  表示当前entry 不指向任何一块内存,recyclerHandle.recycle(this) 将当前entry 回收, 以上就是命中缓存的流程, 因为这里我们是假设缓存中有值的情况下， 如果第一次分配, 缓存中是没有值的, 那么在缓存中没有值的i情况下, Netty 是如何进行分配的呢? 我们在后面再详细分析：</p>
<p>最后, 我们简单总结一下MemoryRegionCache 对象的基本结构, 如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191010224444.png"></p>
<h3 id="5-Page-级别的内存分配"><a href="#5-Page-级别的内存分配" class="headerlink" title="5. Page 级别的内存分配"></a>5. Page 级别的内存分配</h3><p>之前我们介绍过,Netty 内存分配的单位是chunk, 一个chunk 的大小是16MB,实际上每个chunk都以双向链表的形式保存在一个chunkList中, 而多个chunkList 同样也是双向链表进行关联的, 大概结构如下:</p>
<p><img src="http://files.luyanan.com//img/20191010225320.png"></p>
<p>在chunkList 中, 是根据chunk 的内存使用率归到一个chunkList中, 这样, 在内存分配时, 会根据百分比找到相应的chunkList, 在chunkList 中选择一个chunk 进行内存分配, 我们来看PoolArena 有关 chunkList 的成员变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line">q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line">q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line">qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br></pre></td></tr></table></figure>

<p>这里总共定义了6个chunkList, 并在构造方法中将其进行初始化, 我们跟到其构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PoolArena</span><span class="params">(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.parent = parent;</span><br><span class="line">       <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">       <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">       <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">       <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">       subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">       tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) &#123;</span><br><span class="line">           tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       numSmallSubpagePools = pageShifts - <span class="number">9</span>;</span><br><span class="line">       smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smallSubpagePools.length; i ++) &#123;</span><br><span class="line">           smallSubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line">       q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">       q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">       q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line">       q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line">       qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br><span class="line"></span><br><span class="line">       q100.prevList(q075);</span><br><span class="line">       q075.prevList(q050);</span><br><span class="line">       q050.prevList(q025);</span><br><span class="line">       q025.prevList(q000);</span><br><span class="line">       q000.prevList(<span class="keyword">null</span>);</span><br><span class="line">       qInit.prevList(qInit);</span><br><span class="line"></span><br><span class="line">       List&lt;PoolChunkListMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolChunkListMetric&gt;(<span class="number">6</span>);</span><br><span class="line">       metrics.add(qInit);</span><br><span class="line">       metrics.add(q000);</span><br><span class="line">       metrics.add(q025);</span><br><span class="line">       metrics.add(q050);</span><br><span class="line">       metrics.add(q075);</span><br><span class="line">       metrics.add(q100);</span><br><span class="line">       chunkListMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先通过new PoolChunkList() 这种方式将每个chunkList 进行创建,我们以q050 = new PoolChunkList(q075, 50, 100, chunkSize)  为例进行简单介绍, q075 表示当前q50 的下一个节点是q075, 刚才我们讲过ChunkList 是通过双向链表进行关联的. 所以这里不难理解, 参数50 和100 表示当前chunkList 中存储的chunk 的内存使用率都在50% 到100% 之间. 最后chunkSize 为其设置大小, 创建完ChunkList 之后, 再设置其上一个节点,, q050.prevList(q025)  为例, 这里代表当前chunkList 的上一个节点是q025, 以这种方式创建完成之后, chunkList 的节点关系就变成了如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191011103228.png"></p>
<p>Netty中,chunk 又包含了多个Page, 每个page 的大小为8KB, 如果要分配16KB的内存, 就要在chunk 汇总找到连续的两个page就可以分配, 对应关系如下:</p>
<p><img src="http://files.luyanan.com//img/20191011103351.png"></p>
<p>很多场景下,为缓冲区分配8KB的内存也是一种浪费, 比如只需要分配2KB的缓存区, 如果使用8KB的就会造成6KB的浪费, 这种情况下，Netty 又会将page 切分成多个subpage, 每个subpage 大小要根据分配的缓冲区大小而指定, 比如要分配2KB 的内存, 就会将一个page切分成4个subpage, 每个subpage 的大小为2KB, 如下图:</p>
<p><img src="http://files.luyanan.com//img/20191011104117.png"></p>
<p>来看看PoolSubpage 的基本结构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolSubpage</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">PoolSubpageMetric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PoolChunk&lt;T&gt; chunk;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> memoryMapIdx;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> runOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] bitmap;</span><br><span class="line"></span><br><span class="line">    PoolSubpage&lt;T&gt; prev;</span><br><span class="line">    PoolSubpage&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doNotDestroy;</span><br><span class="line">    <span class="keyword">int</span> elemSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxNumElems;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bitmapLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextAvail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numAvail;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chunk  代表其子页属于哪个chunk, bitmap 用于记录子页的内存分配情况, prev和 next, 代表子页是按照双向链表进行关联的, 这里分别指向上一个和下一个节点, elemSize 属性代表就是这个子页是按照多大内存进行划分的, 如果按照1KB 进行划分, 则可以划分出8个子页, 简单介绍了内存分配的数据结构.</p>
<p>我们开始剖析Netty 级别上分配内存的流程, 还是回到PoolArena 的 allocate 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">       <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize</span></span><br><span class="line">           <span class="keyword">int</span> tableIdx;</span><br><span class="line">           PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">           <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">           <span class="keyword">if</span> (tiny) &#123; <span class="comment">// &lt; 512</span></span><br><span class="line">               <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                   <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               tableIdx = tinyIdx(normCapacity);</span><br><span class="line">               table = tinySubpagePools;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                   <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               tableIdx = smallIdx(normCapacity);</span><br><span class="line">               table = smallSubpagePools;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Synchronize on the head. This is needed as &#123;<span class="doctag">@link</span> PoolChunk#allocateSubpage(int)&#125; and</span></span><br><span class="line"><span class="comment">            * &#123;<span class="doctag">@link</span> PoolChunk#free(long)&#125; may modify the doubly linked list as well.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">               <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">               <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                   <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                   <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                   <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                   s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">                       allocationsTiny.increment();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       allocationsSmall.increment();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">               <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">           allocateHuge(buf, reqCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们之前讲过, 如果在缓存中分配不成功, 则会开辟一块连续的内存进行缓冲区分配, 这里我们先跳过isTinyOrSmall(normCapacity)往后的代码, 之后再来分析。</p>
<p>首先if (normCapacity &lt;= chunkSize) 说明其小于16KB , 然后首先在缓存中分配, 以为最初缓存中没有值, 所以会走到 allocateNormal(buf, reqCapacity, normCapacity), 这里实际上就是在page级别上进行分配, 分配一个或者多个page 的空间, 我们跟进到 allocateNormal()  方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 首先在原来的chunk 上进行内存分配(1)   </span></span><br><span class="line">    <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            ++allocationsNormal;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add a new chunk.</span></span><br><span class="line">    <span class="comment">// 创建chunk 进行内存分配(2)</span></span><br><span class="line">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">        <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line">        ++allocationsNormal;</span><br><span class="line">        <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化 byteBuf(3)</span></span><br><span class="line">        c.initBuf(buf, handle, reqCapacity);</span><br><span class="line">        qInit.add(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要拆解了如下步骤:</p>
<ol>
<li>在原有的chunk 中进行分配</li>
<li>创建chunk 进行分配</li>
<li>初始化byteBuf </li>
</ol>
<p>首先我们来看第一步, 在原有的chunk 中进行分配:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">         q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">         q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">         ++allocationsNormal;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>我们之前讲过, chunkList 是存储不同内存使用量的chunk 集合,每个chunkList 通过双向链表的形式进行关联, 这里的 q050.allocate(buf, reqCapacity, normCapacity)  就代表首先在q050 这个chunkList 进行内存分配, 我们以q050 为例进行分析, 跟到q050.allocate(buf, reqCapacity, normCapacity)方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || normCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="comment">// Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</span></span><br><span class="line">            <span class="comment">// be handled by the PoolChunks that are contained in this PoolChunkList.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  从head 节点往下遍历</span></span><br><span class="line">        <span class="keyword">for</span> (PoolChunk&lt;T&gt; cur = head;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> handle = cur.allocate(normCapacity);</span><br><span class="line">            <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.initBuf(buf, handle, reqCapacity);</span><br><span class="line">                <span class="keyword">if</span> (cur.usage() &gt;= maxUsage) &#123;</span><br><span class="line">                    remove(cur);</span><br><span class="line">                    nextList.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会从head节点进行往下遍历, <code>ong handle = cur.allocate(normCapacity)</code>  表示对于每个chunk 都尝试去分配, if (handle &lt; 0) 说明没有分配到, 则通过 cur = cur.next 找到下一个节点继续进行分配, 我们讲过chunk 也是通过双向链表进行关联的. 所以对这块逻辑应该不会陌生, 如果handler 大于0 说明已经分配到内存, 则通过cur.initBuf(buf, handle, reqCapacity)对 byteBuf 进行初始化；if (cur.usage() &gt;= maxUsage) 代表当前 chunk 的内存使用率大于其最大<br>使用率, 则通过 remove(cur)从当前的 chunkList 中移除, 再通过 nextList.add(cur)添加到下一个 chunkList 中。<br>我们再回到 PoolArena 的 allocateNormal()方法中：</p>
<p>看第二步 PoolChunk c = newChunk(pageSize, maxOrder, pageShifts, chunkSize)，这里的参数 pageSize 是 8192, 也就是 8KB。</p>
<p>maxOrder 为11;</p>
<p>pageShifts 为 13, 2 的 13 次方正好是 8192, 也就是 8KB；<br>chunkSize 为 16777216, 也就是 16MB。</p>
<p>因为我们分析的是堆外内存, newChunk(pageSize, maxOrder, pageShifts, chunkSize)所以会走到 DirectArena 的<br>    ()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newChunk</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(</span><br><span class="line">               <span class="keyword">this</span>, allocateDirect(chunkSize),</span><br><span class="line">               pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里直接通过构造函数创建了一个chunk , allocateDirect(chunkSize) 这里是通过JDK 的api 申请一块直接内存, 我们跟到 PoolChunk 的构造函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize) &#123;</span><br><span class="line">       unpooled = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">this</span>.arena = arena;</span><br><span class="line">    <span class="comment">// memory 为一个ByteBuf</span></span><br><span class="line">       <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    <span class="comment">// 8KB</span></span><br><span class="line">       <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    <span class="comment">// 13</span></span><br><span class="line">       <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">    <span class="comment">// 11   </span></span><br><span class="line">    <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">       <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">       unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);</span><br><span class="line">       log2ChunkSize = log2(chunkSize);</span><br><span class="line">       subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">       freeBytes = chunkSize;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">assert</span> maxOrder &lt; <span class="number">30</span> : <span class="string">&quot;maxOrder should be &lt; 30, but is: &quot;</span> + maxOrder;</span><br><span class="line">       maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Generate the memory map.</span></span><br><span class="line">     <span class="comment">//  节点数量为4096   </span></span><br><span class="line">    memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 也就是4096个节点</span></span><br><span class="line">       depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">       <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// d 相当于一个深度, 赋值的内容代表当前节点的深度</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class="comment">// move down the tree one level at a time</span></span><br><span class="line">           <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">               <span class="comment">// in each level traverse left to right and set value to the depth of subtree</span></span><br><span class="line">               memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">               depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">               memoryMapIndex ++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       subpages = newSubpageArray(maxSubpageAllocs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先将传入的参数的值进行赋值 <code>this.memory = memory</code>  就是将参数中创建的堆外内存进行保存, 就是chunk 所指向的那块连续的内存, 在这个chunk 中所分配的BteBuf, 都会在这块内存中进行读写.</p>
<p>我们重点关注 memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1] 和 depthMap = new byte[memoryMap.length]<br>这两步：首先看 memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1]；这里初始化了一个字节数组 memoryMap, 大<br>小为 maxSubpageAllocs &lt;&lt; 1, 也就是 4096；depthMap = new byte[memoryMap.length] 同样也是初始化了一个字<br>节数组, 大小为 memoryMap 的大小, 也就是 4096。继续往下分析之前, 我们看 chunk 的一个层级关系。</p>
<p><img src="http://files.luyanan.com//img/20191011112610.png"></p>
<p>这是一个二叉树的结构，左侧的数字代表层级, 右侧代表一块连续的内存, 每个父节下又拆分成多个子节点, 最顶层表示的内存范围为0-16KB， 其下又分为两层, 范围为0-8MB，8-16MB, 以此类推, 最后到11层, 以8KB 的大小划分, 也就是一个page 的大小.</p>
<p>如果我们分配一个8MB 的缓冲区, 则会将第二层的第一个节点, 也就是0-8 这样连续的内存进行分配, 分配完成后会将这个节点设置为不可用, 结合上面的图, 我们再看构造函数中的for 循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class="comment">// move down the tree one level at a time</span></span><br><span class="line">         <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">             <span class="comment">// in each level traverse left to right and set value to the depth of subtree</span></span><br><span class="line">             memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">             depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">             memoryMapIndex ++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>实际上这个for循环就是将上面的结构包装成一个字节数组memoryMap, 外层循环用于控制层数, 内层循环用于控制里面每层的节点, 这里经过循环后， memoryMap 和depthMap 内容为以下表现形式：</p>
<blockquote>
<p>[0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4………..]</p>
</blockquote>
<p>这里注意一下, 因为程序汇总数组的下标是从1开始设置的, 所以第零个节点元素为默认值0.</p>
<p>这里数字代表层级, 同时也代表了当前层级的节点, 相同的数字个数就是这一层级的节点数.</p>
<p>其中0 为2(因为这里分配时下标是从1开始的, 所以第0个位置的默认是0, 实际上第0层元素只有一个, 就是头节点), 1为2, 2为4, 3为8, 4为16, n 为2的n次方个, 也及时11有2 的11次方个.</p>
<p>我们再回到PoolArena 的 allocateNormal()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">         q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">         q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">         ++allocationsNormal;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Add a new chunk.</span></span><br><span class="line">     PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">     <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line">     ++allocationsNormal;</span><br><span class="line">     <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line">     c.initBuf(buf, handle, reqCapacity);</span><br><span class="line">     qInit.add(c);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们继续剖析 long handle = c.allocate(normCapacity) 这步，跟到 allocate(normCapacity)中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long allocate(int normCapacity) &#123;</span><br><span class="line">     if ((normCapacity &amp; subpageOverflowMask) !&#x3D; 0) &#123; &#x2F;&#x2F; &gt;&#x3D; pageSize</span><br><span class="line">         return allocateRun(normCapacity);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         return allocateSubpage(normCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>如果分配的以page 为单位, 则走到allocateRun(normCapacity) 方法中, 跟进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateRun</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = maxOrder - (log2(normCapacity) - pageShifts);</span><br><span class="line">    <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    freeBytes -= runLength(id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int d = maxOrder - (log2(normCapacity) - pageShifts) 表示根据 normCapacity 计算出第几层；</p>
<p>int id = allocateNode(d) 表示根据层级关系, 去分配一个节点, 其中 id 代表 memoryMap 中的下标。</p>
<p>我们跟到 allocateNode()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">allocateNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标初始值为1</span></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 代表 当前层级第一个节点的初始下标</span></span><br><span class="line">        <span class="keyword">int</span> initial = - (<span class="number">1</span> &lt;&lt; d); <span class="comment">// has last d bits = 0 and rest all = 1</span></span><br><span class="line">    <span class="comment">// 获取第一个节点的值</span></span><br><span class="line">        <span class="keyword">byte</span> val = value(id);</span><br><span class="line">    <span class="comment">// 如果值大于层级, 说明chunk 不可用</span></span><br><span class="line">        <span class="keyword">if</span> (val &gt; d) &#123; <span class="comment">// unusable</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 当前下标对应的节点值如果小于层级,或者当前下标小于层级的初始下标</span></span><br><span class="line">        <span class="keyword">while</span> (val &lt; d || (id &amp; initial) == <span class="number">0</span>) &#123; <span class="comment">// id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</span></span><br><span class="line">            <span class="comment">// 当前下标乘以2, 代表当前节点的子节点的初始位置</span></span><br><span class="line">            id &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 获取id 位置的值</span></span><br><span class="line">            val = value(id);</span><br><span class="line">            <span class="comment">// 如果当前节点值大于层数(节点不可用)</span></span><br><span class="line">            <span class="keyword">if</span> (val &gt; d) &#123;</span><br><span class="line">                <span class="comment">// id 为偶数则+1, id 为奇数则-1(拿的是其兄弟节点)</span></span><br><span class="line">                id ^= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 获取id 的值</span></span><br><span class="line">                val = value(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> value = value(id);</span><br><span class="line">        <span class="keyword">assert</span> value == d &amp;&amp; (id &amp; initial) == <span class="number">1</span> &lt;&lt; d : String.format(<span class="string">&quot;val = %d, id &amp; initial = %d, d = %d&quot;</span>,</span><br><span class="line">                value, id &amp; initial, d);</span><br><span class="line">    <span class="comment">// 将找到的节点设置为不可用</span></span><br><span class="line">        setValue(id, unusable); <span class="comment">// mark as unusable</span></span><br><span class="line">    <span class="comment">// 逐层往上标记被使用    </span></span><br><span class="line">    updateParentsAlloc(id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里是实际上从一个节点往下找, 找到层级为d 未被使用的节点，我们可以通过注释体会其逻辑, 找到相关节点后通过setValue 将当前节点设置为不可用, 其中id 是当前节点的下标, unusable 代表一个不可用的值, 这里是12, 以为我们的层级只有12层, 所以设置为12之后就相当于标记不可用,设置成不可用之后, 通过updateParentsAlloc(id) 逐层设置为被使用, 我们跟进 updateParentsAlloc() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsAlloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 取到当前节点的父节点id</span></span><br><span class="line">        <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取当前节点的值</span></span><br><span class="line">        <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line">        <span class="comment">// 找到当前节点的兄弟节点</span></span><br><span class="line">        <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果当前节点值大小兄弟节点,则保存当前节点值到val,否则, 保存兄弟节点值到val.</span></span><br><span class="line">        <span class="comment">// 如果当前节点是不可用的, 则当前节点值是12, 大于兄弟节点的值,所以这里将兄弟节点的值进行保存</span></span><br><span class="line">        <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">        <span class="comment">// 将val 的值设置为父节点下标所对应的值</span></span><br><span class="line">        setValue(parentId, val);</span><br><span class="line">        <span class="comment">// id 设置为父节点id, 继续循环</span></span><br><span class="line">        id = parentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实是循环将兄弟节点的值替换成父节点的值, 我们可以通过注释仔细的进行逻辑分析, 如果实在理解有困难, 我通过画图帮助大家理解, 简单起见, 我们这里只设置为三层：</p>
<p><img src="http://files.luyanan.com//img/20191011120814.png"></p>
<p>我们模拟其分配场景, 假设只有三层, 其中 index 代表数组 memoryMap 的下标, value 代表其值, memoryMap 中的值<br>就为[0, 0, 1, 1, 2, 2, 2, 2]。我们要分配一个 4MB 的 byteBuf, 在我们调用 allocateNode(int d)中传入的 d 是 2, 也就是<br>第二层。根据我们上面分分析的逻辑这里会找到第二层的第一个节点, 也就是 0-4mb 这个节点, 找到之后将其设置为 不可用, 这样 memoryMap 中的值就为[0, 0, 1, 1, 12, 2, 2, 2]，二叉树的结构就会变为：</p>
<p><img src="http://files.luyanan.com//img/20191011120905.png"></p>
<p>注意标红部分, 将 index 为 4 的节点设置为了不可用。将这个节点设置为不可用之后, 则会将进行向上设置不可用, 循<br>环将兄弟节点数值较小的节点替换到父节点, 也就是将 index 为 2 的节点的值替换成了 index 的为 5 的节点的值, 这样<br>数组的值就会变为[0, 1, 2, 1, 12, 2, 2, 2]，二叉树的结构变为：</p>
<p><img src="http://files.luyanan.com//img/20191011120943.png"></p>
<blockquote>
<p>注意: 这里节点标红仅仅代表节点变化,并不是当前节点为不可用状态, 真正不可用状态的判断依据是value 的值为12</p>
</blockquote>
<p>这样, 如果再次分配一个 4MB 内存的 ByteBuf, 根据其逻辑, 则会找到第二层的第二个节点, 也就是 4-8MB。再根据我<br>们的逻辑, 通过向上设置不可用, index为2就会设置成不可用状态, 将value的值设置为12, 数组数值变为[0, 1, 12, 1, 12, 12, 2, 2]二叉树如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20191011121137.png"></p>
<p>这样我们看到, 通过分配两个4mb 的ByteBuf 之后, 当前节点和其父节点都会设置成不可用状态, 当index =2 的节点设置为不可用之后, 将不会再找到这个节点下的子节点. 以此类推, 直到所有的内存分配完毕的时候, index 为1 的节点也会变成不可用状态, 这样所有的page 就分配完毕, chunk 中再无可用的节点.  现在再回到 PoolArena的allocateNormal()<br>方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">           q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">           q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">           ++allocationsNormal;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Add a new chunk.</span></span><br><span class="line">       PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">       <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line">       ++allocationsNormal;</span><br><span class="line">       <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line">       c.initBuf(buf, handle, reqCapacity);</span><br><span class="line">       qInit.add(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的逻辑我们知道<code>ong handle = c.allocate(normCapacity)</code>  这一步其实返回的就是 memoryMap 的一个下标, 通过这个下标我们能唯一的定义一块内存, 继续往下跟, 通过过 c.initBuf(buf, handle, reqCapacity)初始化 ByteBuf 之后, 通过 qInit.add(c)将新创建的 chunk 添加到 chunkList 中，我们跟到 initBuf 方法中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">      <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line">      <span class="keyword">if</span> (bitmapIdx == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">byte</span> val = value(memoryMapIdx);</span><br><span class="line">          <span class="keyword">assert</span> val == unusable : String.valueOf(val);</span><br><span class="line">          buf.init(<span class="keyword">this</span>, handle, runOffset(memoryMapIdx), reqCapacity, runLength(memoryMapIdx),</span><br><span class="line">                   arena.parent.threadCache());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中, 看出通过memoryMapIdx(handle)找到 memoryMap 的下标, 其实就是 handle 的值。bitmapIdx(handle)<br>是有关 subPage 中使用到的逻辑, 如果是 page 级别的分配, 这里只返回 0, 所以进入到 if 块中。if 中首先断言当前节<br>点是不是不可用状态, 然后通过 init 方法进行初始化。其中 runOffset(memoryMapIdx)表示偏移量, 偏移量相当于分配<br>给缓冲区的这块内存相对于 chunk 中申请的内存的首地址偏移了多少。参数 runLength(memoryMapIdx), 表示根据下<br>标获取可分配的最大长度。我们跟到 init()方法中, 这里会走到 PooledByteBuf 的 init()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> chunk != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">        <span class="keyword">this</span>.handle = handle;</span><br><span class="line">        memory = chunk.memory;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码又是我们熟悉的, 将属性进行了初始化, 以上就是完整的DirectUnsafePooledByteBuf 在Page 级别的完整分配的流程, 逻辑也是复杂的.</p>
<h3 id="6-SubPage-级别的内存分配"><a href="#6-SubPage-级别的内存分配" class="headerlink" title="6. SubPage 级别的内存分配."></a>6. SubPage 级别的内存分配.</h3><p>通过之前的学习我们知道,如果我们分配一个缓冲区大小远小于page, 则直接在一个page 上进行分配则会造成内存浪费, 所以需要将page 继续进行切分成多个子块进行分配, 子块分配的个数根据你要分配的缓冲区大小而定, 比如只需要分配1KB的内存, 就会将一个page 分为8等分. 简单起见, 我们这里仅仅以16字节为例, 讲解其分配逻辑, 在分析其逻辑前, 首先看 PoolArean 的一个属性:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个属性是一个PoolSubpage 的数组, 有点类似于一个 subpage 的缓存, 我们创建一个subpage 之后, 会将创建的subpage 与该属性其中的每个关联, 下次在分配的的时候可以直接通过该属性的元素去找关联的subpage, 我们其中是在构造方法中初始化的, 看构造方法中其初始化的代码:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tinySubpagePools &#x3D; newSubpagePoolArray(numTinySubpagePools);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里的 numTinySubpagePools 为32, 跟到 <code>newSubpagePoolArray(numTinySubpagePools)</code>  方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> PoolSubpage&lt;T&gt;[] newSubpagePoolArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolSubpage[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接创建了一个 PoolSubpage 数组, 长度为32, 在构造方法中创建完毕后, 会通过循环为其赋值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) &#123;</span><br><span class="line">          tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>继续跟进到 <code>newSubpagePoolHead(pageSize);</code> 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PoolSubpage&lt;T&gt; <span class="title">newSubpagePoolHead</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    PoolSubpage&lt;T&gt; head = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(pageSize);</span><br><span class="line">    head.prev = head;</span><br><span class="line">    head.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>newSubpagePoolHead</code> 方法中创建了一个 PoolSubpage 对象head.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.prev = head;</span><br><span class="line">head.next = head;</span><br></pre></td></tr></table></figure>

<p>这种写法我们知道SubPage 其实也是个双向链表,这里的将head的上一个节点和下一个节点设置为自身,有关PoolSubpage 的关联关系, 我们稍后分析, 这样通过循环创建 PoolSubpage, 总共会创建出来32个subpage, 其中每个subpage 实际代表一块内存大小。</p>
<p><img src="http://files.luyanan.com//img/20191011140957.png"></p>
<p>tinySubpagePools 的结构就有点类似之前的缓存数据 tinySubPageDirectCaches 的结构, 了解了tinySubpagePools  属性, 我们看 看 PoolArean 的 allocate 方法, 也就是缓冲区的入口方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">        <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize</span></span><br><span class="line">            <span class="keyword">int</span> tableIdx;</span><br><span class="line">            PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">            <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">            <span class="keyword">if</span> (tiny) &#123; <span class="comment">// &lt; 512</span></span><br><span class="line">                <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                    <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tableIdx = tinyIdx(normCapacity);</span><br><span class="line">                table = tinySubpagePools;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                    <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tableIdx = smallIdx(normCapacity);</span><br><span class="line">                table = smallSubpagePools;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Synchronize on the head. This is needed as &#123;<span class="doctag">@link</span> PoolChunk#allocateSubpage(int)&#125; and</span></span><br><span class="line"><span class="comment">             * &#123;<span class="doctag">@link</span> PoolChunk#free(long)&#125; may modify the doubly linked list as well.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">                <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">                <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                    <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                    <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                    <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                    s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">                        allocationsTiny.increment();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        allocationsSmall.increment();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">            allocateHuge(buf, reqCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 之前我们在这个方法剖析过page级别相关内存分配逻辑, 现在我们来看subpage 级别分配的相关逻辑, 假设我们分配16字节的缓存区, <code>isTinyOrSmall(normCapacity)</code>  就会返回true, 进入if块, 同样 <code>if (tiny)</code>  这里会返回true. 继续跟进到 <code>if (tiny)</code> 的逻辑, 首先会在缓存中分配缓冲区, 如果分配不到, 就开辟一块内存进行内存分配, 先看着一步:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableIdx &#x3D; tinyIdx(normCapacity);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这是通过 normCapacity 拿到tableIdx, 我们跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tinyIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> normCapacity &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里将 normCapacity  除以16, 其实也就是1, 我们回到 到 PoolArena 的 allocate()方法继续看：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#x3D; tinySubpagePools;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里将tinySubpagePools 赋值到局部变量table, 继续往下看:</p>
<p><code>final PoolSubpage head = table[tableIdx]</code> 这步时通过下标拿到一个 PoolSubpage, 因为我们以16字节为例, 所以我们拿到下标为1的PoolSubpage, 对应的内存大小也就是16Byte, 再看 <code>final PoolSubpage head = table[tableIdx]</code> 这一步, 跟我们刚才了解到了tinySubpagePools 属性, 默认情况下 head.next 也是自身, 所以<code>if (s != head)</code> 会返回false, 我们继续往下看, 会走到 <code>allocateNormal(buf, reqCapacity, normCapacity)</code>   这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            ++allocationsNormal;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add a new chunk.</span></span><br><span class="line">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">        <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line">        ++allocationsNormal;</span><br><span class="line">        <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line">        c.initBuf(buf, handle, reqCapacity);</span><br><span class="line">        qInit.add(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑我们之前已经剖析过了, 首先在原来的chunk 中分配, 如果分配不成功, 则会创建chunk 进行分配, 我们看这一步<code>long handle = c.allocate(normCapacity);</code>  跟到  <code>allocate(normCapacity);</code> 这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((normCapacity &amp; subpageOverflowMask) != <span class="number">0</span>) &#123; <span class="comment">// &gt;= pageSize</span></span><br><span class="line">          <span class="keyword">return</span> allocateRun(normCapacity);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> allocateSubpage(normCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>前面我们分析page级别的时候, 剖析的是 <code>allocateRun(normCapacity)</code> 方法, 因为这里我们是以16字节举例, 所以这次我们剖析 <code>allocateSubpage(normCapacity)</code> 方法, 也就是在 subpage级别进行内存分配的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line">        <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = maxOrder; <span class="comment">// subpages are only be allocated from pages i.e., leaves</span></span><br><span class="line">            <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">            <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> id;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line"></span><br><span class="line">            freeBytes -= pageSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">            PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">            <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line">                subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">                subpages[subpageIdx] = subpage;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subpage.init(head, normCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先, 通过<code>PoolSubpage head = arena.findSubpagePoolHead(normCapacity)</code> 这种方式找到head节点, 实际上这里head 就是我们分析的tinySubpagePools 属性的第一个节点, 也就是对应16KB的那个节点, int d = maxOrder 是将11赋值给d, 也就是在内存树的第11层取值, 这部分前面剖析过了,。int id = allocateNode(d)  这个也是前面分析过的, 字节数组 memoryMap 的下标, 这里指向一个page, 如果第一次分配, 指向的是0-8KB 的那个page, 前面已经对此进行详细的剖析了, <code>final PoolSubpage[] subpages = this.subpages</code>  这一步, 是拿到PoolChunk 中成员变量subpage的值, 也就是 PoolSubpage 数组, 在PoolChunk 进行初始化的时候， 也会初始化该数组, 长度为2048, 也就是每个chunk 都维护着一个subpage 的列表, 如果每一个page 级别的内存都需要被切分成子page, 则会将这个page 放入该列表中, 专门用于分配子page, 所以这个列表中的subpage 其实就是一个用于切分的page.</p>
<p><img src="http://files.luyanan.com//img/20191011144649.png"></p>
<p><code>int subpageIdx = subpageIdx(id)</code>  这一步是通过id 拿到这个 PoolSubpage 数组的下标, 如果id 对应的page 是0-8KB 的节点, 这里拿到的下标就是0, 在 if (subpage == null) 中, 因为默认 subpages 只是创建一个数组, 并没有数组中赋值, 所以第一次走到这里会返回true, 跟到if 块中:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subpage &#x3D; new PoolSubpage&lt;T&gt;(head, this, id, runOffset(id), pageSize, normCapacity);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里通过 <code>new PoolSubpage</code> 创建一个新的subpage 之后, 通过<code>subpages[subpageIdx] = subpage</code>  这种方式将新创建的subpage 根据下表赋值到subpages 中的元素中, 在new PoolSubpage 的构造方法中, 传入head, 就是我们刚才提到过的tinySubpagePools 属性中的节点, 如果我们分配的16字节的缓冲区, 则这里对应的就是第一个节点, 我们跟到PoolSubpage  的构造方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> memoryMapIdx, <span class="keyword">int</span> runOffset, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> elemSize) &#123;</span><br><span class="line">       <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">       <span class="keyword">this</span>.memoryMapIdx = memoryMapIdx;</span><br><span class="line">       <span class="keyword">this</span>.runOffset = runOffset;</span><br><span class="line">       <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">       bitmap = <span class="keyword">new</span> <span class="keyword">long</span>[pageSize &gt;&gt;&gt; <span class="number">10</span>]; <span class="comment">// pageSize / 16 / 64</span></span><br><span class="line">       init(head, elemSize);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里重点关注属性 bitmap, 这是一个long类型的数组, 初始大小为8, 这里只是初始化的大小, 真正的大小要根据将page 切分多少块而确定的, 这里将属性进行了赋值, 我们跟到init()  方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">       doNotDestroy = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">this</span>.elemSize = elemSize;</span><br><span class="line">       <span class="keyword">if</span> (elemSize != <span class="number">0</span>) &#123;</span><br><span class="line">           maxNumElems = numAvail = pageSize / elemSize;</span><br><span class="line">           nextAvail = <span class="number">0</span>;</span><br><span class="line">           bitmapLength = maxNumElems &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">           <span class="keyword">if</span> ((maxNumElems &amp; <span class="number">63</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">               bitmapLength ++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">               bitmap[i] = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addToPool(head);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>this.elemSize = elemSize</code>  表示保存当前分配的缓存区大小, 这里我们以16字节举例, <code>maxNumElems = numAvail = pageSize / elemSize</code>   这里初始化了两个属性 性 maxNumElems, numAvail, 值都为 pageSize / elemSize, 表示一个 page 大小除以分配的缓冲区大小, 也就是表示当前 page 被划分了多少分。</p>
<p>nextAvail 则表示剩余可用的块数, 由于第一次分配都是可用的, 所以 numAvail=maxNumElems；</p>
<p>bitmapLength 表示bitmap 的实际大小, 刚才我们分析过, bitmap 初始化的大小为8, 但实际上并不一定需要8个元素, 元素个数要根据page切分的子块而定, 这里的大小是所切分的子块数除以64.</p>
<p>再往下看, <code>if ((maxNumElems &amp; 63) != 0)</code>   判断maxNumElems 也就是当前配置所切分的子块是不是64的倍数, 如果不是, 则bigmapLength 加1 , 最后通过循环, 将其分配的大小中的元素赋值为0.</p>
<p>这里详细分析一下bitmap, 这里是个long 类型的数组, long 数组中的每一个值, 也就是long 类型的数字, 其中的每一个比特位, 都标记着page 中每一个子块的内存是否已分配, 如果比特位是1, 表示该快已经分配, 如果比特位是0, 表示该子块未分配. 标记顺序是其二进制数从低位到高位进行排列的, 我们应该知道为什么bitmap 大小要设置为子块数量乘以64, 因为long类型的数字是64位, 每一个元素能记录64个子块的数量, 这样就可以通过 子page 个数除以64 的方式决定bitmap中元素的数量, 如果子块不能整除64, 则通过元素数量+1 方式, 除以64之后剩余的子块通过long中比特位由低到高进行排列记录, 其逻辑结构如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20191011153603.png"></p>
<p>进入到 PoolSubpage 的addToPool(head) 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToPool</span><span class="params">(PoolSubpage&lt;T&gt; head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> prev == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">    prev = head;</span><br><span class="line">    next = head.next;</span><br><span class="line">    next.prev = <span class="keyword">this</span>;</span><br><span class="line">    head.next = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的head我们刚才讲过, 是Arena 中数组 tinySubpagePools 中的元素, 通过以上逻辑, 就会将新创建的Subpage 通过双向链表的方式关联到 tinySubpagePools 中的元素, 我们以16字节为例, 关联关系如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20191011154018.png"></p>
<p>这样, 下次如果还需要分配16字节的内存, 就可以通过tinySubpagePools 找到其元素关联的subpage 进行分配了, 我们再回到PoolChunk 的 allocateSubpage()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line">    <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">        <span class="keyword">int</span> d = maxOrder; <span class="comment">// subpages are only be allocated from pages i.e., leaves</span></span><br><span class="line">        <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line"></span><br><span class="line">        freeBytes -= pageSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">        <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">            subpages[subpageIdx] = subpage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subpage.init(head, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完一个subpage， 我们就可以通过subpage.allocate() 方法进行内存分配, 我们跟到allocate()  方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elemSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> toHandle(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numAvail == <span class="number">0</span> || !doNotDestroy) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bitmapIdx = getNextAvail();</span><br><span class="line">        <span class="keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> r = bitmapIdx &amp; <span class="number">63</span>;</span><br><span class="line">        <span class="keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">        bitmap[q] |= <span class="number">1L</span> &lt;&lt; r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (-- numAvail == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFromPool();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toHandle(bitmapIdx);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 bitmapIdx 表示从 bitmap 中找到一个可用的bit 位的下标, 注意, 这里是bit的下标, 并不是数组的下标, 我们之前分析过，因为每一个比特位代表一个子块的内存分配情况, 通过这个下标就可以知道哪个比特位是未分配状态, 我们跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextAvail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextAvail = <span class="keyword">this</span>.nextAvail;</span><br><span class="line">       <span class="keyword">if</span> (nextAvail &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.nextAvail = -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">return</span> nextAvail;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> findNextAvail();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上述代表片段中的nextAvail 表示下一个可用的bitmapIdx, 在释放的时候就会被标记, 标记被释放的子块对应  bitmapIdx的下标, 如果&lt; 0 则代表没有被释放的子块, 则通过findNextAvail() 方法进行查找, 继续跟进 findNextAvail() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextAvail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span>[] bitmap = <span class="keyword">this</span>.bitmap;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> bitmapLength = <span class="keyword">this</span>.bitmapLength;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">           <span class="keyword">long</span> bits = bitmap[i];</span><br><span class="line">           <span class="keyword">if</span> (~bits != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> findNextAvail0(i, bits);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历bitmap 中的每一个元素, 如果当前元素中所有的比特位并没有全部标记被使用, 则通过findNextAvail() 方法一个一个往后找标记未使用的比特位, 再继续跟findNextAvail0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextAvail0</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxNumElems = <span class="keyword">this</span>.maxNumElems;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> baseVal = i &lt;&lt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((bits &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = baseVal | j;</span><br><span class="line">                <span class="keyword">if</span> (val &lt; maxNumElems) &#123;</span><br><span class="line">                    <span class="keyword">return</span> val;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bits &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里从当前元素的第一个比特位开始查找, 知道找到一个标记位0的比特位, 并返回当前比特位的下标,大致流程如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191011155250.png"></p>
<p>我们回到allocate() 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elemSize == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> toHandle(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (numAvail == <span class="number">0</span> || !doNotDestroy) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取一个bitmap 中可用的id(绝对id)</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> bitmapIdx = getNextAvail();</span><br><span class="line">    <span class="comment">// 除以64 (bitmap 的相对下标)</span></span><br><span class="line">       <span class="keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 除以64 取余, 其实就是当前绝对id 的偏移量</span></span><br><span class="line">       <span class="keyword">int</span> r = bitmapIdx &amp; <span class="number">63</span>;</span><br><span class="line">       <span class="keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前位标记位1</span></span><br><span class="line">       bitmap[q] |= <span class="number">1L</span> &lt;&lt; r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果可用的page 为0</span></span><br><span class="line">    <span class="comment">// 可用的子page -1</span></span><br><span class="line">       <span class="keyword">if</span> (-- numAvail == <span class="number">0</span>) &#123;</span><br><span class="line">           removeFromPool();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将bitmapIdx 转换为handler</span></span><br><span class="line">       <span class="keyword">return</span> toHandle(bitmapIdx);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>找到可用的bitmapIdx , 通过 <code>int q = bitmapIdx &gt;&gt;&gt;6</code> 获取bitmap 中 bitmapIdx 所属元素的数组下标, <code>int r = bitmapIdx &amp; 63</code> 表示获取bitmapIdx 的位置是从当前元素最低开始的第几个比特位, <code>bitmap[q] |= 1L &lt;&lt; r</code> 是将bitmap 的位置设置为不可用, 特就是比特位设置为1, 表示已占用, 然后将可用子配置的数量numAvail 减1.  如果没有可用子page 的数量, 则会将 PoolArena 中的数组 tinySubpagePools 所关联的 subpage 进行移除。最后通过toHandle(bitmapIdx)  获取当前子块的handle, 上一小节我们知道handler 指向的是当前chunk 中的唯一的一块内存, 我们跟进toHandle(bitmapIdx) 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">toHandle</span><span class="params">(<span class="keyword">int</span> bitmapIdx)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0x4000000000000000L</span> | (<span class="keyword">long</span>) bitmapIdx &lt;&lt; <span class="number">32</span> | memoryMapIdx;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>(long) bitmapIdx &lt;&lt; 32 是将 bitmapIdx 右移 32 位, 而 32 位正好是一个 int 的长度, 这样, 通过 (long) bitmapIdx &lt;&lt;<br>32 | memoryMapIdx 计算, 就可以将 memoryMapIdx, 也就是 page 所属的下标的二进制数保存在 (long) bitmapIdx<br>&lt;&lt; 32 的低 32 位中。0x4000000000000000L 是一个最高位是 1 并且所有低位都是 0 的二进制数, 这样通过按位或的<br>方式可以将 (long) bitmapIdx &lt;&lt; 32 | memoryMapIdx 计算出来的结果保存在 0x4000000000000000L 的所有低位中, 这样, 返回对的数字就可以指向 chunk 中唯一的一块内存，我们回到 PoolArena 的 allocateNormal 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            ++allocationsNormal;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add a new chunk.</span></span><br><span class="line">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">        <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line">        ++allocationsNormal;</span><br><span class="line">        <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line">        c.initBuf(buf, handle, reqCapacity);</span><br><span class="line">        qInit.add(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析完了 <code>long handle = c.allocate(normCapacity)</code> 这步, 这里返回的handle 就指向 chunk 中的某个page 中的某个子块所对应的连续内存, 最后, 通过 initBuf() 初始化后， 将创建的chunk 加到chunkList 里面, 我们跟进到initBuf 方法里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">       <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line">       <span class="keyword">if</span> (bitmapIdx == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">byte</span> val = value(memoryMapIdx);</span><br><span class="line">           <span class="keyword">assert</span> val == unusable : String.valueOf(val);</span><br><span class="line">           buf.init(<span class="keyword">this</span>, handle, runOffset(memoryMapIdx), reqCapacity, runLength(memoryMapIdx),</span><br><span class="line">                    arena.parent.threadCache());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这部分在前面已经剖析过, 相信大家不会陌生, 这里有区别是的<code>if (bitmapIdx == 0)</code> 的判断, 这里的bitmapIdx 不会是0, 这样, 就会走到 initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity)方法中，跟到 initBufWithSubpage()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> bitmapIdx, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> bitmapIdx != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"></span><br><span class="line">       PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">       <span class="keyword">assert</span> subpage.doNotDestroy;</span><br><span class="line">       <span class="keyword">assert</span> reqCapacity &lt;= subpage.elemSize;</span><br><span class="line"></span><br><span class="line">       buf.init(</span><br><span class="line">           <span class="keyword">this</span>, handle,</span><br><span class="line">           runOffset(memoryMapIdx) + (bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>) * subpage.elemSize, reqCapacity, subpage.elemSize,</span><br><span class="line">           arena.parent.threadCache());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先拿到memoryMapIdx , 这里会将我们之前计算的 handle 传入, 跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memoryMapIdx</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">int</span>) handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里将其强制转换为一个int 类型, 也就是去掉高32位, 这样就能得到memoryMapIdx, 回到initBufWithSubpage()  方法中:我们注意在buf 调用init()  方法中的一个参数 <code>runOffset(memoryMapIdx) + (bitmapIdx &amp; 0x3FFFFFFF) * subpage.elemSize</code>  这里的偏移量就是原来page 的偏移量 + 子块的偏移量: bitmapIdx &amp; 0x3FFFFFFF 代表当前分配<br>的子 page 是属于第几个子 page。(bitmapIdx &amp; 0x3FFFFFFF) * subpage.elemSize 表示在当前 page 的偏移量。这样, 分<br>配的 ByteBuf 在内存读写的时候, 就会根据偏移量进行读写。最后，我们跟到 init()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assert</span> chunk != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    memory = chunk.memory;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">    tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又是我们熟悉的逻辑, 初始化属性之后, 一个缓冲区分配完成, 以上就是SubPage 级别的缓冲区分配逻辑。</p>
<h3 id="7-内存池ByteBuf-内存回收"><a href="#7-内存池ByteBuf-内存回收" class="headerlink" title="7. 内存池ByteBuf 内存回收"></a>7. 内存池ByteBuf 内存回收</h3><p>我们知道,堆外内存是不受JVM 垃圾回收机制控制的, 所以我们分配一块堆外内存进行ByteBuf 操作时, 使用完毕要对对象进行回收, 本节就以 PooledUnsafeDirectByteBuf 为例讲解有关内存分配的相关逻辑, PooledUnsafeDirectByteBuf 中内存释放的入口方法是其父类 AbstractReferenceCountedByteBuf 中的release() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> release0(checkPositive(decrement, <span class="string">&quot;decrement&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">release0</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> refCnt = <span class="keyword">this</span>.refCnt;</span><br><span class="line">           <span class="keyword">if</span> (refCnt &lt; decrement) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(refCnt, -decrement);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="keyword">this</span>, refCnt, refCnt - decrement)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (refCnt == decrement) &#123;</span><br><span class="line">                   deallocate();</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>if (refCnt == decrement)</code>  中判断当前ByteBuf 是否没有被引用了, 如果没有被引用, 则通过deallocate() 方法进行释放 ,因为我们是以因为我们是以 PooledUnsafeDirectByteBuf 为例, 所以这里会调用其父类 PooledByteBuf 的 deallocate()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">        <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">        memory = <span class="keyword">null</span>;</span><br><span class="line">        chunk.arena.free(chunk, handle, maxLength, cache);</span><br><span class="line">        recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先来分析  free()  方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">            destroyChunk(chunk);</span><br><span class="line">            activeBytesHuge.add(-size);</span><br><span class="line">            deallocationsHuge.increment();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line">            <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">                <span class="comment">// cached so not free it.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            freeChunk(chunk, handle, sizeClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断是不是unpooled, 我们这里是 Pooled, 所以会走到else 块中：</p>
<p>sizeClass(normCapacity) 计算是哪种级别的size, 我们按照tiny 级别进行分析</p>
<p>cache.add(this, chunk, handle, normCapacity, sizeClass) 是将当前ByteBuf  进行缓存.</p>
<p>我们之前讲过, 在分配ByteBuf 时首先在缓存上分配, 而这步, 就是将其缓存的过程, 继续跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolArena&lt;?&gt; area, PoolChunk chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">       MemoryRegionCache&lt;?&gt; cache = cache(area, normCapacity, sizeClass);</span><br><span class="line">       <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cache.add(chunk, handle);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先根据类型拿到相关类型的缓存节点, 这里会根据不同的内存规格去找不同的对象, 我们简单回顾一下, 每个缓存对象都包含一个queue, queue 中每个节点是entry, 每一个entry 中包含一个chunk 和handle, 可以指向唯一的连续的内存, 我们跟到cache中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cache(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity, SizeClass sizeClass) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (sizeClass) &#123;</span><br><span class="line">      <span class="keyword">case</span> Normal:</span><br><span class="line">          <span class="keyword">return</span> cacheForNormal(area, normCapacity);</span><br><span class="line">      <span class="keyword">case</span> Small:</span><br><span class="line">          <span class="keyword">return</span> cacheForSmall(area, normCapacity);</span><br><span class="line">      <span class="keyword">case</span> Tiny:</span><br><span class="line">          <span class="keyword">return</span> cacheForTiny(area, normCapacity);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>假设我们是tiny类型, 这里就会走到   <code>cacheForTiny(area, normCapacity)</code> 方法中, 跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForTiny(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">       <span class="keyword">int</span> idx = PoolArena.tinyIdx(normCapacity);</span><br><span class="line">       <span class="keyword">if</span> (area.isDirect()) &#123;</span><br><span class="line">           <span class="keyword">return</span> cache(tinySubPageDirectCaches, idx);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cache(tinySubPageHeapCaches, idx);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法我们之前剖析过, 就是根据大小找到第几个缓存中的第几个缓存, 拿到下标后, 通过cache 去找相对应的缓存对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MemoryRegionCache&lt;T&gt; <span class="title">cache</span><span class="params">(MemoryRegionCache&lt;T&gt;[] cache, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span> || idx &gt; cache.length - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache[idx];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们这里看到, 是直接通过下标拿到的缓存对象, 回到 add()  方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolArena&lt;?&gt; area, PoolChunk chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">      MemoryRegionCache&lt;?&gt; cache = cache(area, normCapacity, sizeClass);</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.add(chunk, handle);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的cache 对象调用了一个add方法, 这个方法就是将chunk 和handle 封装成一个 entry 加到queue, 我们跟到add() 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">          Entry&lt;T&gt; entry = newEntry(chunk, handle);</span><br><span class="line">          <span class="keyword">boolean</span> queued = queue.offer(entry);</span><br><span class="line">          <span class="keyword">if</span> (!queued) &#123;</span><br><span class="line">              <span class="comment">// If it was not possible to cache the chunk, immediately recycle the entry</span></span><br><span class="line">              entry.recycle();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> queued;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>我们之前介绍过, 从在缓存对象中分配的时候从queue 弹出一个entry, 会放到一个对象池里面, 而这里的<code> Entry&lt;T&gt; entry = newEntry(chunk, handle);</code>  就是从对象池中去取一个entry 对象, 然后将chunk 和handle 进行赋值, 然后通过<code>queue.offer(entry)</code>  加到queue, 我们回到free() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">         <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">         destroyChunk(chunk);</span><br><span class="line">         activeBytesHuge.add(-size);</span><br><span class="line">         deallocationsHuge.increment();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line">         <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">             <span class="comment">// cached so not free it.</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         freeChunk(chunk, handle, sizeClass);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里加到缓存之后, 如果成功, 就会return, 如果不成功, 就会调用 <code> freeChunk(chunk, handle, sizeClass);</code>  方法, 这个方法的意思是： 将原来给ByteBuf 分配的内存区段标记位未使用,跟进到 ` freeChunk()  方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeChunk</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> destroyChunk;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (sizeClass) &#123;</span><br><span class="line">            <span class="keyword">case</span> Normal:</span><br><span class="line">                ++deallocationsNormal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Small:</span><br><span class="line">                ++deallocationsSmall;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Tiny:</span><br><span class="line">                ++deallocationsTiny;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">            &#125;</span><br><span class="line">            destroyChunk = !chunk.parent.free(chunk, handle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (destroyChunk) &#123;</span><br><span class="line">            <span class="comment">// destroyChunk not need to be called while holding the synchronized lock.</span></span><br><span class="line">            destroyChunk(chunk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们在跟到free() 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">       chunk.free(handle);</span><br><span class="line">       <span class="keyword">if</span> (chunk.usage() &lt; minUsage) &#123;</span><br><span class="line">           remove(chunk);</span><br><span class="line">           <span class="comment">// Move the PoolChunk down the PoolChunkList linked-list.</span></span><br><span class="line">           <span class="keyword">return</span> move0(chunk);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>chunk.free(handle);</code> 的意思是通过chunk 释放一段连续的内存, 再跟回到free() 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">        <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bitmapIdx != <span class="number">0</span>) &#123; <span class="comment">// free a subpage</span></span><br><span class="line">            PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">            <span class="keyword">assert</span> subpage != <span class="keyword">null</span> &amp;&amp; subpage.doNotDestroy;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line">            <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line">            PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</span><br><span class="line">            <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">                <span class="keyword">if</span> (subpage.free(head, bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        freeBytes += runLength(memoryMapIdx);</span><br><span class="line">        setValue(memoryMapIdx, depth(memoryMapIdx));</span><br><span class="line">        updateParentsFree(memoryMapIdx);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>if (bitmapIdx != 0)  这里判断是当前缓存区分配的级别是page 还是subpage, 如果是subpage , 则会找到相关的subpage 将其位标记为0， 如果不是subpage, 这里通过分配内存的反向标记, 将该内存标记为未使用. 回 到 PooledByteBuf 的 deallocate方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">          <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">          memory = <span class="keyword">null</span>;</span><br><span class="line">          chunk.arena.free(chunk, handle, maxLength, cache);</span><br><span class="line">          recycle();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后, 通过recycle()  将释放的ByteBuf 放入对象回收站</p>
<h3 id="8-SocketChannel-读取ByteBuf-的过程"><a href="#8-SocketChannel-读取ByteBuf-的过程" class="headerlink" title="8. SocketChannel 读取ByteBuf 的过程"></a>8. SocketChannel 读取ByteBuf 的过程</h3><p>我们首先看NioEventLoop 的processSelectedKey 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">            <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                eventLoop = ch.eventLoop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">                <span class="comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span></span><br><span class="line">                <span class="comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span></span><br><span class="line">                <span class="comment">// to close ch.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only close ch if ch is still registerd to this EventLoop. ch could have deregistered from the event loop</span></span><br><span class="line">            <span class="comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span></span><br><span class="line">            <span class="comment">// still healthy and should not be closed.</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/5125</span></span><br><span class="line">            <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span> || eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// close the channel if the key is not valid anymore</span></span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line">            <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line">            <span class="comment">// to a spin loop</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();</span><br><span class="line">                <span class="keyword">if</span> (!ch.isOpen()) &#123;</span><br><span class="line">                    <span class="comment">// Connection already closed - no need to handle write.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0)</code> 这里的判断表示轮询到大事件是OP_READ 或者 OP_ACCEPT 事件.  如果当前 <strong>NioEventLoop</strong> 是work 线程的话, 那么这里就是OP_READ  事件, 也就是读事件, 表示客户端发来了数据流, 这里会调用 unsafe 的redis()  方法进行读取， 如果是work 线程, 那么这里的channel  是NioServerSocketChannel, 其绑定的 unsafe 是NioByteUnsafe, 这里会走到 NioByteUnsafe 的 read()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">         <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">         <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">         <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">         allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">         ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">                 allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">                 <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="comment">// nothing was read. release the buffer.</span></span><br><span class="line">                     byteBuf.release();</span><br><span class="line">                     byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                     close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">                 readPending = <span class="keyword">false</span>;</span><br><span class="line">                 pipeline.fireChannelRead(byteBuf);</span><br><span class="line">                 byteBuf = <span class="keyword">null</span>;</span><br><span class="line">             &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">             allocHandle.readComplete();</span><br><span class="line">             pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                 closeOnRead(pipeline);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="comment">// Check if there is a readPending which was not processed yet.</span></span><br><span class="line">             <span class="comment">// This could be for two reasons:</span></span><br><span class="line">             <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class="line">             <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span></span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">             <span class="comment">// See https://github.com/netty/netty/issues/2254</span></span><br><span class="line">             <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                 removeReadOp();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>首先获取SocketChannel 的 config, pipeline 等相关属性，final ByteBufAllocator allocator = config.getAllocator(); 这<br>一步是获取一个 ByteBuf 的内存分配器, 用于分配 ByteBuf。这里会走到 DefaultChannelConfig 的 getAllocator 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ByteBufAllocator <span class="title">getAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> allocator;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的 DefaultChannelConfig  的成员变量, 我们看这个成员变量：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile ByteBufAllocator allocator &#x3D; ByteBufAllocator.DEFAULT;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里调用的 ByteBufAllocator 的DEFAULT属性, 跟进去:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBufAllocator DEFAULT &#x3D; ByteBufUtil.DEFAULT_ALLOCATOR;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>看到这里又调用了ByteBufUtil 的静态属性DEFAULT_ALLOCATOR, 再跟进去</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final ByteBufAllocator DEFAULT_ALLOCATOR;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>DEFAULT_ALLOCATOR  这个属性是在static 块中初始化的, 我们跟到static 块中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       String allocType = SystemPropertyUtil.get(</span><br><span class="line">               <span class="string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="string">&quot;unpooled&quot;</span> : <span class="string">&quot;pooled&quot;</span>);</span><br><span class="line">       allocType = allocType.toLowerCase(Locale.US).trim();</span><br><span class="line"></span><br><span class="line">       ByteBufAllocator alloc;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;unpooled&quot;</span>.equals(allocType)) &#123;</span><br><span class="line">           alloc = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">           logger.debug(<span class="string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pooled&quot;</span>.equals(allocType)) &#123;</span><br><span class="line">           alloc = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">           logger.debug(<span class="string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           alloc = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">           logger.debug(<span class="string">&quot;-Dio.netty.allocator.type: pooled (unknown: &#123;&#125;)&quot;</span>, allocType);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       DEFAULT_ALLOCATOR = alloc;</span><br><span class="line"></span><br><span class="line">       THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.threadLocalDirectBufferSize&quot;</span>, <span class="number">64</span> * <span class="number">1024</span>);</span><br><span class="line">       logger.debug(<span class="string">&quot;-Dio.netty.threadLocalDirectBufferSize: &#123;&#125;&quot;</span>, THREAD_LOCAL_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">       MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.maxThreadLocalCharBufferSize&quot;</span>, <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">       logger.debug(<span class="string">&quot;-Dio.netty.maxThreadLocalCharBufferSize: &#123;&#125;&quot;</span>, MAX_CHAR_BUFFER_SIZE);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断运行环境是不是安卓, 如果不是安卓, 在返回”pooled”  字符串保存到  allocType 中, 然后通过if 判断, 最后局部变量alloc = PooledByteBufAllocator.DEFAULT;  最后将alloc  赋值到成员变量 DEFAULT_ALLOCATOR, 我们跟到PooledByteBufAllocator 的 DEFAULT 属性中：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final PooledByteBufAllocator DEFAULT &#x3D;        new PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们看到这里直接通过new 的方式, 创建了一个PooledByteBufAllocator 对象， 也就是基于申请一块连续内存进行缓冲区分配的缓存区分配器, 回到NioByteUnsafe 的 read()  方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">         <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">         <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">         <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">         allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">         ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">                 allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">                 <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="comment">// nothing was read. release the buffer.</span></span><br><span class="line">                     byteBuf.release();</span><br><span class="line">                     byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                     close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">                 readPending = <span class="keyword">false</span>;</span><br><span class="line">                 pipeline.fireChannelRead(byteBuf);</span><br><span class="line">                 byteBuf = <span class="keyword">null</span>;</span><br><span class="line">             &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">             allocHandle.readComplete();</span><br><span class="line">             pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                 closeOnRead(pipeline);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="comment">// Check if there is a readPending which was not processed yet.</span></span><br><span class="line">             <span class="comment">// This could be for two reasons:</span></span><br><span class="line">             <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class="line">             <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span></span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">             <span class="comment">// See https://github.com/netty/netty/issues/2254</span></span><br><span class="line">             <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                 removeReadOp();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<p>这里ByteBufAllocator allocator = config.getAllocator()中的 allocator , 就是 PooledByteBufAllocator。<br>final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle() 是创建一个 handle,handle是对RecvByteBufAllocator 进行实际操作的对象, 我们跟进recvBufAllocHandle：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> RecvByteBufAllocator.<span class="function">Handle <span class="title">recvBufAllocHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (recvHandle == <span class="keyword">null</span>) &#123;</span><br><span class="line">               recvHandle = config().getRecvByteBufAllocator().newHandle();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> recvHandle;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>这里是我们之前剖析过的逻辑, 如果不存在, 则创建handle 的实例. 同样, <code>allocHandle.reset(config)</code> 是将配置重置, 重置完配置后, 进行 <code>do-while</code>     循环, 有关循环终止条件 <code>allocHandle.continueReading()</code>. 在  <code>do-while </code> 循环中, 首先看 <code>byteBuf = allocHandle.allocate(allocator)</code> 这一步, 这里传入了刚才创建的allocate 对象 , 也就是PooledByteBufAllocator，这里会进入 DefaultMaxMessagesRecvByteBufAllocator 类的 allocate()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> alloc.ioBuffer(guess());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>这里的guess() 方法, 会调用AdaptiveRecvByteBufAllocator 的 guess()  方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> nextReceiveBufferSize;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里会返回AdaptiveRecvByteBufAllocator 的成员变量nextReceiveBufferSize, 也就是下次所分配的缓冲区的大小,第一个分配的时候u也会分配初始大小, 也就是1024字节, 这样, alloc.ioBuffer(guess())  就会分配一个PooledByteBuf，我们跟到AbstractByteBufAllocator 的 ioBuffer 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">          <span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断是否能够获取jdk 的unsafe 对象, 默认为true, 所以会走到directBuffer(initialCapacity) 中, 这里最终会分配一个 PooledUnsafeDirectByteBuf 对象 , 回到NioByteUnsafe 的read(） 方法中, 分配完了ByteBuf 之后, 再看这一步 allocHandle.lastBytesRead(doReadBytes(byteBuf))。</p>
<p>首先看参数doReadBytes(byteBuf)方法, 这步是将channel 中的数据读取到我们刚分配到了ByteBuf 中, 并返回读取到的字节数, 这里会调用NioSocketChannel 的 doReadBytes()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">      allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">      <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先拿到绑定在channel 中的handle, 因为我们已经创建了handle,所以这里会直接拿到, 再看allocHandle.attemptedBytesRead(byteBuf.writableBytes()) 这步, , byteBuf.writableBytes()  返回的是ByteBuf 可写的字节数, 也就是最多能从channel 中读取多少字节写到ByteBuf,  allocate 的 attemptedBytesRead 会把可写字节数设置到<br>DefaultMaxMessagesRecvByteBufAllocator 类 的 attemptedBytesRead 属 性 中 ， 跟 到<br>DefaultMaxMessagesRecvByteBufAllocator 中的 attemptedBytesRead 我们会看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attemptedBytesRead</span><span class="params">(<span class="keyword">int</span> bytes)</span> </span>&#123;</span><br><span class="line">          attemptedBytesRead = bytes;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>继续看doReadBytes()  方法, 往下看到最后, 通过<code>byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead())</code>  将JDK 底层的channel 数据写入到我们创建的ByteBuf 中, 并返回实际写入的字节数.  回到 NioByteUnsafe 的 read() 方法中继续看<code>allocHandle.lastBytesRead(doReadBytes(byteBuf))</code>  这一步, 刚才我们剖析过 <code>doReadBytes(byteBuf)</code>  返回的是刚才写入的ByteBuf 的字节数, 再看 lastBytesRead()   方法, 跟到DefaultMaxMessagesRecvByteBufAllocator 的lastBytesRead()   方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lastBytesRead</span><span class="params">(<span class="keyword">int</span> bytes)</span> </span>&#123;</span><br><span class="line">          lastBytesRead = bytes;</span><br><span class="line">          <span class="comment">// Ignore if bytes is negative, the interface contract states it will be detected externally after call.</span></span><br><span class="line">          <span class="comment">// The value may be &quot;invalid&quot; after this point, but it doesn&#x27;t matter because reading will be stopped.</span></span><br><span class="line">          totalBytesRead += bytes;</span><br><span class="line">          <span class="keyword">if</span> (totalBytesRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              totalBytesRead = Integer.MAX_VALUE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里会赋值两个属性, lastBytesRead 代表最后读取的字节数, 这里赋值为我们刚才写入ByteBuf 的字节数, totalBytesRead 代表总共读取的字节数, 这里将写入的字节数相加。继续来到 NioByteUnsafe 的read(） 方法, 如果最后一次性读取数据为0, 说明已经将channel 中的数据全部读取完毕, 将新创建的ByteBuf 释放循环使用, 并跳出循环, <code>allocHandle.incMessagesRead(1);</code> 这步是增加消息的读取次数, 因为我们这里循环最多16次, 所以当消息增加次数增加到16 会结束循环。 读取完毕后, 会通过<code>pipeline.fireChannelReadComplete()</code>   将传入 channelRead 事件.</p>
<p>至此, 小伙伴应该有个疑问, 如果一次读取不完, 就传递channelRead 事件. 那么server 接受到的数据就有可能不是完整的, 其实关于这点, Netty 也做了相应的处理, 循环结束后, 会执行到<code>allocHandle.readComplete();</code>   这一步.</p>
<p>其实我们知道第一次分配ByteBuf 的初始容量是1024, 但是初始容量不一定一定满足所有的业务场景, netty 中, 将每次读取数据的字节数进行记录, 然后之后分配ByteBuf 的时候, 容量会尽可能的符合业务场景所需要的大小, 具体实现方式在 allocHandle.readComplete(）这一步体现的,  我们跟到 AdaptiveRecvByteBufAllocator 的 readComplete()  方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          record(totalBytesRead());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里调用了record()  方法, 并传入了这一次所读取的字节总数, 跟到record() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> actualReadBytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[Math.max(<span class="number">0</span>, index - INDEX_DECREMENT - <span class="number">1</span>)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (decreaseNow) &#123;</span><br><span class="line">                    index = Math.max(index - INDEX_DECREMENT, minIndex);</span><br><span class="line">                    nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">                    decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    decreaseNow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;</span><br><span class="line">                index = Math.min(index + INDEX_INCREMENT, maxIndex);</span><br><span class="line">                nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">                decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先看判断条件 <code>if (actualReadBytes &lt;= SIZE_TABLE[Math.max(0, index - INDEX_DECREMENT - 1)]) </code> . 这里index 是当前分配的缓存区大小所在的SIZE_TABLE 的索引, 将这个索引进行缩进, 然后根据缩进后的索引找出 SIZE_TABLE 所存储的内存值, 再判断是否大于等于这次读取的最大字节数， 如果条件成立, 说明分配的内存过大, 需要缩容操作, 我们看if 块中缩容相关的逻辑, 首先 <code>if (decreaseNow)</code>   会判断是否立即进行收缩操作, 通常第一次不会进行收缩操作, 然后会将 decreaseNow 设置为true, 代表下一次直接进行收缩操作, 假设需要立即进行收缩操作,我们看收缩操作的相关逻辑。</p>
<p><code> index = Math.max(index - INDEX_DECREMENT, minIndex);</code> 这一步将索引缩进一步, 但不能小于最小索引值, 然后通过<code>nextReceiveBufferSize = SIZE_TABLE[index]</code> 获取设置索引之后的内存, 赋值在nextReceiveBufferSize , 也就是下次需要分配的大小, 下次就会根据这个大小分配ByteBuf了, 这样就实现了缩容操作.</p>
<p>再看 <code>else if (actualReadBytes &gt;= nextReceiveBufferSize)</code> 这里判断这次读取字节的总量比上次分配的大小还要大, 则进行扩容操作. 扩容操作也非常简单, 索引步进 , 然后拿到步进后的索引锁对应的内存值, 作为下次所需要的分配的大小在NioByteUnsafe 的 read()  方法， 经过了缩容或者扩容操作后， 通过pipeline.fireChannelReadComplete()传播<br>ChannelReadComplete()事件 , 以上就是读取客户端消息的相关流程.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/12.1%20Netty%E5%86%85%E5%AD%98%E5%88%86%E9%85%8DByteBuf/" rel="prev" title="12">
      <i class="fa fa-chevron-left"></i> 12
    </a></div>
      <div class="post-nav-item">
    <a href="/13.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/" rel="next" title="13">
      13 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Pooled-%E6%B1%A0%E5%8C%96%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.</span> <span class="nav-text">4. Pooled 池化内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-PooledByteBufAllocator-%E7%AE%80%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1. PooledByteBufAllocator 简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-DirectArena-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2. DirectArena 内存分配流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%84%E6%A0%BC"><span class="nav-number">1.3.</span> <span class="nav-text">3. 内存池的内存规格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%91%BD%E4%B8%AD%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">1.4.</span> <span class="nav-text">4. 命中缓存的分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Page-%E7%BA%A7%E5%88%AB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.5.</span> <span class="nav-text">5. Page 级别的内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-SubPage-%E7%BA%A7%E5%88%AB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.6.</span> <span class="nav-text">6. SubPage 级别的内存分配.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%86%85%E5%AD%98%E6%B1%A0ByteBuf-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-number">1.7.</span> <span class="nav-text">7. 内存池ByteBuf 内存回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-SocketChannel-%E8%AF%BB%E5%8F%96ByteBuf-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.8.</span> <span class="nav-text">8. SocketChannel 读取ByteBuf 的过程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/luyanan0718" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luyanan0718" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/luyanan0718@163.com" title="E-Mail → luyanan0718@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://luyanan.com/" title="https:&#x2F;&#x2F;luyanan.com">Site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
