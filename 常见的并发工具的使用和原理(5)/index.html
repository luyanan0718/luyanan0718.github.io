<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="5. 常见的并发工具的使用和原理Condition 在前面学习synchronized 的时候,有讲到 wait&#x2F;nofity 的基本使用,结合synchronized 可以实现对线程的通信.那么既然J.U.C 里面提供了锁的实现机制,那么J.U.C 里面有没有提供了类似的线程通信的工具呢? 于是发现了Condition 工具类  Condition 是一个多线程协调通信的工具类,可以让某些线程一">
<meta property="og:type" content="article">
<meta property="og:title" content="常见的并发工具的使用和原理(5)">
<meta property="og:url" content="http://luyanan.com/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86(5)/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="5. 常见的并发工具的使用和原理Condition 在前面学习synchronized 的时候,有讲到 wait&#x2F;nofity 的基本使用,结合synchronized 可以实现对线程的通信.那么既然J.U.C 里面提供了锁的实现机制,那么J.U.C 里面有没有提供了类似的线程通信的工具呢? 于是发现了Condition 工具类  Condition 是一个多线程协调通信的工具类,可以让某些线程一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20190808150135.jpg">
<meta property="og:image" content="http://files.luyanan.com//img/20190808162956.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190808164157.jpg">
<meta property="og:image" content="http://files.luyanan.com//img/20190812142913.jpg">
<meta property="og:image" content="http://files.luyanan.com//img/20190812154533.jpg">
<meta property="og:image" content="http://files.luyanan.com//img/20190812163630.jpg">
<meta property="og:image" content="http://files.luyanan.com//img/20190812171333.jpg">
<meta property="article:published_time" content="2021-03-12T02:15:06.295Z">
<meta property="article:modified_time" content="2021-03-12T02:15:06.295Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Python, Rust, C++, Go, 爬虫, 深度学习, 服务研发, 对象存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20190808150135.jpg">

<link rel="canonical" href="http://luyanan.com/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86(5)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>常见的并发工具的使用和原理(5) | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          常见的并发工具的使用和原理(5)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 10:15:06" itemprop="dateCreated datePublished" datetime="2021-03-12T10:15:06+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="5-常见的并发工具的使用和原理"><a href="#5-常见的并发工具的使用和原理" class="headerlink" title="5. 常见的并发工具的使用和原理"></a>5. 常见的并发工具的使用和原理</h1><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> 在前面学习synchronized 的时候,有讲到 wait/nofity 的基本使用,结合synchronized 可以实现对线程的通信.那么既然J.U.C 里面提供了锁的实现机制,那么J.U.C 里面有没有提供了类似的线程通信的工具呢? 于是发现了Condition 工具类</p>
<p> Condition 是一个多线程协调通信的工具类,可以让某些线程一起等待某个条件(condition),只有满足条件时，线程才会被唤醒.</p>
<h3 id="Condition的基本使用"><a href="#Condition的基本使用" class="headerlink" title="Condition的基本使用"></a>Condition的基本使用</h3><h3 id="condition-wait"><a href="#condition-wait" class="headerlink" title="condition.wait"></a>condition.wait</h3><p> ConditionWaitDemo<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> package com.notes.concurrent.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;8</span><br><span class="line"> * &lt;p&gt;使用condition实现线程wait&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class ConditionWaitDemo implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock;</span><br><span class="line"></span><br><span class="line">    private Condition condition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ConditionWaitDemo(Lock lock, Condition condition) &#123;</span><br><span class="line">        this.lock &#x3D; lock;</span><br><span class="line">        this.condition &#x3D; condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ConditionWaitDemo start &quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(&quot;ConditionWaitDemo end &quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><br> ConditionSignalDemo<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> package com.notes.concurrent.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;8</span><br><span class="line"> * &lt;p&gt;使用condition 实现线程唤醒&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class ConditionSignalDemo implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Lock lock;</span><br><span class="line"></span><br><span class="line">    private Condition condition;</span><br><span class="line"></span><br><span class="line">    public ConditionSignalDemo(Lock lock, Condition condition) &#123;</span><br><span class="line">        this.lock &#x3D; lock;</span><br><span class="line">        this.condition &#x3D; condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;ConditionSignalDemo start &quot;);</span><br><span class="line">            lock.lock();</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(&quot;ConditionSignalDemo end &quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.notes.concurrent.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;8</span><br><span class="line"> * &lt;p&gt;测试类&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class ConditionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock  lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition &#x3D; lock.newCondition();</span><br><span class="line">        new Thread(new ConditionWaitDemo(lock,condition)).start();</span><br><span class="line">        new Thread(new ConditionSignalDemo(lock,condition)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 结果<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ConditionWaitDemo start </span><br><span class="line">ConditionSignalDemo start </span><br><span class="line">ConditionSignalDemo end </span><br><span class="line">ConditionWaitDemo end </span><br></pre></td></tr></table></figure></p>
<p> 通过这个案例简单实现了wait和 notify的功能, 当调用await 方法之后,当前线程会释放锁并等待,而其他线程调用confition对象的signal或者signalAll 方法通知被阻塞的线程,然后自己执行unlock 释放锁,被唤醒的线程获得之前是锁继续执行,最后释放锁.</p>
<p> 所以,condition 中两个最重要的方法,一个是await,一个是 signal.</p>
<ul>
<li>await: 把当前线程阻塞挂起</li>
<li>signal: 唤醒阻塞的线程</li>
</ul>
<h3 id="Condition-源码分析"><a href="#Condition-源码分析" class="headerlink" title="Condition 源码分析"></a>Condition 源码分析</h3><p>调用Condition , 需要获得Lock锁,所以意味着会存在一个AQS 同步队列,在上面的案例中,假如两个线程同时运行的话,那么AQS的队列可能是下面四种情况<br><img src="http://files.luyanan.com//img/20190808150135.jpg"><br>那么这个时候,ThreadA 调用了condition.await() 方法之后,它做了什么事情呢?</p>
<h4 id="condition-await"><a href="#condition-await" class="headerlink" title="condition.await"></a>condition.await</h4><p>调用Condition 的await()方法[或者以await开头的方法],会使得当前线程进入到等待队列并释放锁,同时线程状态变为等待状态.当await()方法返回时,当前线程一定获取了Condition 相关联的锁.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">         &#x2F;&#x2F;  表示await 允许被中断</span><br><span class="line">         if (Thread.interrupted())</span><br><span class="line">             throw new InterruptedException();</span><br><span class="line">         &#x2F;&#x2F; 创建一个新的节点,节点状态为condition, 采用的数据结构依然为链表,</span><br><span class="line">         Node node &#x3D; addConditionWaiter();</span><br><span class="line">         &#x2F;&#x2F;  释放当前的锁,得到锁的状态,并唤醒AQS队列中的一个线程</span><br><span class="line">         int savedState &#x3D; fullyRelease(node);</span><br><span class="line">         int interruptMode &#x3D; 0;</span><br><span class="line">         &#x2F;&#x2F; 判断这个节点是否在AQS队列中,第一次判断的是false, 因为前面已经是释放过锁了.</span><br><span class="line">         while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">             &#x2F;&#x2F; 通过park 挂起当前线程</span><br><span class="line">             LockSupport.park(this);</span><br><span class="line">             if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">                 break;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 当这个线程醒来之后,会尝试拿锁,当acquireQueued 返回false 就是拿到锁了</span><br><span class="line">         &#x2F;&#x2F; interruptMode !&#x3D; THROW_IE 表示这个线程没有成功将node 入队,但是signal 执行了enq 方法让其入队了</span><br><span class="line">         &#x2F;&#x2F; 将interruptMode 设置为 REINTERRUPT</span><br><span class="line">         if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">             interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">         &#x2F;&#x2F; 如果node 的下一个等待着不是null, 则进行清理,清理condition队列上的节点</span><br><span class="line">         &#x2F;&#x2F; 如果是null,则不需要清理</span><br><span class="line">         if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">             unlinkCancelledWaiters();</span><br><span class="line">         &#x2F;&#x2F; 如果线程被中断了,需要抛出异常,或者什么都不做.</span><br><span class="line">         if (interruptMode !&#x3D; 0)</span><br><span class="line">             reportInterruptAfterWait(interruptMode);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><p>这个方法的主要作用是把当前线程封装成Node,添加到等待队列,这里的队列不是双向链表,而是单向链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">          Node t &#x3D; lastWaiter;</span><br><span class="line">          &#x2F;&#x2F; If lastWaiter is cancelled, clean out.</span><br><span class="line">          &#x2F;&#x2F; 如果laseWaiter 不等于空并且waitStatus 不等于CONDITION的时候,把这个节点从链表中移除</span><br><span class="line">          if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">              t &#x3D; lastWaiter;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 构建一个Node, waitStatus &#x3D; CONDITION, 这里的链表是一个单向链表，相对于AQS来说会简单很多</span><br><span class="line">          Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">          if (t &#x3D;&#x3D; null)</span><br><span class="line">              firstWaiter &#x3D; node;</span><br><span class="line">          else</span><br><span class="line">              t.nextWaiter &#x3D; node;</span><br><span class="line">          lastWaiter &#x3D; node;</span><br><span class="line">          return node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>图解分析</strong></p>
<p>执行完 addConditionWaiter 这个方法之后,就会产生一个这样的condition 队列<br><img src="http://files.luyanan.com//img/20190808162956.png"></p>
<h5 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h5><p>fullyRelease,就是彻底的释放锁,什么叫彻底呢? 就是如果当前锁存在多次重入,那么在这个方法中只需要释放一次,就会把所有的重入次数归零.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">       boolean failed &#x3D; true;</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F; 获得重入的次数</span><br><span class="line">           int savedState &#x3D; getState();</span><br><span class="line">           &#x2F;&#x2F; 释放锁并且唤醒下一个同步队列中的线程</span><br><span class="line">           if (release(savedState)) &#123;</span><br><span class="line">               failed &#x3D; false;</span><br><span class="line">               return savedState;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               throw new IllegalMonitorStateException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h6><p>此时,同步队列会出发锁的释放和重新竞争.ThreadB 获得了锁<br><img src="http://files.luyanan.com//img/20190808164157.jpg"></p>
<h5 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h5><p>判断当前节点是否在同步队列中，返回false 则表示不在,返回true 则表示在</p>
<p>如果不在AQS同步队列,说明当前节点没有唤醒去争抢同步锁,所以需要把当前线程阻塞起来,直到其他的线程调用signal 唤醒.</p>
<p>如果在AQS同步队列中,意味着它需要同步锁去获得执行程序执行权限。</p>
<p>为什么要做这个判断呢? 原因是在conditin 队列中的节点会重新加入到AQS队列去竞争锁.也就是调用signal的时候,会把当前节点从condition 队列转移到AQS 队列中.</p>
<h6 id="大家思考一下-基于现在的逻辑结构-如何去判断ThreadA-这个节点是否存在于AQS队列中呢"><a href="#大家思考一下-基于现在的逻辑结构-如何去判断ThreadA-这个节点是否存在于AQS队列中呢" class="headerlink" title="大家思考一下,基于现在的逻辑结构.如何去判断ThreadA 这个节点是否存在于AQS队列中呢?"></a>大家思考一下,基于现在的逻辑结构.如何去判断ThreadA 这个节点是否存在于AQS队列中呢?</h6><ol>
<li>如果ThreadA的waitStatus 的状态为CONDITION,说明他存在于condition队列中,不在AQS队列中,因为AQS 队列的状态一定不可能有CONDITION</li>
<li>如果node.prev为空,说明也不存在于AQS队列,原因是prev = null 在AQS队列中只存在一种可能性,就是它是head节点,head节点意味着它是获得锁的节点.</li>
<li>如果node.next 不等于空,说明一定存在于AQS队列中,因为只有AQS队列才会存在next和prev 关系.</li>
<li>findNodeFromTail 表示从tail节点往前扫描AQS队列，一旦发现AQS队列的节点与当前节点一样,说明节点一定存在于AQS队列中.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">       if (node.waitStatus &#x3D;&#x3D; Node.CONDITION || node.prev &#x3D;&#x3D; null)</span><br><span class="line">           return false;</span><br><span class="line">       if (node.next !&#x3D; null) &#x2F;&#x2F; If has successor, it must be on queue</span><br><span class="line">           return true;</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * node.prev can be non-null, but not yet on queue because</span><br><span class="line">        * the CAS to place it on queue can fail. So we have to</span><br><span class="line">        * traverse from tail to make sure it actually made it.  It</span><br><span class="line">        * will always be near the tail in calls to this method, and</span><br><span class="line">        * unless the CAS failed (which is unlikely), it will be</span><br><span class="line">        * there, so we hardly ever traverse much.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       return findNodeFromTail(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="condition-signal"><a href="#condition-signal" class="headerlink" title="condition.signal"></a>condition.signal</h4><p>await 方法会阻塞ThreadA, 然后ThreadB 抢占到了锁获得了执行权限,这个时候在ThreadB 中调用了condition.signal()方法,将会唤醒在等待队列中的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">          &#x2F;&#x2F; 先判断当前线程是否获得了锁,这个判断比较简单,直接用获得了锁的线程和当前线程进行相对即可.</span><br><span class="line">          if (!isHeldExclusively())</span><br><span class="line">              throw new IllegalMonitorStateException();</span><br><span class="line">          &#x2F;&#x2F; 拿到Condition队列上的第一个节点</span><br><span class="line">          Node first &#x3D; firstWaiter;</span><br><span class="line">          if (first !&#x3D; null)</span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h5 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h5><p>对 condition 队列中从首部开始的第一个condition状态的节点,执行 transferForSignal 操作,将node 从condition 队列中转换到AQS队列中,同时修改AQS队列中原先队尾 的状态.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 将next 节点设置为null</span><br><span class="line">                    lastWaiter &#x3D; null;</span><br><span class="line">                first.nextWaiter &#x3D; null;</span><br><span class="line">            &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="AQS-transferForSignal"><a href="#AQS-transferForSignal" class="headerlink" title="AQS.transferForSignal"></a>AQS.transferForSignal</h5><p>该方法显示CAS 修改了节点状态,如果成功,就将这个节点放到AQS 队列中,然后唤醒这个节点上的线程. 此时,这个节点j就会在await 方法中唤醒.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">      &#x2F;*</span><br><span class="line">       * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      &#x2F;&#x2F; 更新节点的状态为0,如果更新失败,只有一种可能就是节点被CANCELLED 了</span><br><span class="line">      if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">          return false;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">       * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">       * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">       * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">       *&#x2F;</span><br><span class="line">      &#x2F;&#x2F; 调用enq,把当前节点添加到AQS队列中,b并且返回当前节点的上一个节点,也就是原tail节点</span><br><span class="line">      Node p &#x3D; enq(node);</span><br><span class="line">      int ws &#x3D; p.waitStatus;</span><br><span class="line">      &#x2F;&#x2F; 如果上一个节点的状态被取消了,或者尝试设置上一个节点的状态为SIGNAL,失败了(SIGNAL 表示它的next节点需要停止阻塞)</span><br><span class="line">      if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">          &#x2F;&#x2F; 唤醒节点上的线程</span><br><span class="line">          LockSupport.unpark(node.thread);</span><br><span class="line">      &#x2F;&#x2F; 如果node的prev 节点已经是signal 状态,那么被阻塞的ThreadA 的唤醒工作由AQS 队列来完成</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="图解分析-1"><a href="#图解分析-1" class="headerlink" title="图解分析"></a>图解分析</h6><p>执行完doSignal 以后,会把condition 队列中的节点转移到AQS 队列中</p>
<p>这个时候会判断ThreadA的prev 节点也就是head节点的waitStatus,如果大于0 或者设置signal 失败,表示节点被设置成了CANCELLED状态.这个时候会唤醒ThreadA 这个线程,否则就基于AQS 队列的机制来唤醒,也就是等到ThreadB 释放锁之后来唤醒ThreadA</p>
<h5 id="被阻塞的线程唤醒后的逻辑"><a href="#被阻塞的线程唤醒后的逻辑" class="headerlink" title="被阻塞的线程唤醒后的逻辑"></a>被阻塞的线程唤醒后的逻辑</h5><p>前面在分析 await方法时,线程会被阻塞.而通过signal 被唤醒后又继续回到上次执行的逻辑中被标注为红色部分的代码</p>
<p>checkInterruptWhileWaiting 这个方法是干啥的呢? 其实从名字上就可以看出来,就是ThreadA 在condition 队列被阻塞的过程中,有没有被其他线程触发过中断请求 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">           &#x2F;&#x2F;  表示await 允许被中断</span><br><span class="line">           if (Thread.interrupted())</span><br><span class="line">               throw new InterruptedException();</span><br><span class="line">           &#x2F;&#x2F; 创建一个新的节点,节点状态为condition, 采用的数据结构依然为链表,</span><br><span class="line">           Node node &#x3D; addConditionWaiter();</span><br><span class="line">           &#x2F;&#x2F;  释放当前的锁,得到锁的状态,并唤醒AQS队列中的一个线程</span><br><span class="line">           int savedState &#x3D; fullyRelease(node);</span><br><span class="line">           int interruptMode &#x3D; 0;</span><br><span class="line">           &#x2F;&#x2F; 判断这个节点是否在AQS队列中,第一次判断的是false, 因为前面已经是释放过锁了.</span><br><span class="line">           while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">               &#x2F;&#x2F; 通过park 挂起当前线程</span><br><span class="line">               LockSupport.park(this);</span><br><span class="line">               if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 当这个线程醒来之后,会尝试拿锁,当acquireQueued 返回false 就是拿到锁了</span><br><span class="line">           &#x2F;&#x2F; interruptMode !&#x3D; THROW_IE 表示这个线程没有成功将node 入队,但是signal 执行了enq 方法让其入队了</span><br><span class="line">           &#x2F;&#x2F; 将interruptMode 设置为 REINTERRUPT</span><br><span class="line">           if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">               interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">           &#x2F;&#x2F; 如果node 的下一个等待着不是null, 则进行清理,清理condition队列上的节点</span><br><span class="line">           &#x2F;&#x2F; 如果是null,则不需要清理</span><br><span class="line">           if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">               unlinkCancelledWaiters();</span><br><span class="line">           &#x2F;&#x2F; 如果线程被中断了,需要抛出异常,或者什么都不做.</span><br><span class="line">           if (interruptMode !&#x3D; 0)</span><br><span class="line">               reportInterruptAfterWait(interruptMode);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h6 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting"></a>checkInterruptWhileWaiting</h6><p>如果当前线程被中断,则调用transferAfterCancelledWait 方法判断后续的处理应该是抛出InterruptedException 异常 还是重新中断</p>
<p>这里需要注意的是,如果第一次CAS 失败了,则不能判断当前线程是先进行了中断还是先进行了signal方法的调用,可能是先执行了signal 然后中断,也可能是先执行了中断,后执行了signal。 当然 这两个操作肯定是发生在CAS之前,这时需要做的就是等待当前线程的node被添加到AQS 队列后，也就是enq方法返回后,返回false 告诉 checkInterruptWhileWaiting 方法返回 REINTERRUPT(1), 后续进行重新中断。</p>
<p>简单来说,该方法的返回值代表当前线程是否在park的时候被中断唤醒,如果为true, 表示中断在siganl调用之前,signal 还未执行. 那么这个时候会根据await() 的语义,在await 时遇到中断需要抛出InterruptedException ,返回true 就是告诉checkInterruptWhileWaiting 返回THROW_IE(-1). 如果返回false ,否则表示siganl 已经执行过了,只需要响应中断即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> private int checkInterruptWhileWaiting(Node node) &#123;</span><br><span class="line">        return Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">            0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> final boolean transferAfterCancelledWait(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用cas 修改节点状态,如果 还能修改成功,说明线程被中断时,signal 还没有被调用</span><br><span class="line">    &#x2F;&#x2F; 这里有一个知识点,就是线程被唤醒,并不一定是在java层面执行了 lockSupport.unpark,也就是调用了线程的interrupt()方法,这个方法</span><br><span class="line">    &#x2F;&#x2F; 会更新一个中断标识,并且会唤醒处于阻塞状态下的线程</span><br><span class="line">    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果cas成功,则把node添加到AQS队列中</span><br><span class="line">        enq(node);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * If we lost out to a signal(), then we can&#39;t proceed</span><br><span class="line">     * until it finishes its enq().  Cancelling during an</span><br><span class="line">     * incomplete transfer is both rare and transient, so just</span><br><span class="line">     * spin.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 循环检测node是否已经添加到AQS队列中,如果没有,则通过yield</span><br><span class="line">    while (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><p>这个方法在讲AQS的时候说过,是当前被唤醒的节点ThreadA 去抢占锁,并且要恢复到原本的重入次数状态.调用完这个方法之后,AQS队列的状态如下:将head节点的waitStatus 设置为-1 Signal 状态</p>
<h5 id="reportInterruptAfterWait"><a href="#reportInterruptAfterWait" class="headerlink" title="reportInterruptAfterWait"></a>reportInterruptAfterWait</h5><p>根据checkInterruptWhileWaiting 方法返回的中断标识来进行中断上报,如果是THROW_IE,则抛出中断异常,如果是REINTERRUPT,则重新响应中断.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void reportInterruptAfterWait(int interruptMode)</span><br><span class="line">         throws InterruptedException &#123;</span><br><span class="line">         if (interruptMode &#x3D;&#x3D; THROW_IE)</span><br><span class="line">             throw new InterruptedException();</span><br><span class="line">         else if (interruptMode &#x3D;&#x3D; REINTERRUPT)</span><br><span class="line">             selfInterrupt();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Condition-总结"><a href="#Condition-总结" class="headerlink" title="Condition 总结"></a>Condition 总结</h3><h4 id="await-和-signal-的总结"><a href="#await-和-signal-的总结" class="headerlink" title="await 和 signal 的总结"></a>await 和 signal 的总结</h4><p><img src="http://files.luyanan.com//img/20190812142913.jpg"></p>
<p>我们把前面的整个分解的图在通过一张整体的结构图来表述,线程awaitThread 先通过lock.lock() 方法 获得锁成功后调用了 condition.await() 方法进入了等待队列中,而另一个线程signalThread通过lock.lock() 方法获得锁成功后调用了condition.signal() 或者signalAll() 方法,使得线程awaitThread 能够有机会移入到同步队列中,当其他线程释放lock 后使得线程 awaitThread 能够有机会获取lock,从而使得线程awaitThread 能够从await 方法中推出执行后续操作.如果awaitThread 获得lock失败会直接进入到同步队列中.</p>
<p><strong>阻塞:</strong> 在await方法中,在线程释放锁资源后,如果节点不在AQS等待队列,则阻塞当前线程,如果在等待队列,则自旋鞥带尝试获得锁.</p>
<p><strong>释放:</strong> signal 后,节点会从condition队列移动到 AQS等待队列,则进入正常锁的获得流程.</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>countDownLatch 是一个同步工具类,它允许一个或者多个线程一直等待,直到其他线程的操作执行完毕再执行.,从命名汇总可以解读到 countdown 是倒数的意思,类似于我们倒计时的概念</p>
<p>countDownLatch 提供了两个方法.一个是 countDown,一个是 await . countDownLatch 在初始化的时候需要传入一个整数,在这个整数倒数到0之前,调用await 方法的线程都必须等待,然后通过countDown 来倒数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.notes.concurrent;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;12</span><br><span class="line"> * &lt;p&gt;countDownLatch的demo&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行中&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行完毕&quot;);</span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行中&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行完毕&quot;);</span><br><span class="line">        &#125;,&quot;t2&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行中&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + &quot;执行完毕&quot;);</span><br><span class="line">        &#125;,&quot;t3&quot;).start();</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;所有线程执行结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t1-执行中</span><br><span class="line">t1-执行完毕</span><br><span class="line">t2-执行中</span><br><span class="line">t3-执行中</span><br><span class="line">t3-执行完毕</span><br><span class="line">t2-执行完毕</span><br><span class="line">所有线程执行结束</span><br></pre></td></tr></table></figure>
<p>从代码的实现上来看,有点类似于join的功能,但是比join  更加的灵活.CountDownLatch 构造函数会接受一个int 类型的参数作为计数器的初始值. 当调用CountDownLatch的 countDown 方法的时候,这个计数器就会减1,通过await方法去阻塞主流程.</p>
<h5 id="模拟高并发"><a href="#模拟高并发" class="headerlink" title="模拟高并发"></a>模拟高并发</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.notes.concurrent;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;12</span><br><span class="line"> * &lt;p&gt;使用countDownLatch 模拟高并发&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class CountDownLatchDemo2 extends  Thread &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static CountDownLatch countDownLatch &#x3D; new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;ThreadName:&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            new CountDownLatchDemo2().start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 总的来说,凡是涉及到需要指定某个任务执行之前,需要等待前置任务执行完毕之后才执行的场景,都可以使用CountDownLatch</p>
<h4 id="CountDownLatch的源码分析"><a href="#CountDownLatch的源码分析" class="headerlink" title="CountDownLatch的源码分析"></a>CountDownLatch的源码分析</h4><p> <img src="http://files.luyanan.com//img/20190812154533.jpg"><br> 对于CountDownLatch ,我们仅仅需要关心两个方法,一个是countDown,另一个是 await()方法。</p>
<p> countDown() 方法每次调用都会将state 减1,知道state 的值为0; 而await方法是一个阻塞方法,当state 减为0的时候,await方法才会返回. await可以被多个线程调用,大家在这个时候脑子里面要有个图: 所有调用了await方法的线程阻塞在AQS队列中,等待条件(state = 0) 满足,将线程从队列中一个个的唤醒过来.</p>
<h5 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly"></a>acquireSharedInterruptibly</h5><p> countDownLatch 也用到了AQS,在CountDownLatch 内部写了一个Sync 并且继承了AQS这个抽象类重写了AQS中的共享锁的方法. 首先看到下面这个代码,这段代码主要是判断当前线程是否获取到了共享锁;(在CountDownLatch中使用的是共享锁机制,因为在CountDownLatch 中并不需要实现互斥的特性)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">         throws InterruptedException &#123;</span><br><span class="line">     if (Thread.interrupted())</span><br><span class="line">         throw new InterruptedException();</span><br><span class="line">     &#x2F;&#x2F; state 如果不等于0,说明当前线程需要加入到共享锁队列</span><br><span class="line">     if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">         doAcquireSharedInterruptibly(arg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h5><ol>
<li>addWaiter 设置为shared 模式</li>
<li>tryAcquire和tryAcquireShared 的返回值不同,因此会多出一个判断过程.</li>
<li>在判断前驱节点是头节点之后,调用了setHeadAndPropagate方法,而不是简单的更新了一下头节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">      throws InterruptedException &#123;</span><br><span class="line">      &#x2F;&#x2F; 创建一个共享模式的节点添加到队列中</span><br><span class="line">      final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">      boolean failed &#x3D; true;</span><br><span class="line">      try &#123;</span><br><span class="line">          for (;;) &#123;</span><br><span class="line">              final Node p &#x3D; node.predecessor();</span><br><span class="line">              if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                  &#x2F;&#x2F; 判断尝试获得锁</span><br><span class="line">                  int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                  &#x2F;&#x2F; r &gt;&#x3D;0 表示尝试获取到了执行权限,这个时候因为 state !&#x3D;0 ,所以不会执行这段代码</span><br><span class="line">                  if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                      setHeadAndPropagate(node, r);</span><br><span class="line">                      p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                      failed &#x3D; false;</span><br><span class="line">                      return;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              &#x2F;&#x2F; 阻塞线程</span><br><span class="line">              if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  throw new InterruptedException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          if (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="图解分析-2"><a href="#图解分析-2" class="headerlink" title="图解分析"></a>图解分析</h6><p>加入这个时候有是三个线程都调用了await方法,由于这个时候state的值还不为0,所以这三个线程都会加入到AQS队列中,并且这三个线程都属于阻塞状态.</p>
<p><img src="http://files.luyanan.com//img/20190812163630.jpg"></p>
<h4 id="CountDownLatch-countDown"><a href="#CountDownLatch-countDown" class="headerlink" title="CountDownLatch.countDown"></a>CountDownLatch.countDown</h4><p>由于线程被await 方法阻塞了,所以只能等到countDown 方法使得state = 0的时候才会被唤醒,我们来看看countDown 做了什么?</p>
<ol>
<li>只有当state 减为0的时候,tryReleaseShared 才返回true, 否则只是简单的 state = state -1</li>
<li>如果state = 0,  则调用 doReleaseShared 唤醒 处于await 状态下的线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">        &#x2F;&#x2F; 用自旋的方式实现state 减1</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0)</span><br><span class="line">                return false;</span><br><span class="line">            int nextc &#x3D; c-1;</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc &#x3D;&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AQS-doReleaseShared"><a href="#AQS-doReleaseShared" class="headerlink" title="AQS.doReleaseShared"></a>AQS.doReleaseShared</h4></li>
</ol>
<p>共享锁的释放和独占锁的释放是有一定的差别的</p>
<p>前面唤醒锁的逻辑和独占锁是一样的,先判断头节点是不是SIGNAL状态,如果是,则修改为0,并且唤醒头节点的下一个节点.</p>
<blockquote>
<p>PROPAGATE： 标识为PROPAGETE 状态的节点,是共享锁模式下的节点状态,处于这个状态的节点会对线程的唤醒进行传播.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">     &#x2F;*</span><br><span class="line">      * Ensure that a release propagates, even if there are other</span><br><span class="line">      * in-progress acquires&#x2F;releases.  This proceeds in the usual</span><br><span class="line">      * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">      * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">      * ensure that upon release, propagation continues.</span><br><span class="line">      * Additionally, we must loop in case a new node is added</span><br><span class="line">      * while we are doing this. Also, unlike other uses of</span><br><span class="line">      * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">      * fails, if so rechecking.</span><br><span class="line">      *&#x2F;</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         Node h &#x3D; head;</span><br><span class="line">         if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">             int ws &#x3D; h.waitStatus;</span><br><span class="line">             if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                     continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                 unparkSuccessor(h);</span><br><span class="line">             &#125;</span><br><span class="line">             &#x2F;&#x2F; 这个CAS失败的场景是: 执行到这里的时候,刚好有一个节点入队,入队会将这个ws设置为-1</span><br><span class="line">             else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                 continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 如果到这里的时候,前面唤醒的线程已经占领了head,那么再循环通过检查头节点是否被改变了,如果改变了就继续循环</span><br><span class="line">         if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>h == head:说明头节点还没有被刚刚用unparkSuccessor唤醒的线程(这里可以理解为ThreadB) 占有,此时break 退出循环.</li>
<li> h!= head: 头节点被刚刚唤醒的线程占用,那么这里重新进入到下一轮循环,唤醒下一个节点(这里是ThreadB),我们知道等到ThreadB被唤醒后,其实是会主动唤醒ThreadC…</li>
</ul>
<h5 id="doAcquireSharedInterruptibly-1"><a href="#doAcquireSharedInterruptibly-1" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h5><p>一旦ThreadA被唤醒后,代码又会继续回到doAcquireSharedInterruptibly 中来执行.如果当前state = 0的条件满足,则会执行setHeadAndPropagate 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">       throws InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; 创建一个共享模式的节点添加到队列中</span><br><span class="line">       final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">       boolean failed &#x3D; true;</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F; 被唤醒的线程进入下一次循环继续判断</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               final Node p &#x3D; node.predecessor();</span><br><span class="line">               if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 判断尝试获得锁</span><br><span class="line">                   int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                   &#x2F;&#x2F; r &gt;&#x3D;0 表示尝试获取到了执行权限,这个时候因为 state !&#x3D;0 ,所以不会执行这段代码</span><br><span class="line">                   if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       &#x2F;&#x2F; 把当前节点移除AQS队列</span><br><span class="line">                       p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                       failed &#x3D; false;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               &#x2F;&#x2F; 阻塞线程</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   throw new InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h5><p>这个方法的主要作用是把被唤醒的节点设置成head节点,然后继续唤醒队列中的其他线程.</p>
<p>由于现在队列中有三个线程处于阻塞状态,一旦ThreaA 被唤醒,并且设置成head后,会继续唤醒后续的ThreadB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">       Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">       setHead(node);</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * Try to signal next queued node if:</span><br><span class="line">        *   Propagation was indicated by caller,</span><br><span class="line">        *     or was recorded (as h.waitStatus either before</span><br><span class="line">        *     or after setHead) by a previous operation</span><br><span class="line">        *     (note: this uses sign-check of waitStatus because</span><br><span class="line">        *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">        * and</span><br><span class="line">        *   The next node is waiting in shared mode,</span><br><span class="line">        *     or we don&#39;t know, because it appears null</span><br><span class="line">        *</span><br><span class="line">        * The conservatism in both of these checks may cause</span><br><span class="line">        * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">        * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">        * anyway.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">           (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">           Node s &#x3D; node.next;</span><br><span class="line">           if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">               doReleaseShared();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="图解分析-3"><a href="#图解分析-3" class="headerlink" title="图解分析"></a>图解分析</h6><p><img src="http://files.luyanan.com//img/20190812171333.jpg"></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 也就是我们常说的信号灯,Semaphore 可以控制同时访问的线程个数,通过acquire 获得一个许可,如果没有就等待，通过release 释放一个许可.有点类似于限流的作用. 叫信号灯的原因也和她的用户有关，比如某商场就5个停车位,每个停车位只能停一辆车,如果这个时候来了10辆车,必须要等到前面有空的车位才能进去.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.notes.concurrent;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;12</span><br><span class="line"> * &lt;p&gt;Semaphore demo&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(5);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(new Car(i,semaphore)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Car extends  Thread &#123;</span><br><span class="line"></span><br><span class="line">        private int num;</span><br><span class="line"></span><br><span class="line">        private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        public Car(int num, Semaphore semaphore) &#123;</span><br><span class="line">            this.num &#x3D; num;</span><br><span class="line">            this.semaphore &#x3D; semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(&quot;第&quot; + num + &quot;个车位被占用了&quot;);</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(&quot;第&quot; + num + &quot;个车位被释放了&quot;);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">第0个车位被占用了</span><br><span class="line">第2个车位被占用了</span><br><span class="line">第1个车位被占用了</span><br><span class="line">第3个车位被占用了</span><br><span class="line">第4个车位被占用了</span><br><span class="line">第4个车位被释放了</span><br><span class="line">第1个车位被释放了</span><br><span class="line">第0个车位被释放了</span><br><span class="line">第5个车位被占用了</span><br><span class="line">第7个车位被占用了</span><br><span class="line">第3个车位被释放了</span><br><span class="line">第2个车位被释放了</span><br><span class="line">第8个车位被占用了</span><br><span class="line">第9个车位被占用了</span><br><span class="line">第6个车位被占用了</span><br><span class="line">第8个车位被释放了</span><br><span class="line">第5个车位被释放了</span><br><span class="line">第7个车位被释放了</span><br><span class="line">第6个车位被释放了</span><br><span class="line">第9个车位被释放了</span><br></pre></td></tr></table></figure>

<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>Semaphore比较常见的就是用来做限流</p>
<h5 id="Semaphore-源码分析"><a href="#Semaphore-源码分析" class="headerlink" title="Semaphore 源码分析"></a>Semaphore 源码分析</h5><p>从Semaphore的功能上来看,我们基本能猜测到他的底层一定是基于AQS的共享锁,因为需要实现多个线程共享一个令牌池.</p>
<p>创建Semaphore实例的时候,需要一个参数permit, 这个基本上可以确定是设置给AQS的state的,然后每个线程调用acquire 的时候,执行state = state -1, release的时候执行 state = state +1,当然,acquire的时候,如果state = 0 说明没有资源了,需要等待其他线程release</p>
<p>Semaphore 分公平策略和非公平策略</p>
<h5 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">      private static final long serialVersionUID &#x3D; 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">      FairSync(int permits) &#123;</span><br><span class="line">          super(permits);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">          for (;;) &#123;</span><br><span class="line">              &#x2F;&#x2F; 区别在于是不是会先判断是否有线程在排队,然后才进行CAS 减操作</span><br><span class="line">              if (hasQueuedPredecessors())</span><br><span class="line">                  return -1;</span><br><span class="line">              int available &#x3D; getState();</span><br><span class="line">              int remaining &#x3D; available - acquires;</span><br><span class="line">              if (remaining &lt; 0 ||</span><br><span class="line">                  compareAndSetState(available, remaining))</span><br><span class="line">                  return remaining;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="NofairSync"><a href="#NofairSync" class="headerlink" title="NofairSync"></a>NofairSync</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID &#x3D; -2694183684443567898L;</span><br><span class="line"></span><br><span class="line">       NonfairSync(int permits) &#123;</span><br><span class="line">           super(permits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">           return nonfairTryAcquireShared(acquires);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">          final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               int available &#x3D; getState();</span><br><span class="line">               int remaining &#x3D; available - acquires;</span><br><span class="line">               if (remaining &lt; 0 ||</span><br><span class="line">                   compareAndSetState(available, remaining))</span><br><span class="line">                   return remaining;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier 的字面意思是可循环使用(Cyclic)的屏障(Barrier).他要做的事情是让一组线程到达一个屏障(也可以叫同步点)时被阻塞,知道最后一个线程达到屏障时,屏障才会开门,所有被屏障拦截的线程才会继续工作. CyclicBarrier的默认的构造方法是CyclicBarrier(int parties),其参数表示屏障拦截的线程数量,每个线程调用await方法告诉 CyclicBarrier 当前线程已经达到了屏障,然后当前线程被阻塞.</p>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p>当存在需要所有的子任务都完成时,才执行主任务,这个时候就可以选择使用CyclicBarrier</p>
<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>DataImportThread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.notes.concurrent.cyclicbarrier;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;12</span><br><span class="line"> * &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class DataImportThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String path;</span><br><span class="line"></span><br><span class="line">    public DataImportThread(CyclicBarrier cyclicBarrier, String path) &#123;</span><br><span class="line">        this.cyclicBarrier &#x3D; cyclicBarrier;</span><br><span class="line">        this.path &#x3D; path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;开始导入:&quot; + path + &quot;位置的数据&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CycliBarrierDemo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.notes.concurrent.cyclicbarrier;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author luyanan</span><br><span class="line"> * @since 2019&#x2F;8&#x2F;12</span><br><span class="line"> * &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class CycliBarrierDemo extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;开始进行数据分析&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3, new CycliBarrierDemo());</span><br><span class="line"></span><br><span class="line">        new Thread(new DataImportThread(cyclicBarrier,&quot;path1&quot;)).start();</span><br><span class="line">        new Thread(new DataImportThread(cyclicBarrier,&quot;path2&quot;)).start();</span><br><span class="line">        new Thread(new DataImportThread(cyclicBarrier,&quot;path3&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始导入:path1位置的数据</span><br><span class="line">开始导入:path2位置的数据</span><br><span class="line">开始导入:path3位置的数据</span><br><span class="line">开始进行数据分析</span><br></pre></td></tr></table></figure>

<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ol>
<li>对于指定计数值 parties,若由于某种原因,没有足够的线程调用CyclicBarrier的await() ，则所有调用 await() 的线程都会被阻塞.</li>
<li>同样的CyclicBarrier 也可以调用 await(timeout,unit),设置超时时间,在设定的时候内,没有足够线程到达,则解除阻塞状态,继续工作.</li>
<li>通过rest重置计数,会使得进入await的线程出现BrokenBarrierException；</li>
<li>如果采用是CyclicBarrier(int parties,Runnable barrierAction) 构造方法,执行 barrierAction操作的最后一个到达线程.</li>
</ol>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>CyclicBarrier 相比CountDownLatch 来说,简单很多,源码是基于ReentrantLock和Condition组合使用的.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86(1)/" rel="prev" title="并发编程的基本认识(1)">
      <i class="fa fa-chevron-left"></i> 并发编程的基本认识(1)
    </a></div>
      <div class="post-nav-item">
    <a href="/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8C%91%E6%88%98(2)/" rel="next" title="多线程的基本原理及挑战(2)">
      多线程的基本原理及挑战(2) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">5. 常见的并发工具的使用和原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition"><span class="nav-number">1.1.</span> <span class="nav-text">Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">Condition的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition-wait"><span class="nav-number">1.1.2.</span> <span class="nav-text">condition.wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.1.3.</span> <span class="nav-text">Condition 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#condition-await"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">condition.await</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#addConditionWaiter"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">addConditionWaiter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fullyRelease"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">fullyRelease</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90"><span class="nav-number">1.1.3.1.2.1.</span> <span class="nav-text">图解分析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isOnSyncQueue"><span class="nav-number">1.1.3.1.3.</span> <span class="nav-text">isOnSyncQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%A7%E5%AE%B6%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E5%9C%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADThreadA-%E8%BF%99%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8EAQS%E9%98%9F%E5%88%97%E4%B8%AD%E5%91%A2"><span class="nav-number">1.1.3.1.3.1.</span> <span class="nav-text">大家思考一下,基于现在的逻辑结构.如何去判断ThreadA 这个节点是否存在于AQS队列中呢?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#condition-signal"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">condition.signal</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#doSignal"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">doSignal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS-transferForSignal"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">AQS.transferForSignal</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90-1"><span class="nav-number">1.1.3.2.2.1.</span> <span class="nav-text">图解分析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%94%A4%E9%86%92%E5%90%8E%E7%9A%84%E9%80%BB%E8%BE%91"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">被阻塞的线程唤醒后的逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#checkInterruptWhileWaiting"><span class="nav-number">1.1.3.2.3.1.</span> <span class="nav-text">checkInterruptWhileWaiting</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#acquireQueued"><span class="nav-number">1.1.3.2.4.</span> <span class="nav-text">acquireQueued</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reportInterruptAfterWait"><span class="nav-number">1.1.3.2.5.</span> <span class="nav-text">reportInterruptAfterWait</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.4.</span> <span class="nav-text">Condition 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#await-%E5%92%8C-signal-%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">await 和 signal 的总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">1.2.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.0.0.1.</span> <span class="nav-text">模拟高并发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">CountDownLatch的源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acquireSharedInterruptibly"><span class="nav-number">1.2.0.1.1.</span> <span class="nav-text">acquireSharedInterruptibly</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#doAcquireSharedInterruptibly"><span class="nav-number">1.2.0.1.2.</span> <span class="nav-text">doAcquireSharedInterruptibly</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90-2"><span class="nav-number">1.2.0.1.2.1.</span> <span class="nav-text">图解分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-countDown"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">CountDownLatch.countDown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-doReleaseShared"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">AQS.doReleaseShared</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#doAcquireSharedInterruptibly-1"><span class="nav-number">1.2.0.3.1.</span> <span class="nav-text">doAcquireSharedInterruptibly</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setHeadAndPropagate"><span class="nav-number">1.2.0.3.2.</span> <span class="nav-text">setHeadAndPropagate</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90-3"><span class="nav-number">1.2.0.3.2.1.</span> <span class="nav-text">图解分析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.3.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.0.0.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.0.0.2.</span> <span class="nav-text">Semaphore 源码分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FairSync"><span class="nav-number">1.3.0.0.3.</span> <span class="nav-text">FairSync</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NofairSync"><span class="nav-number">1.3.0.0.4.</span> <span class="nav-text">NofairSync</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.4.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.4.0.0.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">1.4.0.0.2.</span> <span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">1.4.0.0.2.1.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.0.0.3.</span> <span class="nav-text">实现原理</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/luyanan0718" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luyanan0718" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/luyanan0718@163.com" title="E-Mail → luyanan0718@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://luyanan.com/" title="https:&#x2F;&#x2F;luyanan.com">Site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
