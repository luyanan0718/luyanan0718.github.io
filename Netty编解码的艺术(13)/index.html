<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Netty 编解码的艺术1. 什么是拆包&#x2F;粘包1. TCP 粘包&#x2F;拆包TCP 是一个”流”协议, 所谓流, 就是没有界限的一长串二进制数据, TCP 作为传输协议并不了解业务数据的具体含义, 它会根据TCP缓冲区的实际情况进行数据包的划分, 所以在业务上认为是一个完整的包, 可能会被TCP 拆分成多个包进行发送, 也有可能把多个小的包封装成一个大的数据包发送, 这就是所谓的TCP 粘包和拆包问题.">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty编解码的艺术(13)">
<meta property="og:url" content="http://luyanan.com/Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF(13)/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="Netty 编解码的艺术1. 什么是拆包&#x2F;粘包1. TCP 粘包&#x2F;拆包TCP 是一个”流”协议, 所谓流, 就是没有界限的一长串二进制数据, TCP 作为传输协议并不了解业务数据的具体含义, 它会根据TCP缓冲区的实际情况进行数据包的划分, 所以在业务上认为是一个完整的包, 可能会被TCP 拆分成多个包进行发送, 也有可能把多个小的包封装成一个大的数据包发送, 这就是所谓的TCP 粘包和拆包问题.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20191012102026.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012110838.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012112806.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012144654.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012164153.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012170539.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012171722.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191012172402.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191014093942.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191014101505.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015113055.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015164216.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015173127.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015173401.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015175718.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015175730.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015211919.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015211943.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015212511.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015212511.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015213053.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191015213115.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191016115234.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191016145712.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191016213539.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191017163858.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191018151311.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191018160007.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191018160207.png">
<meta property="article:published_time" content="2021-03-12T02:15:06.388Z">
<meta property="article:modified_time" content="2021-03-12T02:15:06.388Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20191012102026.png">

<link rel="canonical" href="http://luyanan.com/Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF(13)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Netty编解码的艺术(13) | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF(13)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty编解码的艺术(13)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 10:15:06" itemprop="dateCreated datePublished" datetime="2021-03-12T10:15:06+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Netty-编解码的艺术"><a href="#Netty-编解码的艺术" class="headerlink" title="Netty 编解码的艺术"></a>Netty 编解码的艺术</h1><h2 id="1-什么是拆包-粘包"><a href="#1-什么是拆包-粘包" class="headerlink" title="1. 什么是拆包/粘包"></a>1. 什么是拆包/粘包</h2><h3 id="1-TCP-粘包-拆包"><a href="#1-TCP-粘包-拆包" class="headerlink" title="1. TCP 粘包/拆包"></a>1. TCP 粘包/拆包</h3><p>TCP 是一个”流”协议, 所谓流, 就是没有界限的一长串二进制数据, TCP 作为传输协议并不了解业务数据的具体含义, 它会根据TCP缓冲区的实际情况进行数据包的划分, 所以在业务上认为是一个完整的包, 可能会被TCP 拆分成多个包进行发送, 也有可能把多个小的包封装成一个大的数据包发送, 这就是所谓的TCP 粘包和拆包问题.</p>
<p>同样, 在Netty 的编码器中, 也会对半包和粘包问题做相应的处理. 什么是半包? 顾名思义就是不完整的数据包, 因为Netty 在轮询读事件的时候, 每次将channel 中读取的数据, 不一定是一个完整的数据包, 这种情况下, 就叫半包。 粘包同样也不难理解, 如果Client 往Server 发送数据包, 如果发送频繁很有可能会将多个数据都发送到通道中, 如果在server 在读取的时候可能会读取到超过一个完整数据包的长度, 这种情况叫粘包. 有关半包和粘包, 如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20191012102026.png"></p>
<h3 id="2-粘包问题的解决策略"><a href="#2-粘包问题的解决策略" class="headerlink" title="2. 粘包问题的解决策略"></a>2. 粘包问题的解决策略</h3><p>由于底层的TCP 无法理解上层的业务数据, 所以在底层生物法保证数据包不被拆分和重组的, 这个问题只能通过上层的应用协议栈设计来解决. 业界的主流协议的解决方案, 可以归纳如下:</p>
<ol>
<li>消息定义: 报文大小固定长度, 例如每个报文的长度固定为200字节, 如果不够空位补空格.</li>
<li>包尾添加特殊分隔符, 例如每条报文结束都添加回车换行符(例如FTP协议)或者指定特殊字符作为报文分隔符, 接收方通过特殊分隔符切分报文区分.</li>
<li>将消息分为消息头和消息体, 消息头中包含信息的总长度(或者消息体长度) 的字段.</li>
<li>更复杂的自定义应用层协议.</li>
</ol>
<p>Netty 对半包或者粘包的处理其实也非常简单, 我们知道, 每个handler 是和channel 唯一绑定的, 一个handler 只对应一个channel. 所以将channel 中的数据读取时候经过解析, 如果不是一个完整的数据包, 则解析失败，将这块数据包进行保存, 等下次解析的时候再和这个数据包进行组装解析, 知道解析到完整的数据包, 才会将数据包进行往下传递.</p>
<h2 id="2-什么是编码和解码"><a href="#2-什么是编码和解码" class="headerlink" title="2. 什么是编码和解码"></a>2. 什么是编码和解码</h2><h3 id="1-编解码技术"><a href="#1-编解码技术" class="headerlink" title="1. 编解码技术"></a>1. 编解码技术</h3><p>通常我们也喜欢将编码(Encode) 称为序列化(serialization), 它将对象序列化为字节数组, 用于网络传输、数据持久化或者其他用途. 反之, 解码(Decode) 称为反序列化(deserialization)  把从网络、磁盘等读取的字节数组还原成原始对象(通常是原始对象的拷贝), 以方便后续的业务逻辑操作. 进行远程跨进程服务调用时(例如RPC调用) , 需要使用特定的编解码技术, 对需要进行网络传输的对象做编码或者解码， 以便完成远程调用.</p>
<h3 id="2-Netty-为什么要提供编解码框架"><a href="#2-Netty-为什么要提供编解码框架" class="headerlink" title="2. Netty 为什么要提供编解码框架?"></a>2. Netty 为什么要提供编解码框架?</h3><p>作为一个高性能的异步、NIO 通信框架， 编解码框架是Netty 的重要组成部分. 尽管站在微内核的角度看, 编解码框架并不是Netty 微内核的组成部分, 但是通过ChannelHandler 定制扩展出的编解码框架却是不可或缺的.</p>
<p>然后, 我们已经知道在Netty 中, 从网络读取的inbound 消息, 需要经过解码, 将二进制的数据转换成应用协议消息或者业务消息, 才能够被上层的应用逻辑识别和处理. 同理,用户发送方到网络的outbound 业务消息, 需要经过编码转换成二进制字节数组(对于Netty来说就是ByteBuf) 才能够发送到网络对端。 编码和解码功能是NIO框架的有机组成部分,无论是由业务定制扩展实现, 还是NIO框架内置编解码能力, 该功能是必不可少的. </p>
<p>为了降低用户的开发难度, Netty 对常用的功能和API 做了装饰, 以屏蔽底层的实现细节, 编解码功能的定制, 对于熟悉Netty 底层实现的开发者而言， 直接基于ChannelHandler 扩展开发, 难度并不是很大。 但是对于大部分初学者或者不愿意去了解底层实现细节的用户, 需要提供给他们更简单的类库和API，而不是ChannelHandler.</p>
<p>Netty 在这方面做的非常出色, 针对编解码功能, 他即提供了通用的编码吗框架供用户扩展, 又提供了常用的编解码类库供用户直接使用, 在保证定制扩展性的基础上, 尽量降低用户的开发工作量和开发门槛, 提升开发效率.</p>
<p>Netty 预置的编解码功能列表如下: Base64、Protobuf、JBoss Marshalling、Spdy等.</p>
<p><img src="http://files.luyanan.com//img/20191012110838.png"></p>
<h2 id="3-Netty-中常用的编码器"><a href="#3-Netty-中常用的编码器" class="headerlink" title="3. Netty 中常用的编码器"></a>3. Netty 中常用的编码器</h2><p>Netty 默认提供了多个解码器, 可以进行分包的操作, 满足99%的编码需求.</p>
<h3 id="1-ByteToMessageDecoder-抽象解码器"><a href="#1-ByteToMessageDecoder-抽象解码器" class="headerlink" title="1. ByteToMessageDecoder 抽象解码器"></a>1. ByteToMessageDecoder 抽象解码器</h3><p>使用NIO 进行网络编程时, 往往需要将读取到的字节数组或者字节缓冲区解码为业务可以使用的POJO对象. 为了方便业务将ByteBuf 解码成业务域POJO 对象, Netty 提供了ByteToMessageDecoder  抽象工具解码类.</p>
<p>用户自定义解码器继承ByteToMessageDecoder, 只需要实现 <code>void decode（ChannelHandler Context ctx, ByteBuf in,List&lt;Object&gt; out）</code>  抽象方法即可完成 ByteBuf 到POJO 对象的解码.</p>
<p>由于ByteToMessageDecoder  并没有考虑TCP 粘包和拆包等场景, 用户自定义解码器的时候需要自己处理”读半包” 的问题. 正因为如此, 大部分场景不会直接继承 ByteToMessageDecoder  , 而是继承另外一些更高级的解码器来屏蔽半包的处理。 实际项目中,通常将LengthFieldBasedFrameDecoder 和 ByteToMessageDecoder 组合使用, 前者负责将网络读取的数据报解码为整包消息, 后者负责将整包消息解码成最终的业务对象. 除了和其他解码器组合形成新的解码器之外, ByteToMessageDecoder 也是很多基础解码器的父类, 它的继承关系如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191012112806.png"></p>
<p>下面我们来看源码, ByteToMessageDecoder  类的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出, ByteToMessageDecoder   继承了ChannelInboundHandlerAdapter , 这是一个inbound 类型的handler, 也就是处理流向自身事件的handler, 其次, 该类通过abstract 关键字修饰, 说明是个抽象类, 在我们实际使用的时候, 并不是直接使用这个类, 而是使用其子类, 类定义了解码器的骨架方法, 具体实现逻辑交给子类, 同样, 在半包处理中也是由该类实进行实现的, Netty 中很多解码器都实现了这个类, 并且， 我们也可以通过实现该类进行自定义解码器.</p>
<p>我们重点关注一下该类的cumulation 的这个属性, 它就是有关半包处理的关键属性,从概述中我们知道,Netty 会将不完整的数据包进行保存, 这个数据包就是保存在这个属性中。我们知道ByteBuf 读取完数据会传递channelRead 事件, 传播过程中会调用handler 的channelRead 方法, ByteToMessageDecoder   的channelRead 方法就是编码的关键部分, 我们来看看 channelRead() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">            <span class="comment">// 简单当分成一个arrayList 对象, 用于盛放解析到的对象</span></span><br><span class="line">            CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteBuf data = (ByteBuf) msg;</span><br><span class="line">                <span class="comment">// 当前累加器为空, 说明这是第一次从IO流中读取数据</span></span><br><span class="line">                first = cumulation == <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    <span class="comment">// 如果是第一次, 则将累加器赋值为刚读进来的对象.</span></span><br><span class="line">                    cumulation = data;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果不是, 则把当前累加的数据和读进来的数据进行累加.</span></span><br><span class="line">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用子类的方法进行解析</span></span><br><span class="line">                callDecode(ctx, cumulation, out);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">                    numReads = <span class="number">0</span>;</span><br><span class="line">                    cumulation.release();</span><br><span class="line">                    cumulation = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">                    <span class="comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/4275</span></span><br><span class="line">                    numReads = <span class="number">0</span>;</span><br><span class="line">                    discardSomeReadBytes();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录list 长度</span></span><br><span class="line">                <span class="keyword">int</span> size = out.size();</span><br><span class="line">                decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line">                <span class="comment">// 向下传播</span></span><br><span class="line">                fireChannelRead(ctx, out, size);</span><br><span class="line">                out.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是ByteBuf 类型的往下传播</span></span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>这方法比较长, 我带大家一步步剖析, 首先判断如果传来的数据是ByteBuf , 则进入if 块中, <code>CodecOutputList out = CodecOutputList.newInstance();</code> 这里将当成一个ArrayList 就好, 用于保存解码完成的数据 <code>ByteBuf data = (ByteBuf) msg;</code> 这步将数据转换为 ByteBuf. <code>first = cumulation == null;</code>  表示如果 cumulation  == null 则说明没有存储半包数据, 则将当前的数据保存到数据 cumulation  中, 如果 cumulation  !=null.说明存储了半包数据, 则通过<code>cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data)</code> 将读取到的数据和原来的数据进行累加, 保存在属性 <code>cumulation </code> 中. 我们看 cumulation  属性的定义:</p>
<blockquote>
<p> private Cumulator cumulator = MERGE_CUMULATOR; </p>
</blockquote>
<p>这里调用了其静态属性 MERGE_CUMULATOR, 我们跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">            ByteBuf buffer;</span><br><span class="line">            <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</span><br><span class="line">                    || cumulation.refCnt() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// Expand cumulation (by replace it) when either there is not more room in the buffer</span></span><br><span class="line">                <span class="comment">// or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</span></span><br><span class="line">                <span class="comment">// duplicate().retain().</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See:</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/2327</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/1764</span></span><br><span class="line">                buffer = expandCumulation(alloc, cumulation, in.readableBytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer = cumulation;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.writeBytes(in);</span><br><span class="line">            in.release();</span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>这里创建了Cumulator 类型的静态对象, 并重写了cumulate 方法, 这个cumulate 方法 , 就是用于将 ByteBuf 进行拼接的方法. 在方法中, 首先判断 cumulation 是写指针 +in 的可读字节数是否超过了cumulation 的最大长度, 如果超过,则对cumulation 进行扩容, 如果没有超过, 则将其赋值到局部变量 buffer 中。 然后将in 的数据写到buffer 中 , 将in 进行释放, 返回写入数据后的ByteBuf. 回到channelRead 方法, 最后调用<code>callDecode(ctx, cumulation, out)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 只要累加器中有数据</span></span><br><span class="line">            <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">int</span> outSize = out.size();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断当前list 中是否有对象</span></span><br><span class="line">                <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果有对象, 则往下传播</span></span><br><span class="line">                    fireChannelRead(ctx, out, outSize);</span><br><span class="line">                    <span class="comment">// 清空list</span></span><br><span class="line">                    out.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Check if this handler was removed before continuing with decoding.</span></span><br><span class="line">                    <span class="comment">// If it was removed, it is not safe to continue to operate on the buffer.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// See:</span></span><br><span class="line">                    <span class="comment">// - https://github.com/netty/netty/issues/4635</span></span><br><span class="line">                    <span class="comment">// 解码过程中如ctx 被removed 掉就break</span></span><br><span class="line">                    <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    outSize = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前可读数据的长度</span></span><br><span class="line">                <span class="keyword">int</span> oldInputLength = in.readableBytes();</span><br><span class="line">                <span class="comment">// 子类实现</span></span><br><span class="line">                <span class="comment">// 子类解析, 解析完对象放到out 中</span></span><br><span class="line">                decode(ctx, in, out);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if this handler was removed before continuing the loop.</span></span><br><span class="line">                <span class="comment">// If it was removed, it is not safe to continue to operate on the buffer.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/1664</span></span><br><span class="line">                <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// list 解析前大小和解析后长度一样(什么都没有解析出来)</span></span><br><span class="line">                <span class="keyword">if</span> (outSize == out.size()) &#123;</span><br><span class="line">                    <span class="comment">// 原来可读的长度 == 解析后的可读长度</span></span><br><span class="line">                    <span class="comment">// 说明没有可读数据(当前累加的数据并没有拼成一个完整的数据包)</span></span><br><span class="line">                    <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                        <span class="comment">// 跳出循环(下次在读取数据才进行后续的解析)</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 没有解析到数据, 但是进行读取了</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// out 里面有数据, 但是没有从累加器中读取数据</span></span><br><span class="line">                <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(</span><br><span class="line">                            StringUtil.simpleClassName(getClass()) +</span><br><span class="line">                            <span class="string">&quot;.decode() did not read anything but decoded a message.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isSingleDecode()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先循环判断传入的ByteBuf 是否有可读的字节, 如果还有可读字节说明没有解码完成, 则循环解析解码, 然后判断集合out 的大小, 如果大小小于1, 说明out 中盛放了解码完成之后的数据, 然后将事件往下传播, 并清空out. 因为我们第一次解码out 是空的, 所以这里并不会进入if 块, 这部分我们稍后分析, 所以继续往下看. 通过<code>int oldInputLength = in.readableBytes()</code> 获取当前的ByteBuf, 其实也就是属性 cumulation 的可读字节数, 这里就是一个备份, 用于比较. 我们继续往下看, <code>decode(ctx, in, out)</code>  方法是最终的解码操作, 这步会读取 cumulation  并且将解码后的数据放入到集合out 中, 在ByteToMessageDecoder 中这个方法是一个抽象方法, 让子类去实现. 我们使用的netty 很多的解码都是继承了ByteToMessageDecoder 并且实现了 decode 方法从而完成了解码操作,同样我们也可以遵循相应的规则进行自定义解码器. 在之后的小节中会讲解netty 定义的解码器, 并剖析相关的实现细节. 继续往下看 <code>if (outSize == out.size()) </code>  这个判断表示解析之前的out 大小和解析之后的out 大小进行比较,如果相同则说明并没有解析出数据， 我们进入到if 块中. <code>if (oldInputLength == in.readableBytes())</code>  表示cumulation   的可读字节数在解析之前和解析之后是相同的. 说明解码方法中并没有解析数据, 也就是当前的数据并不是一个完整的数据包, 则跳出循环,留给下次解析。 否则说明没有解析出数据, 但是读取了, 所以跳出该次循环进入下次循环. 最后判断<code>if (oldInputLength == in.readableBytes())</code>  这里代表out 中有数据, 但是并没有从 cumulation    读数据, 说明这个out 的内容是非法的, 直接排除异常. 现在回到chanelRead方法, 我们来关注一下finally 代码块中的内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">               numReads = <span class="number">0</span>;</span><br><span class="line">               cumulation.release();</span><br><span class="line">               cumulation = <span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">               <span class="comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span></span><br><span class="line">               <span class="comment">// See https://github.com/netty/netty/issues/4275</span></span><br><span class="line">               numReads = <span class="number">0</span>;</span><br><span class="line">               discardSomeReadBytes();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> size = out.size();</span><br><span class="line">           decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line">           fireChannelRead(ctx, out, size);</span><br><span class="line">           out.recycle();</span><br></pre></td></tr></table></figure>

<p>首先判断 cumulation  不为null, 并且没有可读字节, 则将累加器进行释放, 并设置为null. 之后记录out的长度,通过fireChannelRead  将channelRead  事件进行向下传播, 并回收out 对象, 我们跟到<code>fireChannelRead(ctx, out, size)</code> 方法来看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i ++) &#123;</span><br><span class="line">          ctx.fireChannelRead(msgs.getUnsafe(i));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里遍历out 集合,并将里面的元素逐个往下传递, 以上就是有关解码的骨架逻辑.</p>
<h3 id="2-LineBasedFrameDecoder-行解码器"><a href="#2-LineBasedFrameDecoder-行解码器" class="headerlink" title="2. LineBasedFrameDecoder 行解码器"></a>2. LineBasedFrameDecoder 行解码器</h3><p>LineBasedFrameDecoder  是回车换行解码器, 如果用户发送的消息以回车换行符(以\r\n 或者直接以\n 结尾)作为消息结束的标识, 则可以直接使用Netty 的LineBasedFrameDecoder 对消息进行解码, 只需要在进行初始化Netty 服务端或者客户端时将LineBasedFrameDecoder 正确的添加到ChanenlPipeline 中即可, 不需要自己实现一套换行解码器. LineBasedFrameDecoder 的工作原理是它依次遍历ByteBuf 中的可读字节，判断看是否有“\n”或者“\r\n”, 如果有, 就以此位置为结束位置, 从可读索引到结束位置区间的字节就组成了一行. 它是以换行符为结束标识的解码器， 支持携带结束符或者不携带结束符两种解码方式, 同时支持配置单行的最大长度. 如果连续读取到最大长度后仍然没有发现换行符, 就会抛出异常. 同时忽略到之前读取到的异常码流. 防止由于数据报没有携带换行符导致接受到的ByteBuf 无限制积压, 引起系统内存溢出. 它的使用效果如下:</p>
<p>解码之前:</p>
<p><img src="http://files.luyanan.com//img/20191012144654.png"></p>
<p>通常情况下，LineBasedFrameDecoder 会和 StringDecoder 配合使用, 组合成按行切换的文本解码器. 对于文本类协议的解析, 文本换行解码器非常实用. 例如对HTTP 消息头的解析、FTP 协议消息的解析等. </p>
<p>下面我们简单给出文本换行符解码器的简单示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br></pre></td></tr></table></figure>

<p>初始化Channel 的时候,首先将LineBasedFrameDecoder 添加到ChannelPipeline 中, 然后再依次添加字符串解码器StringDecoder,业务handler.</p>
<p>接下来,我们来看 LineBasedFrameDecoder  的源码, LineBasedFrameDecoder   也继承了ByteToMessageDecoder, 首先看其参数定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Maximum length of a frame we&#x27;re willing to decode.  */</span></span><br><span class="line">    <span class="comment">// 数据包的最大长度, 超过该长度会进行丢弃模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxLength;</span><br><span class="line">    <span class="comment">/** Whether or not to throw an exception as soon as we exceed maxLength. */</span></span><br><span class="line">    <span class="comment">// 超过最大长度是否要抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line">    <span class="comment">// 最终解析的数据包是否带有换行符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> stripDelimiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if we&#x27;re discarding input because we&#x27;re already over maxLength.  */</span></span><br><span class="line">    <span class="comment">// 为true 说明当前解码过程为丢弃模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> discarding;</span><br><span class="line">    <span class="comment">// 丢了多少字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> discardedBytes;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的丢弃模式,我们会在源码中看到其中的含义, 我们看其decode() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Object decoded = decode(ctx, in);</span><br><span class="line">       <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">           out.add(decoded);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里的decode()  方法会调用重载的decode()  方法,并将解码后的内容放到out 集合中. 我们跟到 重载的decode()  方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 找这行的结尾</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> eol = findEndOfLine(buffer);</span><br><span class="line">        <span class="keyword">if</span> (!discarding) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ByteBuf frame;</span><br><span class="line">                <span class="comment">// 计算从换行到可读字符之间的长度</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = eol - buffer.readerIndex();</span><br><span class="line">                <span class="comment">// 拿到分割长度, 如果是\r\n 结尾, 分隔符长度为2</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">&#x27;\r&#x27;</span>? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果长度大于最大长度</span></span><br><span class="line">                <span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">                    <span class="comment">// 指向换行符之后的可读字符(这段数据完全丢弃)</span></span><br><span class="line">                    buffer.readerIndex(eol + delimLength);</span><br><span class="line">                    <span class="comment">// 传播异常事件</span></span><br><span class="line">                    fail(ctx, length);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果这次解析的数据是有效的</span></span><br><span class="line">                <span class="comment">// 分隔符是否算在完整的数据包里</span></span><br><span class="line">                <span class="comment">// true 为丢弃分隔符</span></span><br><span class="line">                <span class="keyword">if</span> (stripDelimiter) &#123;</span><br><span class="line">                    <span class="comment">// 截取有效长度</span></span><br><span class="line">                    frame = buffer.readRetainedSlice(length);</span><br><span class="line">                    <span class="comment">// 跳出分隔符的字节</span></span><br><span class="line">                    buffer.skipBytes(delimLength);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 包含分隔符</span></span><br><span class="line">                    frame = buffer.readRetainedSlice(length + delimLength);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> frame;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到分隔符(非丢弃模式)</span></span><br><span class="line">                <span class="comment">// 可读字节长度</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">                    <span class="comment">// 将当前长度标记为可丢弃的</span></span><br><span class="line">                    discardedBytes = length;</span><br><span class="line">                    <span class="comment">// 直接将读指针移动到写指针</span></span><br><span class="line">                    buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">                    <span class="comment">// 标记为丢弃模式</span></span><br><span class="line">                    discarding = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 超过最大长度抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                        fail(ctx, <span class="string">&quot;over &quot;</span> + discardedBytes);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有超过, 则直接返回.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 丢弃模式</span></span><br><span class="line">            <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到分隔符</span></span><br><span class="line">                <span class="comment">// 当前丢弃的字节(前面已经丢弃的+ 现在丢弃的位置 =写指针)</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = discardedBytes + eol - buffer.readerIndex();</span><br><span class="line">                <span class="comment">// 当前换行符长度为多少</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">&#x27;\r&#x27;</span>? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 读指针直接移到换行符 + 换行符的长度</span></span><br><span class="line">                buffer.readerIndex(eol + delimLength);</span><br><span class="line">                <span class="comment">// 当前丢弃的字节为0</span></span><br><span class="line">                discardedBytes = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 设置为未丢弃模式</span></span><br><span class="line">                discarding = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 丢弃完字节之后触发异常</span></span><br><span class="line">                <span class="keyword">if</span> (!failFast) &#123;</span><br><span class="line">                    fail(ctx, length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 累计已丢弃的字节个数 + 当前可读的长度</span></span><br><span class="line">                discardedBytes += buffer.readableBytes();</span><br><span class="line">                <span class="comment">// 移动</span></span><br><span class="line">                buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>final int eol = findEndOfLine(buffer)</code>   这里是找当前行的结尾的索引值, 也就 是\r\n 或者是\n：</p>
<p><img src="http://files.luyanan.com//img/20191012164153.png"></p>
<p>从上图中不难看出, 如果是以\n 结尾的, 返回的索引值是\n 的索引值, 如果是\n\r 结尾的, 返回的索引值是\r 的索引值.</p>
<p>我们看 <code>findEndOfLine(buffer)</code>   方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findEndOfLine</span><span class="params">(<span class="keyword">final</span> ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = buffer.forEachByte(ByteProcessor.FIND_LF);</span><br><span class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; buffer.getByte(i - <span class="number">1</span>) == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">           i--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码看到, 通过一个 forEachByte()  方法找到\n 这个字节, 如果找到了, 并且前面是\r, 则返回\r的索引值,否则返回\n的索引值. 回到重载的decode()   方法, <code>if (!discarding)</code> 判断是否为非丢弃模式, 所以进入if中, <code>if (eol &gt;= 0)</code>  如果找到了换行符， 我们看非丢弃模式下找到换行符的相关逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ByteBuf frame;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> length = eol - buffer.readerIndex();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">&#x27;\r&#x27;</span>? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">                   buffer.readerIndex(eol + delimLength);</span><br><span class="line">                   fail(ctx, length);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (stripDelimiter) &#123;</span><br><span class="line">                   frame = buffer.readRetainedSlice(length);</span><br><span class="line">                   buffer.skipBytes(delimLength);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   frame = buffer.readRetainedSlice(length + delimLength);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> frame;</span><br></pre></td></tr></table></figure>

<p>首先获取换行符到可读字节之间的长度, 然后拿到换行符的长度, 如果是\n结尾，那么长度是1, 如果是\r 结尾, 长度为2. <code>if (length &gt; maxLength)</code>  代表如果长度超过最大长度, 则直接通过 <code>buffer.readerIndex(eol + delimLength)</code> 这种方式, 将读指针指向换行符之后的字节,说明换行符之前的字节需要完全丢弃.</p>
<p><img src="http://files.luyanan.com//img/20191012170539.png"></p>
<p>丢弃之后通过fail 方法传播异常, 并返回null, 继续往下看, 走到下一步, 说明解析出来的数据长度没有超过最大长度, 说明是有效数据包. <code>if (stripDelimiter)</code> 表示是否要将分隔符放在完整的数据包里面, 如果是true, 则说明要丢弃分隔符. 然后截取有效长度, 并跳出分隔符长度, 将包含分隔符进行截取.</p>
<p>以上就是非丢弃模式下找到换行符的相关逻辑, 我们再看非丢弃模式下没有找到换行符的相关逻辑. 也就是非丢弃模式下, <code>if (eol &gt;= 0) </code> 中的else 块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">              <span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">                  discardedBytes = length;</span><br><span class="line">                  buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">                  discarding = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                      fail(ctx, <span class="string">&quot;over &quot;</span> + discardedBytes);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>final int length = buffer.readableBytes()</code>  获取所有的可读字节数, 然后判断可读字节数是否超过了最大值, 如果超过了最大值, 则属性 discardedBytes 标记为这个长度, 代表这段内容要进行丢弃.</p>
<p><img src="http://files.luyanan.com//img/20191012171722.png"></p>
<p><code>buffer.readerIndex(buffer.writerIndex())</code>  这里直接将读指针移动到写指针, 并且将discarding 设置为true, 就是丢弃模式.  如果可读字节没有超过最大长度, 则返回null, 表示什么都没有解析出来. 等着下次解析. 我们再看丢弃模式的处理逻辑, 也就是 <code>if (!discarding)</code> 中的else 块, 首先这里也分为两种情况, 根据<code>if (eol &gt;= 0)</code> 判断是否找到了分隔符, 我们首先来看找到分隔符的解码逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">              <span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">                  discardedBytes = length;</span><br><span class="line">                  buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">                  discarding = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                      fail(ctx, <span class="string">&quot;over &quot;</span> + discardedBytes);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>如果找到换行符, 则需要将换行符之前的数据全部丢弃掉.</p>
<p><img src="http://files.luyanan.com//img/20191012172402.png"></p>
<p><code>final int length = buffer.readableBytes()</code> 这里获取丢弃的字节总数, 也就是之前丢弃的字节数 + 现在需要丢弃的字节数. 然后计算换行符的长度, 如果是\n 则是1,\r\n 则是2. <code>buffer.readerIndex(buffer.writerIndex())</code> 这里将读指针移动到换行符之后的位置, 然后将discarding 设置为false, 表示当前是非丢弃状态.我们再来看丢弃模式未找到换行符的情况, 也就是丢弃模式下, <code>if (eol &gt;= 0)</code> 中的else块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">                    discardedBytes = length;</span><br><span class="line">                    buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">                    discarding = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                        fail(ctx, <span class="string">&quot;over &quot;</span> + discardedBytes);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>final int length = buffer.readableBytes()</code> 获取所有可读的字节数, 然后判断可读字节数是否超过了最大值, 如果超过最大值, 则属性discardedBytes 标记为这个程度, 代表这段内容要进行丢弃.</p>
<p><img src="http://files.luyanan.com//img/20191014093942.png"></p>
<p><code>buffer.readerIndex(buffer.writerIndex())</code>   这里直接将读指针移动到写指针, 并且将discarding 设置为true, 就是丢弃模式. 如果可读字节没有超过最大长度, 则返回null, 表示什么也没有解析出来,等着下次解析. 我们再看看丢弃模式的处理逻辑,也就是<code>if (!discarding)</code> 的else块, 首先这里也分为两种情况, 根据<code>if (eol &gt;= 0) </code>  判断是否找到了分隔符, 我们首先看找到分隔符的解码逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> length = discardedBytes + eol - buffer.readerIndex();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">&#x27;\r&#x27;</span>? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">               buffer.readerIndex(eol + delimLength);</span><br><span class="line">               discardedBytes = <span class="number">0</span>;</span><br><span class="line">               discarding = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (!failFast) &#123;</span><br><span class="line">                   fail(ctx, length);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>如果找到换行符, 则需要将换行符之前的数据全部丢弃掉.</p>
<p><img src="http://files.luyanan.com//img/20191014101505.png"></p>
<p><code>final int length = discardedBytes + eol - buffer.readerIndex()</code>  这里获取丢弃的字节总数, 也就是之前丢弃的字节数 + 现在丢弃的字节数. 然后计算换行符的长度, 如果是\n 则是 1, \r\n 就是 2。<code>buffer.readerIndex(eol + delimLength)</code> 这里将指针移动到换行符之后的位置, 然后将discarding 设置为false, 表示当前是非丢弃状态，我们再看丢弃模式下未找到换行符的情况, 也就是丢弃模式, <code>if (eol &gt;= 0)</code>  中的else 块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discardedBytes += buffer.readableBytes();</span><br><span class="line">              buffer.readerIndex(buffer.writerIndex());</span><br></pre></td></tr></table></figure>

<p>这里做的事情非常简单, 就是累计丢弃的字节数, 并将读指针移动到写指针, 也就是将数据全部丢弃. 最后在丢弃模式下, decode()   方法返回为null, 代表本次没有解析出任何数据, 以上就是行解析器的相关逻辑.</p>
<h3 id="3-DelimiterBasedFrameDecoder-分隔符解码器"><a href="#3-DelimiterBasedFrameDecoder-分隔符解码器" class="headerlink" title="3. DelimiterBasedFrameDecoder 分隔符解码器"></a>3. DelimiterBasedFrameDecoder 分隔符解码器</h3><p>DelimiterBasedFrameDecoder   分隔符解码器, 是按照指定分隔符进行解码的解码器, 通过分隔符, 可以将二进制流拆分成完整的数据包，回车换行解码器其实就是一种特殊的<strong>DelimiterBasedFrameDecoder</strong> 解码器.</p>
<p>分隔符解码器在实际工作中也有实际的应用, 在电信行业,很多简单的文本私有协议, 都是以特殊的分隔符作为消息结束的标识， 特殊是对于那些使用长连接的基于文本的私有协议.</p>
<p>分隔符的指定: 与大家的习惯不同, 分隔符并非以char 或者string 作为构造参数的, 而是ByteBuf,下面我们就结合实际例子给出它的用法。 假设消息是以”$_” 作为分隔符, 服务端或者客户端初始化ChannelPipeline 的代码示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"> ByteBuf delimter = Unpooled.copiedBuffer(<span class="string">&quot;$_&quot;</span>.getBytes());</span><br><span class="line"> pipeline.addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>, delimter));</span><br><span class="line"> pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br></pre></td></tr></table></figure>

<p>首先将 “$_”  转换为ByteBuf 对象, 作为参数构造器 DelimiterBasedFrameDecoder    , 将其添加到ChannelPepeline中, 然后依次添加到字符串解码器(通常用于文本解码)和用户handler, 请注意解码器和Handler 的添加顺序, 如果顺序颠倒, 会导致消息解码失败.</p>
<p>DelimiterBasedFrameDecoder    同样继承了ByteToMessageDecoder, 并重写了 decode()  方法, 我们来看其中的一个构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelimiterBasedFrameDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameLength, ByteBuf delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(maxFrameLength, <span class="keyword">true</span>, delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里参数 maxFrameLength 代表最长长度, delimiter 是个可变参数, 可以说可以支持多个分隔符进行解码,我们进入 decode()  方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Object decoded = decode(ctx, in);</span><br><span class="line">      <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">          out.add(decoded);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样同样调用了其重载的 decode()  并将其解析好的数据添加到集合list中, 其父类就可以遍历out, 并将内容传播.我们跟到重载 decode()  方法里面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 行处理器    </span></span><br><span class="line">    <span class="keyword">if</span> (lineBasedDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lineBasedDecoder.decode(ctx, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Try all delimiters and choose the delimiter which yields the shortest frame.</span></span><br><span class="line">        <span class="keyword">int</span> minFrameLength = Integer.MAX_VALUE;</span><br><span class="line">        ByteBuf minDelim = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 找到最小长度的分隔符(2)</span></span><br><span class="line">        <span class="keyword">for</span> (ByteBuf delim: delimiters) &#123;</span><br><span class="line">            <span class="keyword">int</span> frameLength = indexOf(buffer, delim);</span><br><span class="line">            <span class="keyword">if</span> (frameLength &gt;= <span class="number">0</span> &amp;&amp; frameLength &lt; minFrameLength) &#123;</span><br><span class="line">                minFrameLength = frameLength;</span><br><span class="line">                minDelim = delim;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码(3)</span></span><br><span class="line">    <span class="comment">// 已经找到分隔符</span></span><br><span class="line">        <span class="keyword">if</span> (minDelim != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minDelimLength = minDelim.capacity();</span><br><span class="line">            ByteBuf frame;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前分隔符处于丢弃模式</span></span><br><span class="line">            <span class="keyword">if</span> (discardingTooLongFrame) &#123;</span><br><span class="line">                <span class="comment">// We&#x27;ve just finished discarding a very large frame.</span></span><br><span class="line">                <span class="comment">// Go back to the initial state.</span></span><br><span class="line">                <span class="comment">// 首先设置为非丢弃模式</span></span><br><span class="line">                discardingTooLongFrame = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 丢弃</span></span><br><span class="line">                buffer.skipBytes(minFrameLength + minDelimLength);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> tooLongFrameLength = <span class="keyword">this</span>.tooLongFrameLength;</span><br><span class="line">                <span class="keyword">this</span>.tooLongFrameLength = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!failFast) &#123;</span><br><span class="line">                    fail(tooLongFrameLength);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处于非丢弃模式</span></span><br><span class="line">            <span class="comment">// 当前找到的数据包, 大于允许的数据包</span></span><br><span class="line">            <span class="keyword">if</span> (minFrameLength &gt; maxFrameLength) &#123;</span><br><span class="line">                <span class="comment">// Discard read frame.</span></span><br><span class="line">                <span class="comment">// 当前数据包 + 最小分隔符长度 全部丢弃</span></span><br><span class="line">                buffer.skipBytes(minFrameLength + minDelimLength);</span><br><span class="line">                <span class="comment">// 传递异常信息</span></span><br><span class="line">                fail(minFrameLength);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是正常的长度</span></span><br><span class="line">            <span class="comment">// 解析出来的数据包是否忽略分隔符</span></span><br><span class="line">            <span class="keyword">if</span> (stripDelimiter) &#123;</span><br><span class="line">                <span class="comment">// 如果不包含分隔符</span></span><br><span class="line">                <span class="comment">// 截取</span></span><br><span class="line">                frame = buffer.readRetainedSlice(minFrameLength);</span><br><span class="line">                <span class="comment">// 跳过分隔符</span></span><br><span class="line">                buffer.skipBytes(minDelimLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 截取包含分隔符的长度</span></span><br><span class="line">                frame = buffer.readRetainedSlice(minFrameLength + minDelimLength);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> frame;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到分隔符</span></span><br><span class="line">            <span class="comment">// 非丢弃模式</span></span><br><span class="line">            <span class="keyword">if</span> (!discardingTooLongFrame) &#123;</span><br><span class="line">                <span class="comment">// 可读字节大于允许的解析出来的长度</span></span><br><span class="line">                <span class="keyword">if</span> (buffer.readableBytes() &gt; maxFrameLength) &#123;</span><br><span class="line">                    <span class="comment">// Discard the content of the buffer until a delimiter is found.</span></span><br><span class="line">                    <span class="comment">// 将这个长度记下</span></span><br><span class="line">                    tooLongFrameLength = buffer.readableBytes();</span><br><span class="line">                    <span class="comment">// 跳过这段长度</span></span><br><span class="line">                    buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">                    <span class="comment">// 标记当前处于丢弃状态</span></span><br><span class="line">                    discardingTooLongFrame = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                        fail(tooLongFrameLength);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Still discarding the buffer since a delimiter is not found.</span></span><br><span class="line">                tooLongFrameLength += buffer.readableBytes();</span><br><span class="line">                buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的方法也比较长, 这里通过拆分进行剖析:</p>
<ol>
<li>行处理器</li>
<li>找到最小长度分隔符</li>
<li>解码</li>
</ol>
<p>首先来看第一步行处理器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lineBasedDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lineBasedDecoder.decode(ctx, buffer);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断成员变量 lineBasedDecoder 是否为空,如果不为空则直接调用lineBasedDecoder 的decode 方法进行解码, lineBasedDecoder 实际上 LineBasedFrameDecoder 解码器. 这个成员变量, 会在分隔符是\n 和\r\n 的 时候进行初始化, 我们看初始化该属性的构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelimiterBasedFrameDecoder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> maxFrameLength, <span class="keyword">boolean</span> stripDelimiter, <span class="keyword">boolean</span> failFast, ByteBuf... delimiters)</span> </span>&#123;</span><br><span class="line">        validateMaxFrameLength(maxFrameLength);</span><br><span class="line">        <span class="keyword">if</span> (delimiters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;delimiters&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delimiters.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;empty delimiters&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果是基于行的分割</span></span><br><span class="line">        <span class="keyword">if</span> (isLineBased(delimiters) &amp;&amp; !isSubclass()) &#123;</span><br><span class="line">            <span class="comment">// 初始化行 处理器</span></span><br><span class="line">            lineBasedDecoder = <span class="keyword">new</span> LineBasedFrameDecoder(maxFrameLength, stripDelimiter, failFast);</span><br><span class="line">            <span class="keyword">this</span>.delimiters = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.delimiters = <span class="keyword">new</span> ByteBuf[delimiters.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delimiters.length; i ++) &#123;</span><br><span class="line">                ByteBuf d = delimiters[i];</span><br><span class="line">                validateDelimiter(d);</span><br><span class="line">                <span class="keyword">this</span>.delimiters[i] = d.slice(d.readerIndex(), d.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            lineBasedDecoder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxFrameLength = maxFrameLength;</span><br><span class="line">        <span class="keyword">this</span>.stripDelimiter = stripDelimiter;</span><br><span class="line">        <span class="keyword">this</span>.failFast = failFast;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>这里 <code>isLineBased(delimiters)</code>  会判断是否是基于行的分割, 跟到isLineBased(delimiters) 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLineBased</span><span class="params">(<span class="keyword">final</span> ByteBuf[] delimiters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分隔符长度不为2</span></span><br><span class="line">       <span class="keyword">if</span> (delimiters.length != <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 拿到第一个分隔符</span></span><br><span class="line">       ByteBuf a = delimiters[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 拿到第二个分隔符</span></span><br><span class="line">       ByteBuf b = delimiters[<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (a.capacity() &lt; b.capacity()) &#123;</span><br><span class="line">           a = delimiters[<span class="number">1</span>];</span><br><span class="line">           b = delimiters[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 确保 a是/r/n 分割成. 确保b是/n分隔符</span></span><br><span class="line">       <span class="keyword">return</span> a.capacity() == <span class="number">2</span> &amp;&amp; b.capacity() == <span class="number">1</span></span><br><span class="line">               &amp;&amp; a.getByte(<span class="number">0</span>) == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; a.getByte(<span class="number">1</span>) == <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">               &amp;&amp; b.getByte(<span class="number">0</span>) == <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断长度等于2, 直接返回false. 然后那字额第一个分隔符a 和第二个分隔符b, 然后判断a 的第一个分隔符是不是\r,a 的第二个分隔符是不是\n, b 的第一个分隔符是不是\n，如果都为true, 则条件成立,我们回到decode() 方法中, 看第二步, 找到最小长度的分隔符, 这里最小长度的分隔符, 意思就是从读指针开始, 找到最近的分隔符:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ByteBuf delim: delimiters) &#123;</span><br><span class="line">       <span class="keyword">int</span> frameLength = indexOf(buffer, delim);</span><br><span class="line">       <span class="keyword">if</span> (frameLength &gt;= <span class="number">0</span> &amp;&amp; frameLength &lt; minFrameLength) &#123;</span><br><span class="line">           minFrameLength = frameLength;</span><br><span class="line">           minDelim = delim;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历所有的分隔符, 然后找到每个分隔符到读指针到数据包长度, 然后通过if 判断, 找到长度最小的数据包的长度, 然后保存当前数据包的分隔符, 如下图:</p>
<p><img src="http://files.luyanan.com//img/20191015113055.png"></p>
<p>这里假设A 和B 同为分隔符, A 分隔符到读指针的长度小于B 分隔符到读指针的长度, 这里会找到最小的分隔符A , 分隔符的最小长度, 就是 readIndex 到A 的长度, 我们继续看第三步, 解码. <code>if (minDelim != null)</code>     表示已经找到最小长度分隔符, 我们继续看if 块中的逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minDelimLength = minDelim.capacity();</span><br><span class="line">          ByteBuf frame;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (discardingTooLongFrame) &#123;</span><br><span class="line">              <span class="comment">// We&#x27;ve just finished discarding a very large frame.</span></span><br><span class="line">              <span class="comment">// Go back to the initial state.</span></span><br><span class="line">              discardingTooLongFrame = <span class="keyword">false</span>;</span><br><span class="line">              buffer.skipBytes(minFrameLength + minDelimLength);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> tooLongFrameLength = <span class="keyword">this</span>.tooLongFrameLength;</span><br><span class="line">              <span class="keyword">this</span>.tooLongFrameLength = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (!failFast) &#123;</span><br><span class="line">                  fail(tooLongFrameLength);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (minFrameLength &gt; maxFrameLength) &#123;</span><br><span class="line">              <span class="comment">// Discard read frame.</span></span><br><span class="line">              buffer.skipBytes(minFrameLength + minDelimLength);</span><br><span class="line">              fail(minFrameLength);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (stripDelimiter) &#123;</span><br><span class="line">              frame = buffer.readRetainedSlice(minFrameLength);</span><br><span class="line">              buffer.skipBytes(minDelimLength);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              frame = buffer.readRetainedSlice(minFrameLength + minDelimLength);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> frame;</span><br></pre></td></tr></table></figure>

<p><code>if (discardingTooLongFrame)</code>   表示当前是否处于非丢弃模式, 如果是丢弃模式, 则进入if 块, 因为第一个不是丢弃模式, 所这里先分析if 块后面的逻辑, <code>if (minFrameLength &gt; maxFrameLength)</code>   这里是判断当前找到的数据包的长度大于最大长度, 这里的最大长度使我们创建解码器的时候设置的, 如果超过了最大长度, 就通过<code>buffer.skipBytes(minFrameLength + minDelimLength)</code>   方法, 跳过数据包 + 分隔符的长度, 也就是将这部分数据进行完全丢弃, 继续往下看,如果长度不超过最大允许长度, 就通过<code>if (stripDelimiter)</code>  判断解析出来的数据包是否包含分隔符, 如果不包含分隔符， 则截取数据包的长度,跳过分隔符. 我们回头看<code>if (discardingTooLongFrame)</code>  中的if 块中的逻辑, 也就是丢弃模式. 首先将    discardingTooLongFrame 设置为false, 标记为非丢弃模式. 然后通过<code>buffer.skipBytes(minFrameLength + minDelimLength)</code> 将数据包 + 分隔符长度的字节数跳过, 也就是进行丢弃. 之后在进行抛出异常. 分析完成了找到分隔符之后的丢弃模式和非丢弃模式之后的逻辑处理. 我们在分析没找到分隔符的逻辑处理, 也就是<code>if (minDelim != null) </code>  中的else 块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!discardingTooLongFrame) &#123;</span><br><span class="line">               <span class="keyword">if</span> (buffer.readableBytes() &gt; maxFrameLength) &#123;</span><br><span class="line">                   <span class="comment">// Discard the content of the buffer until a delimiter is found.</span></span><br><span class="line">                   tooLongFrameLength = buffer.readableBytes();</span><br><span class="line">                   buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">                   discardingTooLongFrame = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                       fail(tooLongFrameLength);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Still discarding the buffer since a delimiter is not found.</span></span><br><span class="line">               tooLongFrameLength += buffer.readableBytes();</span><br><span class="line">               buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>if (!discardingTooLongFrame)</code>  判断是否为丢弃模式, 如果是, 则进入if 块. 在if 块中, 首先通过<code>if (buffer.readableBytes() &gt; maxFrameLength)</code> 判断当前可读字节是否大于最大允许的长度, 如果大于最大允许的长度, 则将可读字节数设置到tooLongFrameLength 的属性中, 代表丢弃的字节数 , 然后通过 <code>buffer.skipBytes(buffer.readableBytes())</code> 将累计器中的所有的可读的字节进行丢弃, 最后将discardingTooLongFrame 设置为true, 也就是丢弃模式, 之后抛出异常. 如果<code>if (!discardingTooLongFrame)</code> 为false , 也就是当前处于丢弃模式, 则追加tooLongFrameLength 也就是丢弃的字节数的长度, 并通过<code>buffer.skipBytes(buffer.readableBytes())</code> 将所有的字节进行丢弃. 以上就是分隔符解码的相关逻辑.</p>
<h3 id="4-FixedLengthFrameDecoder-固定长度解码器"><a href="#4-FixedLengthFrameDecoder-固定长度解码器" class="headerlink" title="4. FixedLengthFrameDecoder 固定长度解码器"></a>4. FixedLengthFrameDecoder 固定长度解码器</h3><p>FixedLengthFrameDecoder  固定长度解码器, 他能够按照指定的长度对消息进行自动解码，开发者不需要考虑TCP 的粘包/拆包 等问题, 非常实用.</p>
<p>对于定长长度, 如果消息实际长度小于定长, 则往往会进行补位操作,它在一定程度上导致了空间和资源的浪费。 但是它的优点也非常明显， 编解码比较简单, 因此在实际项目中有一定的应用场景.</p>
<p>利用FixedLengthFrameDecoder 解码器, 无论一次接收到多少数据报, 它都会按照构造函数中的设置的固定长度进行解码，如果是半包消息, FixedLengthFrameDecoder 会缓存半包消息并等到下个包到达后进行拼包, 直到读取完第一个完整的包. 假设单条消息的长度为20字节，使用FixedLengthFrameDecoder 解码器的效果如下：</p>
<p><img src="http://files.luyanan.com//img/20191015164216.png"></p>
<p>来看其类的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> frameLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frameLength the length of the frame</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedLengthFrameDecoder</span><span class="params">(<span class="keyword">int</span> frameLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (frameLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;frameLength must be a positive integer: &quot;</span> + frameLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存当前 frameLength</span></span><br><span class="line">        <span class="keyword">this</span>.frameLength = frameLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ByteBuf 去解码, 解码到对象后添加到out 上</span></span><br><span class="line">        Object decoded = decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将解析到的ByteBuf 添加到对象里面</span></span><br><span class="line">            out.add(decoded);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a frame out of the &#123;<span class="doctag">@link</span> ByteBuf&#125; and return it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   ctx             the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; which this &#123;<span class="doctag">@link</span> ByteToMessageDecoder&#125; belongs to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   in              the &#123;<span class="doctag">@link</span> ByteBuf&#125; from which to read data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  frame           the &#123;<span class="doctag">@link</span> ByteBuf&#125; which represent the frame or &#123;<span class="doctag">@code</span> null&#125; if no frame could</span></span><br><span class="line"><span class="comment">     *                          be created.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@SuppressWarnings(&quot;UnusedParameters&quot;)</span> ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 字节是否小于这个固定长度</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前累计器中截取这个长度的数值</span></span><br><span class="line">            <span class="keyword">return</span> in.readRetainedSlice(frameLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到FixedLengthFrameDecoder 类继承了ByteToMessageDecoder , 重写了 decode() 方法,这个类只有一个属性叫    frameLength, 并在构造器中初始化了这个属性。 再看decode() 方法, 在 decode() 方法中又调用了自身另一个重载的 decode() 方法进行解析, 解析出来后的数据放在集合out 中. 再看重载的decode()方法, 重载的decode() 方法中首先判断垒机器的字节数是否小于固定长度, 如果小于固定长度则返回null, 代表不是一个完整的数据包. 直接返回null. 如果大于等于固定长度, 则直接从累加器中截取这个长度的数值<code>in.readRetainedSlice(frameLength)</code>  会返回一个新的截取后的ByteBuf, 并将原来的累计器读指针后移frameLength 字节. 如果累加器中还有数据, 则会通过ByteToMessageDecoder 中的callDecode() 方法里while 循环的方式, 继续进行解码。 这样, 就是实现了固定长度的解码工作.</p>
<h3 id="5-LengthFieldBasedFrameDecoder-通用解码器"><a href="#5-LengthFieldBasedFrameDecoder-通用解码器" class="headerlink" title="5. LengthFieldBasedFrameDecoder 通用解码器"></a>5. LengthFieldBasedFrameDecoder 通用解码器</h3><p>了解TCP 通信机制的都知道TCP底层的粘包和拆包, 当我们在接收消息的时候, 显示不能认为读取到的报文就是个整包消息, 热别是对于采用非阻塞IO 和长连接通信的程序.</p>
<p>如何区分一个整包消息, 通常有如下4种做法:</p>
<ol>
<li>规定长度: 例如每120个字节代表一个整包消息, 不足的前面补位.解码器在处理这类定长消息的时候比较简单, 每次读取到指定的长度的字节后再进行解码。</li>
<li>通过回车换行符区分消息,例如HTTP协议. 这类区分消息的方式多用于文本协议.</li>
<li>通过特定的分隔符区分整包消息</li>
<li>通过在协议头/消息头 中设置长度字段来标识整包消息.</li>
</ol>
<p>前三种解码器之前我们已经做了详细介绍, 下面让我们来一起学习一下最后的一种通用解码器 LengthFieldBasedFrameDecoder  .</p>
<p>大多数的协议(私有/公有) ,协议头中会携带长度字段, 用于标识消息体或者整包消息的长度， 例如SMPP、HTTP协议. 由于基于长度解码需求的通用性, 以及为了降低用户的协议开发难度, Netty 提供了LengthFieldBasedFrameDecoder , 自动屏蔽了TCP底层的粘包/拆包问题, 只需要传入正确的参数, 即可轻松解决”读半包”问题.</p>
<p>下面我们看看如何通过参数组合的不同来实现不同的”半包”读取策略. 第一种常用的方式是消息的第一个字段是长度字段, 后面是消息体, 消息头中只包含一个长度字段.它的消息结构定义如图所示：</p>
<p><img src="http://files.luyanan.com//img/20191015173127.png"></p>
<p>使用以下参数组合进行解码:</p>
<ol>
<li>lengthFieldOffset = 0</li>
<li>lengthFieldLength  = 2</li>
<li>lengthAdjustment = 0</li>
<li>initialBytesToStrip = 0</li>
</ol>
<p>解码后的字段缓冲区内容如图所示:</p>
<p><img src="http://files.luyanan.com//img/20191015173401.png"></p>
<p>通过 ByteBuf.readableBytes() 方法我们可以获取当前消息的长度, 所以解码后的字节缓冲区可以不携带长度字段, 由于长度字段在起始位置并且长度为2, 所以将initialBytesToStrip 设置为2, 参数组合修改为:</p>
<ol>
<li> lengthFieldOffset = 0</li>
<li>lengthFieldLength = 2</li>
<li>lengthAdjustment = 0</li>
<li>initialBytesToStrip = 2</li>
</ol>
<p>解码后的字节缓冲区内容如下图所示:</p>
<p><img src="http://files.luyanan.com//img/20191015175718.png"><img src="http://files.luyanan.com//img/20191015175730.png"></p>
<p>解码后的字节缓冲区丢弃了长度字段, 仅仅包含消息体,对于大多数的协议, 解码之后消息长度没有用户,因此可以丢弃. 在大多数的应用场景中，长度字段仅用来标识消息体的长度,这类协议通常由消息长度字段 + 消息体组成, 如上图所示的几个例子. 但是, 对于某些协议,长度字段还包含了消息头的长度。 在这种应用场景中, 往往需要使用lengthAdjustment  进行修正. 由于整个消息(包含消息头) 的长度往往大于消息体的长度, 所以lengthAdjustment  为负数 . 下图展示了通过指定的lengthAdjustment  字段来包含消息头的长度.</p>
<ol>
<li>lengthFieldOffset = 0</li>
<li>lengthFieldLength = 2</li>
<li>lengthAdjustment = -2</li>
<li>initialBytesToStrip = 0</li>
</ol>
<p>解码之前的码流:</p>
<p><img src="http://files.luyanan.com//img/20191015211919.png"></p>
<p>解码之后的码流:</p>
<p><img src="http://files.luyanan.com//img/20191015211943.png"></p>
<p>由于协议种类繁多, 并不是所有的协议都将长度字段放在消息头的首位, 当标识消息长度的字段位于消息头的中间或者尾部的时候, 需要使用lengthFieldOffset 字段进行标识, 下面的参数组合给出来了如何解决消息长度字段不在首位的问题:</p>
<ol>
<li>lengthFieldOffset = 2</li>
<li>lengthFieldLength = 3</li>
<li>lengthAdjustment = 0</li>
<li>initialBytesToStrip = 0</li>
</ol>
<p>lengthFieldOffset 表示长度字段在消息头中偏移的字节数, lengthFieldLength 表示长度字段自身的长度,解码效果如下:</p>
<p>解码之前:</p>
<p><img src="http://files.luyanan.com//img/20191015212511.png"></p>
<p>解码之后:</p>
<p><img src="http://files.luyanan.com//img/20191015212511.png"></p>
<p>由于消息头1的长度为2, 所以长度字段的偏移量为2 . 消息长度字段Length 为3, 所以lengthFieldLength 值为3. 由于长度字段仅仅标识消息体的长度, 所以lengthAdjustment 和initialBytesToStrip 都为0</p>
<p>最后一种场景是长度字段夹在两个消息头之间或者长度字段位于消息头的中间,前后都有其他消息头字段, 在这种场景下如果想忽略长度字段以及其前面的其他消息头字段， 则可以通过initialBytesToStrip 参数来跳过要忽略的字节长度, 它的组合配置示意如下:</p>
<ol>
<li><strong>lengthFieldOffset</strong> = 1</li>
<li>lengthFieldLength = 2</li>
<li>lengthAdjustment = 1</li>
<li>initialBytesToStrip = 3</li>
</ol>
<p>解码之前的码流(16字节)：</p>
<p><img src="http://files.luyanan.com//img/20191015213053.png"></p>
<p>解码之后的码流(13字节):</p>
<p><img src="http://files.luyanan.com//img/20191015213115.png"></p>
<p>由于HDR1的长度为1, 所以字段长度的偏移量lengthFieldOffset 为1 , 长度字段为2个字节, 所以lengthFieldLength 为2. 由于字段长度为消息体的长度, 解码后如果携带消息头中的字段, 则需要使用lengthAdjustment 进行调整, 此处它的值为1 , 代表的是HDR2的长度, 最后由于解码后的长度要忽略长度字段和HDR1部分, 所以lengthAdjustment 为3. 解码后的结果为13个字节, HDR1和Length 字段都被忽略.</p>
<p>事实上, 通过4个参数的组合， 可以达到不同的解码效果, 用户在使用过程中可以通过业务的实际情况灵活的进行调整.</p>
<p>由于TCP存在粘包和组包问题, 所以通常i情况下需要用户自己处理半包问题，利用LengthFieldBasedFrameDecoder 解码器可以自动解决半包问题， 它的习惯用户如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">&quot;frameDecoder&quot;</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65536</span>,<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在pipeline 中增加 LengthFieldBasedFrameDecoder 解码器, 指定正确的参数组合， 它可以将Netty的ByteBuf 解码成整包消息, 后面的用户解码器拿到的就是完整的包, 按照正常的逻辑进行解码就可以. 不再需要考虑额外的 “读半包”问题, 降低了用户的开发难度.</p>
<h2 id="4-Netty-编码器原理和数据输出"><a href="#4-Netty-编码器原理和数据输出" class="headerlink" title="4. Netty 编码器原理和数据输出"></a>4. Netty 编码器原理和数据输出</h2><p>Netty 默认提供了丰富的编解码框架供用户集成使用, 我们只对较常用的Java 序列化编码器进行分析, 其他的编码器实现大同小异. 其实编码器和解码器比较类似, 编码器也是一个handler, 并且属于outbounfHandle , 就是将准备发出来的数据进行拦截, 拦截之后进行相应的处理之后再进行再次发送处理, 如果理解了解码器， 那么编码器的相关内容理解器来就比较容易了. </p>
<h3 id="1-writeAndFlush-事件传播"><a href="#1-writeAndFlush-事件传播" class="headerlink" title="1. writeAndFlush 事件传播"></a>1. writeAndFlush 事件传播</h3><p>在学习pipeline 的时候, 学到了write事件的传播过程, 但是在实际使用过程中, 我们通常不会调用channel 的write方法, 因为该方法只会写入到发送数据的缓存中, 并不会直接写入到channel, 如果想写入到channel , 还需要调用flush方法. 在实际使用过程中, 我们用的更多的还是writeAndFlush 方法，这方法既能将数据写入到发送缓冲区中, 还能刷新到channe中, 我们看一个简单的使用场景:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.channel().writeAndFlush(<span class="string">&quot;test data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个地方大家肯定不陌生， 通过这种方式, 可以将数据发送到channel中, 对方可以收到响应. 简单回顾一下跟到 writeAndFlush  方法中, 首先会走到AbstractChannel 的writeAndFlush  方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pipeline.writeAndFlush(msg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟到DefaultChannelPipeline 的writeAndFlush(）方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tail.writeAndFlush(msg, promise);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到writeAndFlush 是从tail 节点开始传播的, 继续跟到AbstractChannelHandlerContext 的 writeAndFlush()中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> writeAndFlush(msg, newPromise());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="comment">// cancelled</span></span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(msg, <span class="keyword">true</span>, promise);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进write() 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">        <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AbstractWriteTask task;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            safeExecute(executor, task, promise, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑是找到下一个节点, 因为 writeAndFlush  是从tail 节点开始的, 并且是outBound 的事件, 所以这里会找到tail、节点的上一个 outBoundHandler, 有可能是编码器, 也有可能是我们自己业务处理的handler. <code>if (executor.inEventLoop())</code>  判断是否为eventLoop 线程, 如果不是, 则封装成task 通过NioEventLoop 异步执行, 我们这里按照eventLoop线程分析。 首先, 这里通过flush 判断是否调用了flush, 这里显然是true, 因为我们调用的方法是writeAndFlush (), 我们跟到invokeWriteAndFlush中:、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">           invokeWrite0(msg, promise);</span><br><span class="line">           invokeFlush0();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           writeAndFlush(msg, promise);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>这里就真相大白了, 其实在writeAndFlush  () 方法中, 首先调用write , write 完成之后会再调用flush方法进行刷新,首先跟到invokeWrite0()  方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          notifyOutboundHandlerException(t, promise);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法就是调用当前handler 的write 方法，如果当前handler 中write 方法是继续往下传播, 会在继续传播写事件, 直到传播到head节点，最后会走到HeadContext 的write 方法， 跟到HeadContext 的write 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           unsafe.write(msg, promise);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这里通过当前channel 的unsafe方法将当前消息写到缓存中, 回到 invokeWriteAndFlush() 方法中:、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">           invokeWrite0(msg, promise);</span><br><span class="line">           invokeFlush0();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           writeAndFlush(msg, promise);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p> 我们再看invokeFlush0()  方法：、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          notifyHandlerException(t);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>同样这里会调用当前handler的flush方法, 如果当前的handler的flush方法是继续传播flush事件, 则flush事件会继续往下传播, 直到之后调用head节点的flush事件. 跟到HeadContext 的flush方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          unsafe.flush();</span><br><span class="line">      &#125;	</span><br></pre></td></tr></table></figure>

<p>这里同样会通过当前channel 的unsafe对象通过调用flush方法将缓存的数据刷新到channel中。 以上就是writeAndFlush 的相关逻辑.</p>
<h3 id="2-MessageToByteEncoder-抽象编码器"><a href="#2-MessageToByteEncoder-抽象编码器" class="headerlink" title="2. MessageToByteEncoder 抽象编码器"></a>2. MessageToByteEncoder 抽象编码器</h3><p>同解码器一样, 编码器中也有一个抽象类MessageToByteEncoder,其中定义了编码器的骨架方法, 具体编码逻辑交给子类实现,解码器同样有个handler, 将写入的数据进行截取处理. 我们将学习pipelie的时候知道，写数据的时候会传递write 事件, 传递过程中会调用handler 的write方法, 所以编码器可以重写write方法, 将数据编码成二进制字节流然后再传递write事件, 首先来看MessageToByteEncoder 的类声明: MessageToByteEncoder 负责将POJO 对象编码成ByteBuf, 用户的编码器继承MessageToByteEncoder, 实现<code>void encode(ChannelHandlerContext ctx, I msg, ByteBuf out)</code> 接口, 示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现原理如下: 调用write操作的时候，首先判断当前编码器是否支持需要发送的消息，如果不支持则直接透传, 如果支持则判断缓冲区的类型, 对于直接内存分配ioBuffer（堆外内存），对于堆内存通过headBuffer 方法分配, 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               I cast = (I) msg;</span><br><span class="line">               buf = allocateBuffer(ctx, cast, preferDirect);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   encode(ctx, cast, buf);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   ReferenceCountUtil.release(cast);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                   ctx.write(buf, promise);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   buf.release();</span><br><span class="line">                   ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="line">               &#125;</span><br><span class="line">               buf = <span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ctx.write(msg, promise);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (EncoderException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">               buf.release();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>编码使用的缓冲区分配完成后, 调用encode()  抽象方法进行编码, 它的子类负责具体实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>编码完成后, 调用<code>ReferenceCountUtil</code> 的release(cast) 方法释放编码对象msg, 对编码后的ByteBuf 进行以下判断: </p>
<ol>
<li> 如果缓冲区包含可发送的字节，则调用ChannelHandlerContext 的write方法发送ByteBuf. </li>
<li>如果缓冲区中没有包含可写的字节, 则需要释放编码后的ByteBuf, 写入一个空的ByteBuf 到ChannelHandlerContext 中.</li>
</ol>
<p>发送操作完成后, 在方法退出之前释放编码缓冲区中的ByteBuf 对象. </p>
<h3 id="3-写入Buffer-队列"><a href="#3-写入Buffer-队列" class="headerlink" title="3. 写入Buffer 队列"></a>3. 写入Buffer 队列</h3><p>我们知道， writeAndFlush 方法其实最终会调用到write和flush方法， write方法最终会传递到head节点，调用HeadContext 的write方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         unsafe.write(msg, promise);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>这里通过unsafe 的write方法, 将消息写入到缓存中, 我们跟到AbstractUnsafe 的write方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">           assertEventLoop();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 负责缓冲进来的ByteBuf</span></span><br><span class="line">           ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">           <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class="line">               <span class="comment">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class="line">               <span class="comment">// will be done in flush0()</span></span><br><span class="line">               <span class="comment">// See https://github.com/netty/netty/issues/2362</span></span><br><span class="line">               safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">               <span class="comment">// release message now to prevent resource-leak</span></span><br><span class="line">               ReferenceCountUtil.release(msg);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> size;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 非堆外内存转换为堆外内存</span></span><br><span class="line">               msg = filterOutboundMessage(msg);</span><br><span class="line">               size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">               <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   size = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               safeSetFailure(promise, t);</span><br><span class="line">               ReferenceCountUtil.release(msg);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 插入写队列</span></span><br><span class="line">           outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先看<code>ChannelOutboundBuffer outboundBuffer = this.outboundBuffer</code>  ChannelOutboundBuffer 的功能就是缓存写入的ByteBuf, 我们继续看 try块中的  <code>msg = filterOutboundMessage(msg)</code> , 这步的意思就是将非堆外内存转换为堆内内存, filterOutboundMessage 方法最终会调用到AbstractNioByteChannel的 filterOutboundMessage方法 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">filterOutboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">           ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">           <span class="keyword">if</span> (buf.isDirect()) &#123;</span><br><span class="line">               <span class="keyword">return</span> msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> newDirectBuffer(buf);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</span><br><span class="line">           <span class="keyword">return</span> msg;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">               <span class="string">&quot;unsupported message type: &quot;</span> + StringUtil.simpleClassName(msg) + EXPECTED_TYPES);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断msg 是否为ByteBuf 对象, 如果是, 判断是否为堆外内存,  如果是堆外内存, 则直接返回. 否则通过<code>return newDirectBuffer(buf)</code>  这种方式转化为堆外内存。 回到write 方法中, <code>outboundBuffer.addMessage(msg, size, promise)</code> 将已经转换为堆外内存的msg 插入到写队列, 我们跟到addMessage()  方法当中,这是 ChannelOutboundBuffer 中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        Entry entry = Entry.newInstance(msg, size, total(msg), promise);</span><br><span class="line">        <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">            tailEntry = entry;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry tail = tailEntry;</span><br><span class="line">            tail.next = entry;</span><br><span class="line">            tailEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            unflushedEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment pending bytes after adding message to the unflushed arrays.</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/1619</span></span><br><span class="line">        incrementPendingOutboundBytes(size, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>Entry entry = Entry.newInstance(msg, size, total(msg), promise)</code> 的方式将msg 封装成entry, 然后通过调整tailEntry, flushedEntry, unflushedEntry 这三个指针, 完成entry 的添加。 这三个指针均为ChannelOutboundBuffer  的成员变量:</p>
<ul>
<li>flushedEntry 指向第一个被flush 的entry</li>
<li>unflushedEntry 指向第一个未被flush 的entry</li>
</ul>
<p>也就是说, 从 flushedEntry 到unflushedEntry 之前的entry, 都是被已经被flush的entry. tailEntry 指向最后一个entry, 也就是从unflushedEntry 到tailEntry 之间的entry 都是没flush 的entry. 我们回到代码中, 创建了entry 之后首先判断尾指针是否为空, 在第一个添加的时候, 均是空, 所以会将flushedEntry 设置为null, 并且将尾指针设置为当前创建的entry, 最后判断unflushedEntry  是否为空, 如果第一个添加这里为空, 所以这里将unflushedEntry  设置为新创建的entry, 第一次添加如下图所示: </p>
<p><img src="http://files.luyanan.com//img/20191016115234.png"></p>
<p>如果不是第一次调用write 方法, 则会进入<code>if (tailEntry == null)</code> 中的else 块</p>
<ul>
<li>Entry tail = tailEntry 这里tail 就是当前尾节点</li>
<li>tail.next = entry   代表尾节点的下一个节点指向新的创建的entry</li>
<li>tailEntry = entry 将尾节点也指向entry</li>
</ul>
<p>这样就完成了添加操作, 其实就是将新创建的节点追加到原来的尾节点之后, 第二次添加<code>if (unflushedEntry == null)</code> 会返回false, 所以不会进入if 块. 第二次添加之后指针的指向情况如下图所示: </p>
<p><img src="http://files.luyanan.com//img/20191016145712.png"></p>
<p>以后每次调用write, 如果没有调用flush的话都会在尾节点之后进行追加. 回到代码中, 看这一步<code>incrementPendingOutboundBytes(size, false);</code>   这步时统计当前有多少字节需要被写出, 我们跟到这个方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, size);</span><br><span class="line">      <span class="keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;</span><br><span class="line">          setUnwritable(invokeLater);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>看这一步 <code>long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);</code>    TOTAL_PENDING_SIZE_UPDATER 表示当前缓冲区还有多少戴写的字节， addAndGet 就是将当前的ByteBuf 的长度进行累加， 累加到newWriteBufferSize 中, 在继续看判断<code>if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) </code> 表示写buffer 的高水位值, 默认为64 KB,也就是说些buffer 的最大长度不能超过64KB,如果超过了64KB， 则会调用<code>setUnwritable(invokeLater);</code> 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnwritable</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue | <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (oldValue == <span class="number">0</span> &amp;&amp; newValue != <span class="number">0</span>) &#123;</span><br><span class="line">                  fireChannelWritabilityChanged(invokeLater);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里通过自旋和cas操作, 传播一个ChannelWritabilityChanged 事件, 最终会调用 handler 的ChannelWritabilityChanged 方法进行处理, 以上就是写buffer 的相关逻辑. </p>
<h3 id="4-刷新buffer-队列"><a href="#4-刷新buffer-队列" class="headerlink" title="4. 刷新buffer 队列"></a>4. 刷新buffer 队列</h3><p>我们知道flush方法通过事件传递, 最终会传递到HeadContext 的flush 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           unsafe.flush();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这里最终会调用AbstractUnsafe 的 flush方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         assertEventLoop();</span><br><span class="line"></span><br><span class="line">         ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">         <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         outboundBuffer.addFlush();</span><br><span class="line">         flush0();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先也是拿到ChannelOutboundBuffer对象，然后我们看这一步:</p>
<blockquote>
<p>outboundBuffer.addFlush();</p>
</blockquote>
<p>这一步同样是调整了ChannelOutboundBuffer 的指针, 跟进addFlush方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFlush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// There is no need to process all entries if there was already a flush before and no new messages</span></span><br><span class="line">        <span class="comment">// where added in the meantime.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2577</span></span><br><span class="line">        Entry entry = unflushedEntry;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// there is no flushedEntry yet, so start with the entry</span></span><br><span class="line">                flushedEntry = entry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                flushed ++;</span><br><span class="line">                <span class="keyword">if</span> (!entry.promise.setUncancellable()) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled so make sure we free up memory and notify about the freed bytes</span></span><br><span class="line">                    <span class="keyword">int</span> pending = entry.cancel();</span><br><span class="line">                    decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                entry = entry.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// All flushed so reset unflushedEntry</span></span><br><span class="line">            unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先声明一个entry 指向unflushedEntry, 也就是第一个未flush 的entry. 通常情况下, unflushedEntry 是不为空的, 所以进入if, 再次刷新前flushedEntry通常为空, 所以会执行到<code>flushedEntry = entry;</code>, 也就是 flushedEntry 指向entry, 经过上述操作， 缓存区的指针情况如图所示: </p>
<p><img src="http://files.luyanan.com//img/20191016213539.png"></p>
<p>然后通过do-while 不断寻找unflushedEntry 后面的节点, 直到没有节点为止, flushed  自增代表需要刷新多少节点.循环中我们关注这一步:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>这一步也是统计缓存区中 的字节数, 这里要减掉刷新后的字节数, 我们跟到方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater, <span class="keyword">boolean</span> notifyWritability)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, -size);</span><br><span class="line">       <span class="keyword">if</span> (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark()) &#123;</span><br><span class="line">           setWritable(invokeLater);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同样 TOTAL_PENDING_SIZE_UPDATER 代表缓冲区的字节数, 这里的addAndGet 中参数是-size, 也就是减掉size 的长度, 再看<code>if (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark())</code>  <code>getWriteBufferLowWaterMark()</code>  代表写buffer 的第几位值, 也就是32. 如果写buffer 的长度小于这个数, 就通过setWritable 方法设置写状态, 也就是通道由原来的不可写改成可写. 回到addFlush() 方法，遍历do-while 循环结束后, 将unflushedEntry 指为空, 代表所有的entry 都是可写的, 经过上述操作, 缓冲区的指针情况如下图所示: </p>
<p><img src="http://files.luyanan.com//img/20191017163858.png"></p>
<p>回到AbstractUnsafe 的flush 方法, 指针调整完之后, 我们回到flush0 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (inFlush0) &#123;</span><br><span class="line">                <span class="comment">// Avoid re-entrance</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">            <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span> || outboundBuffer.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inFlush0 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mark all pending write requests as failure if the channel is inactive.</span></span><br><span class="line">            <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span></span><br><span class="line">                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    inFlush0 = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doWrite(outboundBuffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException &amp;&amp; config().isAutoClose()) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Just call &#123;<span class="doctag">@link</span> #close(ChannelPromise, Throwable, boolean)&#125; here which will take care of</span></span><br><span class="line"><span class="comment">                     * failing all flushed messages and also ensure the actual close of the underlying transport</span></span><br><span class="line"><span class="comment">                     * will happen before the promises are notified.</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * This is needed as otherwise &#123;<span class="doctag">@link</span> #isActive()&#125; , &#123;<span class="doctag">@link</span> #isOpen()&#125; and &#123;<span class="doctag">@link</span> #isWritable()&#125;</span></span><br><span class="line"><span class="comment">                     * may still return &#123;<span class="doctag">@code</span> true&#125; even if the channel should be closed as result of the exception.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    outboundBuffer.failFlushed(t, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                inFlush0 = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;	</span><br></pre></td></tr></table></figure>

<p><code>if (inFlush0)</code>  表示判断当前flush 是否在进行中, 如果在进行中, 则返回. 避免重复进入. 我们重点关注 doWrite(outboundBuffer) 方法, 跟到AbstractNioByteChannel 的doWrite() 方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> writeSpinCount = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> setOpWrite = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 每次拿到当前节点</span></span><br><span class="line">           Object msg = in.current();</span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Wrote all messages.</span></span><br><span class="line">               clearOpWrite();</span><br><span class="line">               <span class="comment">// Directly return here so incompleteWrite(...) is not called.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">               <span class="comment">// 转换成ByteBuf</span></span><br><span class="line">               ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">               <span class="comment">// 如果没有可写的值</span></span><br><span class="line">               <span class="keyword">int</span> readableBytes = buf.readableBytes();</span><br><span class="line">               <span class="keyword">if</span> (readableBytes == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// 移除</span></span><br><span class="line">                   in.remove();</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">long</span> flushedAmount = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (writeSpinCount == -<span class="number">1</span>) &#123;</span><br><span class="line">                   writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = writeSpinCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                   <span class="comment">// 将buf 写入到socket中</span></span><br><span class="line">                   <span class="comment">// localFlushedAmount 代表向jdk 底层写了多少字节</span></span><br><span class="line">                   <span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">                   <span class="comment">//如果一个字节没写, 直接break</span></span><br><span class="line">                   <span class="keyword">if</span> (localFlushedAmount == <span class="number">0</span>) &#123;</span><br><span class="line">                       setOpWrite = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 统计总共写了多少字节</span></span><br><span class="line">                   flushedAmount += localFlushedAmount;</span><br><span class="line">                   <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">                       <span class="comment">// 标记全写道</span></span><br><span class="line">                       done = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               in.progress(flushedAmount);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                   <span class="comment">// 移除当前对象</span></span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Break the loop and so incompleteWrite(...) is called.</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</span><br><span class="line">               FileRegion region = (FileRegion) msg;</span><br><span class="line">               <span class="keyword">boolean</span> done = region.transferred() &gt;= region.count();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">                   <span class="keyword">long</span> flushedAmount = <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">if</span> (writeSpinCount == -<span class="number">1</span>) &#123;</span><br><span class="line">                       writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = writeSpinCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                       <span class="keyword">long</span> localFlushedAmount = doWriteFileRegion(region);</span><br><span class="line">                       <span class="keyword">if</span> (localFlushedAmount == <span class="number">0</span>) &#123;</span><br><span class="line">                           setOpWrite = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       flushedAmount += localFlushedAmount;</span><br><span class="line">                       <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">                           done = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   in.progress(flushedAmount);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                   in.remove();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Break the loop and so incompleteWrite(...) is called.</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Should not reach here.</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       incompleteWrite(setOpWrite);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先是一个无限for 循环<code>Object msg = in.current()</code>  这一步是拿到 flushedEntry 指向的entry 中的msg, 跟到current 方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Entry entry = flushedEntry;</span><br><span class="line">      <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> entry.msg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里直接拿到flushedEntry 指向的entry 中关联的msg,  也就是一个ByteBuf. 回到 doWrite 方法:</p>
<p>如果msg 为null,说明没有可以刷新的entry, 则调用<code>clearOpWrite()</code>  方法清除写标识.</p>
<p>如果msg 不为null, 则会判断是否为是ByteBuf 类型, 如果是ByteBuf , 就进入if 块中的逻辑.</p>
<p>if 块中首先将msg 转换为ByteBuf, 然后判断ByteBuf 是否可读, 如果不可读, 则通过in.remove() 将当前的ByteBuf 所关联的entry 移除, 然后跳出这次循环进入下次循环。 remove方法稍后分析. 这里我们先继续往下看, <code>boolean done = false</code>  这里设置一个标识, 标识刷新操作是否执行完成, 这里默认值为false, 代表走到这里没有执行完. </p>
<p><code>writeSpinCount = config().getWriteSpinCount()</code> 这里获取一个写操作的循环次数, 默认是16. 然后根据这个循环次数, 进行循环的写操作, 在循环中, 关注这一步:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br></pre></td></tr></table></figure>

<p>这一步就是将buf 的内容写到channel 中, 并返回写到字节数, 这里会调用NioSocketChannel 的doWriteBytes()  , 我们跟到doWriteBytes 方法中: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doWriteBytes</span><span class="params">(ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> expectedWrittenBytes = buf.readableBytes();</span><br><span class="line">      <span class="keyword">return</span> buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先拿到buf 的可读字节数, 然后通过readBytes 将可读字节写入到jdk底层的channel 中.回到doWrite 方法, 将内容写到jdk底层的channel 之后, 如果一个字节都没写, 说明现在channel 可能不可写,将setOpWrite 设置为true, 用于标识写操作位, 并退出循环. 如果已经写出字节， 则通过    <code>flushedAmount += localFlushedAmount</code> 累加写出的字节数,然后根据是buf是否没有可读字节数判断是否buf 的数据已经写完, 如果写完, 将done 设置为true, 说明写操作完成, 并退出循环. 因为有时候不一定一次就能将ByteBuf 所有的字节写完, 所以这里会继续通过循环进行写出, 直到循环到16次。 如果ByteBuf 内容完全写完, 会通过<code>in.remove()</code> 将当前entry 移除掉, 我们跟到remove方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry e = flushedEntry;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clearNioBuffers();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object msg = e.msg;</span><br><span class="line"></span><br><span class="line">        ChannelPromise promise = e.promise;</span><br><span class="line">        <span class="keyword">int</span> size = e.pendingSize;</span><br><span class="line"></span><br><span class="line">        removeEntry(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!e.cancelled) &#123;</span><br><span class="line">            <span class="comment">// only release message, notify and decrement if it was not canceled before.</span></span><br><span class="line">            ReferenceCountUtil.safeRelease(msg);</span><br><span class="line">            safeSuccess(promise);</span><br><span class="line">            decrementPendingOutboundBytes(size, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recycle the entry</span></span><br><span class="line">        e.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先拿到当前的flushedEntry, 我们重点关注一下removeEntry() 这一步,跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(Entry e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (-- flushed == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// processed everything</span></span><br><span class="line">          flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (e == tailEntry) &#123;</span><br><span class="line">              tailEntry = <span class="keyword">null</span>;</span><br><span class="line">              unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          flushedEntry = e.next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>if (-- flushed == 0)</code> 表示当前节点是否为需要刷新的最后一个节点, 如果是, 则flushedEntry 指针设置为空。 如果当前节点是tailEntry 节点, 说明当前节点是最后一个节点, 将tailEntry 和unflushedEntry 两个指针全部设置为空。如果当前节点不是需要刷新的最后的一个节点, 则通过<code>flushedEntry = e.next</code> 这步将 flushedEntry  指针移动到下一个节点, 以上就是flush 操作的相关逻辑. </p>
<h3 id="5-数据输出回调"><a href="#5-数据输出回调" class="headerlink" title="5. 数据输出回调"></a>5. 数据输出回调</h3><p>首先我们看一段在handler 中的业务逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">ChannelFuture future = ctx.writeAndFlush(<span class="string">&quot;test data&quot;</span>);</span><br><span class="line">        future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;写出成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;写出失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种写法小伙伴们已经不陌生了, 首先调用writeAndFlush 将数据写出, 然后返回的future 进行添加listener, 并且重写回调函数. 这只是一个简单的示例,在回调函数中判断future 的状态成功与否, 成功的话则打印出”写出成功”, 否则打印出”写出失败”. 这里如果写在handler 中通过是在NioEventLoop 线程执行的, 在future 返回之后才会执行添加listener 的操作, 如果在用户线程中 writeAndFlush 是异步执行的, 在添加监听的时候有可能写出操作没有执行完毕, 等写出操作执行完毕之后才会执行回调. 以上逻辑在代码中如何体现呢? 我们首先跟到writeAndFlush 方法中, 会走到AbstractChannelHandlerContext 的writeAndFlush  方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> writeAndFlush(msg, newPromise());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们重点关注newPromise() 方法, 跟进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ChannelPromise <span class="title">newPromise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel(), executor());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里直接创建了DefaultChannelPromise 这个对象并传入了当前的channel 和当前channel 绑定的NioEventLoop 对象, 在DefaultChannelPromise  的构造方法中, 也就将channel 和NioEventLoop  对象绑定在自身的成员变量中.回到writeAndFlush  ()  方法中,继续跟:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="comment">// cancelled</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(msg, <span class="keyword">true</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最后返回了promise ,其实就是我们上一步创建的DefaultChannelPromise 对象, DefaultChannelPromise 实现了ChannelFuture 接口,所以方法如果返回该对象可以被ChannelFuture 类型接收, 我们继续跟write()  方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">        <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AbstractWriteTask task;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            safeExecute(executor, task, promise, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果nioEventLoop 线程, 继续调用invokeWriteAndFlush 方法, 如果不是nioEventLoop 线程则将 writeAndFlush 事件封装成task, 交给 nioEventLoop  线程异步执行。 这里如果是异步执行, 则到这一步之后, 我们的业务代码中, writeAndFlush 就会返回并添加监听 。走到这里无论同步异步, 都会执行invokeWriteAndFlush 方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">           invokeWrite0(msg, promise);</span><br><span class="line">           invokeFlush0();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           writeAndFlush(msg, promise);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           notifyOutboundHandlerException(t, promise);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           unsafe.write(msg, promise);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这里最终会调用unsafe 的write 方法, 并传入promise 对象, 跟到AbstractUnsafe 的write 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class="line">        <span class="comment">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class="line">        <span class="comment">// will be done in flush0()</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2362</span></span><br><span class="line">        safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">        <span class="comment">// release message now to prevent resource-leak</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们首先关注两个部分, 首先看在catch 中safeSetFailure 这步, 因为是catch 块, 说明发生了异常, 写到缓冲区不成功, safeSetFailure  就是设置写出失败的状态, 我们跟到 safeSetFailure() 方法中: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">safeSetFailure</span><span class="params">(ChannelPromise promise, Throwable cause)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.tryFailure(cause)) &#123;</span><br><span class="line">              logger.warn(<span class="string">&quot;Failed to mark a promise as failure because it&#x27;s done already: &#123;&#125;&quot;</span>, promise, cause);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里看if 判断, 首先判断的是promise 是DefaultChannelPromise, 所以<code>promise instanceof VoidChannelPromise</code> 为true. 重点分析 promise.tryFailure(cause) , 这里是设置失败状态, 这里会调用DefaultPromise的 tryFailure() 方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (setFailure0(cause)) &#123;</span><br><span class="line">         notifyListeners();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>再跟到 setFailure0() 方法中: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setFailure0</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> setValue0(<span class="keyword">new</span> CauseHolder(checkNotNull(cause, <span class="string">&quot;cause&quot;</span>)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</span><br><span class="line">           RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) &#123;</span><br><span class="line">           checkNotifyWaiters();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里在if 块中的cas操作, 会将参数objResult 的值设置到DefaultPromise 的成员变量 result 中, 表示当前操作为异常状态. </p>
<p>