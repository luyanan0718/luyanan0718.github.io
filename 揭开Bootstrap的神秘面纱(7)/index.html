<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="揭开Bootstrap 的神秘面纱1. 客户端Bootstrap1. Channel简介在Netty中,Channel是一个Socket的抽象, 它为用户提升了关于Socket状态(是否是连接还是断开) 以及对Socket的读写等操作, 每当Netty 建立一个连接后， 都创建一个对应的Channel 实例. 除了TCP协议外, Netty 还支持很多的其他的连接协议, 并且每种协议还有NIO(非">
<meta property="og:type" content="article">
<meta property="og:title" content="揭开Bootstrap的神秘面纱(7)">
<meta property="og:url" content="http://luyanan.com/%E6%8F%AD%E5%BC%80Bootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1(7)/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="揭开Bootstrap 的神秘面纱1. 客户端Bootstrap1. Channel简介在Netty中,Channel是一个Socket的抽象, 它为用户提升了关于Socket状态(是否是连接还是断开) 以及对Socket的读写等操作, 每当Netty 建立一个连接后， 都创建一个对应的Channel 实例. 除了TCP协议外, Netty 还支持很多的其他的连接协议, 并且每种协议还有NIO(非">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20190923212744.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190924185100.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925155028.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925170544.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925170641.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925171327.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925173905.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925173943.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190925201913.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190926200618.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190926200710.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190926200754.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190926204647.png">
<meta property="article:published_time" content="2021-03-12T02:17:43.810Z">
<meta property="article:modified_time" content="2021-03-12T02:17:43.810Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20190923212744.png">

<link rel="canonical" href="http://luyanan.com/%E6%8F%AD%E5%BC%80Bootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1(7)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>揭开Bootstrap的神秘面纱(7) | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/%E6%8F%AD%E5%BC%80Bootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1(7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          揭开Bootstrap的神秘面纱(7)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 10:17:43" itemprop="dateCreated datePublished" datetime="2021-03-12T10:17:43+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="揭开Bootstrap-的神秘面纱"><a href="#揭开Bootstrap-的神秘面纱" class="headerlink" title="揭开Bootstrap 的神秘面纱"></a>揭开Bootstrap 的神秘面纱</h1><h2 id="1-客户端Bootstrap"><a href="#1-客户端Bootstrap" class="headerlink" title="1. 客户端Bootstrap"></a>1. 客户端Bootstrap</h2><h3 id="1-Channel简介"><a href="#1-Channel简介" class="headerlink" title="1. Channel简介"></a>1. Channel简介</h3><p>在Netty中,Channel是一个Socket的抽象, 它为用户提升了关于Socket状态(是否是连接还是断开) 以及对Socket的读写等操作, 每当Netty 建立一个连接后， 都创建一个对应的Channel 实例.</p>
<p>除了TCP协议外, Netty 还支持很多的其他的连接协议, 并且每种协议还有NIO(非阻塞IO) 和OLO( Old - io,即传统的IO ）版本的区别. 不同 协议不同的阻塞类型的连接都有不同的Channel 类型与之对应. 下面是一些常见的Channel 类型</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>NioSocketChannel</td>
<td>异步非阻塞的客户端TCP Socket连接</td>
</tr>
<tr>
<td>NioServerSocketChannel</td>
<td>异步非阻塞的服务端TCP socket连接</td>
</tr>
<tr>
<td>NioDatagramChannel</td>
<td>异步非阻塞的UDP 连接</td>
</tr>
<tr>
<td>NioSctpChannel</td>
<td>异步的客户端Sctp(Stream Control Transmission Protocol,流控制传输协议) 连接</td>
</tr>
<tr>
<td>NioSctpServerChannel</td>
<td>异步的服务端连接</td>
</tr>
<tr>
<td>OioSocketChannel</td>
<td>同步阻塞的客户端 TCP Socket连接</td>
</tr>
<tr>
<td>OioServerSocketChannel</td>
<td>同步阻塞的服务端 TCP Socket连接</td>
</tr>
<tr>
<td>OioDatagramChannel</td>
<td>同步阻塞的UDP连接</td>
</tr>
<tr>
<td>OioSctpChannel</td>
<td>同步的Sctp连接</td>
</tr>
<tr>
<td>OioSctpServerChannel</td>
<td>同步的客户端 TCP Socket 连接</td>
</tr>
</tbody></table>
<p>下面我们来看一下Channel的总体类图：</p>
<p><img src="http://files.luyanan.com//img/20190923212744.png"></p>
<h3 id="2-NioSocketChannel的创建"><a href="#2-NioSocketChannel的创建" class="headerlink" title="2. NioSocketChannel的创建"></a>2. NioSocketChannel的创建</h3><p>Bootstrap是Netty 提供了一个便利的工厂类, 我们可以通过它来完成Netty的客户端或者服务端的Netty的初始化, 下面我先来看一个例子, 从客户端和服务端的角度来分别分析一下Netty的程序是如何启动的, 首先, 首先我们从客户端的代码片段开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hostName, <span class="keyword">int</span> port, String nickName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 发起同步连接操作</span></span><br><span class="line">        ChannelFuture future = bootstrap.connect(hostName, port).sync();</span><br><span class="line">        future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的客户端代码虽然简单, 却展示了Netty 客户端初始化所需的内容.</p>
<ol>
<li>EventLoopGroup : 不论是服务端还是客户端, 都必须指定EventLoopGroup. 在这个例子中, 指定了NioEventLoopGroup,  表示一个NIO的EventLoopGroup .</li>
<li>ChannelType: 指定Channel的类型， 因为是客户端, 因此使用了NioSocketChannel.</li>
<li>Handler: 设置处理数据的handler</li>
</ol>
<p>下面我们继续深入代码, 看一下客户端通过 Bootstrap 启动后, 都做了哪些工作? 我们看一下NioSocketChannel的类层次结构如下:</p>
<p><img src="http://files.luyanan.com//img/20190924185100.png"></p>
<p>回到我们在客户端连接代码的初始化Bootstrap 中调用channel() 方法, 传入的参数为 NioSocketChannel.class  , 在这个方法中 其实就是初始化了一个ReflectiveChannelFactory 的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而ReflectiveChannelFactory  实现了ChannelFactory 接口, 它提供了唯一的方法, 即newChannel() 方法, 我们看到其实现代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码提示, 我们可以得出</p>
<ol>
<li>Bootstrap中的 ChannelFactory 的实现类是 ReflectiveChannelFactory  </li>
<li>通过channel() 方法创建的Channel 具体类型是 <code>NioSocketChannel</code></li>
</ol>
<p>Channel 的实例化过程就是调用 ChannelFactory 的newChannel() 方法, 而实例化的Channel 具体类型又是和初始化Bootstrap 时传入的channel() 方法的参数相关.  因此对于客户端的Bootstrap而言, 创建的Channel 实例就是<code>NioSocketChannel</code></p>
<h3 id="3-客户端Channel-的初始化"><a href="#3-客户端Channel-的初始化" class="headerlink" title="3.客户端Channel 的初始化"></a>3.客户端Channel 的初始化</h3><p>前面我们已经知道了如何设置一个Channel的类型, 并且了解到Channel是通过 ChannelFactory 的newChannel()  方法来实例化的, 那么ChannelFactory 的newChannel()方法又是在哪里被调用的呢?  继续追踪, 我们发现其调用链如下:</p>
<p><img src="http://files.luyanan.com//img/20190925155028.png"></p>
<p>在AbstractBootstrap 的 initAndRegister() 中调用了ChannelFactory 的newChannel()  来创建一个NioSocketChannel 的实例, 具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Channel channel = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           channel = channelFactory.newChannel();</span><br><span class="line">           init(channel);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">       &#125;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在newChannel()  方法中, 利用反射机制调用类对象的newInstance() 方法来创建一个新的Channel  实例, 相当于调用 NioSocketChannel的默认构造器, NioSocketChannel的默认构造器代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(newSocket(provider));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码比较关键, 我们看到,  这个构造器中会调用newSocket) 来打开一个新的Java NIO 的 SocketChannel ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static SocketChannel newSocket(SelectorProvider provider) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  Use the &#123;@link SelectorProvider&#125; to open &#123;@link SocketChannel&#125; and so remove condition in</span><br><span class="line">         *  &#123;@link SelectorProvider#provider()&#125; which is called by each SocketChannel.open() otherwise.</span><br><span class="line">         *</span><br><span class="line">         *  See &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2308&quot;&gt;#2308&lt;&#x2F;a&gt;.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return provider.openSocketChannel();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new ChannelException(&quot;Failed to open a socket.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会调用父类, 即 AbstractNioByteChannel的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="keyword">null</span>, socket);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(parent, socket);</span><br><span class="line">     config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并传入参数 parent = null,ch 为刚才 newSocket() 常见的 Java NIO  的SocketChannel 对象, 因此新创建的NioSocketChannel 对象中, parent 暂时为 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用 父类的 AbstractNioChannel的构造器, 并传入参数 readInterestOp =  SelectionKey.OP_READ, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(parent);</span><br><span class="line">      <span class="keyword">this</span>.ch = ch;</span><br><span class="line">      <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ch.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">              <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                  logger.warn(</span><br><span class="line">                          <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 然后继续调用父类 AbstractChannel 的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, NioSocketChannel 就初始化结束了, 我们可以稍微总结一下 NioSocketChannel 初始化所做的工作内容：</p>
<ol>
<li><p>调用NioSocketChannel  的 newSocket(DEFAULT_SELECTOR_PROVIDER) 打开一个新的Java NioSocketChannel,</p>
</li>
<li><p>AbstractChannel (Channel parent)  中需要初始化的属性:</p>
<ul>
<li>id: 每一个Channel 都拥有的一个唯一的id</li>
<li>parent: 属性值为 null</li>
<li>unsafe: 通过 Unsafe() 实例化一个 unsafe 对象, 他的类型是AbstractNioByteChannel.NioByteUnsafe 内部类.</li>
<li>pipeline: 是通过DefaultChannelPipeline 新创建的实力</li>
</ul>
</li>
<li><p>AbstractNioChannel  的属性 </p>
<ul>
<li>ch: 赋值为 Java SocketChannel, 即NioSocketChannel  的newSocket() 方法返回的Java Nio SocketChannel, </li>
<li>readInterestOp： 赋值为SelectionKey.OP_READ</li>
<li>ch:被配置为非阻塞, 即调用ch.configureBlocking(false)。</li>
</ul>
</li>
</ol>
<h3 id="4-Unsafe-字段的变化"><a href="#4-Unsafe-字段的变化" class="headerlink" title="4. Unsafe 字段的变化"></a>4. Unsafe 字段的变化</h3><p>我们简单提到了, 在实例化NioSocketChannel 的过程中, 会在父类 AbstractChannel 的构造方法中调用newUnsafe() 来获取一个 unsafe 实力,那么unsafe 是怎么初始化的, 他的作用是什么?</p>
<p>其实 unsafe 特别关键, 它封装了对Java 底层的Socket 的操作, 因此实际上是通过 Netty的上层 和Java 底层的重要的桥梁. 那么下面我们来看一下它提供的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Return the assigned &#123;<span class="doctag">@link</span> RecvByteBufAllocator.Handle&#125; which will be used to allocate &#123;<span class="doctag">@link</span> ByteBuf&#125;&#x27;s when</span></span><br><span class="line"><span class="comment">        * receiving data.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       RecvByteBufAllocator.<span class="function">Handle <span class="title">recvBufAllocHandle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Return the &#123;<span class="doctag">@link</span> SocketAddress&#125; to which is bound local or</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Return the &#123;<span class="doctag">@link</span> SocketAddress&#125; to which is bound remote or</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@code</span> null&#125; if none is bound yet.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function">SocketAddress <span class="title">remoteAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Register the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; and notify</span></span><br><span class="line"><span class="comment">        * the &#123;<span class="doctag">@link</span> ChannelFuture&#125; once the registration was complete.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Bind the &#123;<span class="doctag">@link</span> SocketAddress&#125; to the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; and notify</span></span><br><span class="line"><span class="comment">        * it once its done.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Connect the &#123;<span class="doctag">@link</span> Channel&#125; of the given &#123;<span class="doctag">@link</span> ChannelFuture&#125; with the given remote &#123;<span class="doctag">@link</span> SocketAddress&#125;.</span></span><br><span class="line"><span class="comment">        * If a specific local &#123;<span class="doctag">@link</span> SocketAddress&#125; should be used it need to be given as argument. Otherwise just</span></span><br><span class="line"><span class="comment">        * pass &#123;<span class="doctag">@code</span> null&#125; to it.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The &#123;<span class="doctag">@link</span> ChannelPromise&#125; will get notified once the connect operation was complete.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Disconnect the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelFuture&#125; and notify the &#123;<span class="doctag">@link</span> ChannelPromise&#125; once the</span></span><br><span class="line"><span class="comment">        * operation was complete.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Close the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; and notify the &#123;<span class="doctag">@link</span> ChannelPromise&#125; once the</span></span><br><span class="line"><span class="comment">        * operation was complete.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Closes the &#123;<span class="doctag">@link</span> Channel&#125; immediately without firing any events.  Probably only useful</span></span><br><span class="line"><span class="comment">        * when registration attempt failed.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">closeForcibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Deregister the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; from &#123;<span class="doctag">@link</span> EventLoop&#125; and notify the</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> ChannelPromise&#125; once the operation was complete.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Schedules a read operation that fills the inbound buffer of the first &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.  If there&#x27;s already a pending read operation, this method does nothing.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Schedules a write operation.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Flush out all write operations scheduled via &#123;<span class="doctag">@link</span> #write(Object, ChannelPromise)&#125;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Return a special ChannelPromise which can be reused and passed to the operations in &#123;<span class="doctag">@link</span> Unsafe&#125;.</span></span><br><span class="line"><span class="comment">        * It will never be notified of a success or error and so is only a placeholder for operations</span></span><br><span class="line"><span class="comment">        * that take a &#123;<span class="doctag">@link</span> ChannelPromise&#125; as argument but for which you not want to get notified.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns the &#123;<span class="doctag">@link</span> ChannelOutboundBuffer&#125; of the &#123;<span class="doctag">@link</span> Channel&#125; where the pending write requests are stored.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function">ChannelOutboundBuffer <span class="title">outboundBuffer</span><span class="params">()</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出, 这些方法其实都是对应到相关的Java 底层的Socket 的操作</p>
<p>继续回到 AbstractChannel 的构造方法, 在这里调用了 newUnsafe() 获取了一个新的 Unsafe 对象, 而newUnsafe 方法在NioSocketChannel 中被重写了, 来看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractNioUnsafe <span class="title">newUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioSocketChannelUnsafe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioSocketChannel 的 newUnsafe 方法会返回一个 NioSocketChannelUnsafe 实例, 从这里我们可以确定了, 在实例化中的NioSocketChannel 中的unsafe 字段, 其实是一个 NioSocketChannelUnsafe 的实例.</p>
<h3 id="5-Pipeline-的实例化"><a href="#5-Pipeline-的实例化" class="headerlink" title="5. Pipeline 的实例化"></a>5. Pipeline 的实例化</h3><p>上面我们分析了 NioSocketChannel  的大体初始化过程, 但是我们漏掉了一个关键的过程. 即ChannelPipeline 的初始化. 在Pipeline 的 注释说明中写到 “Each channel has its own pipeline and it is created automatically when a new channel is created.” , 我们知道在实例化一个Channel 时， 需要都要实例化一个ChannelPipeline, 而我们确定在 AbstractChannel 的构造器中看到了 pipeline 字段被初始化为 DefaultChannelPipeline 的实例, 接下来我们就来看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultChannelPipeline 的构造器需要传入一个channel, 而这个channel 就是我们实例化的NioSocketChannel . DefaultChannelPipeline 会将这个 NioSocketChannel  对象保存在 channel 字段中, DefaultChannelPipeline 中还有两个特殊的字段, 即 head 和tail .这两个字段是双向链表的头和尾. 其实在DefaultChannelPipeline 中, 维护了一个以 AbstractChannelHandlerContext 为节点元素的双向链表, 这个链表是Netty 实现Pipeline 的关键. 关于DefaultChannelPipeline  中的双向链表以及它所起的作用, 我们暂时先不讲解, 先看看 HeadContext 的类继承层次结构如下所示：</p>
<p><img src="http://files.luyanan.com//img/20190925170544.png"></p>
<p>TailContext的类继承层次如下所示：</p>
<p><img src="http://files.luyanan.com//img/20190925170641.png"></p>
<p>我们可以看到, 链表中head 是一个 AbstractChannelHandlerContext 的构造器， 并传入参数 inbound = false, outbound = true. 而 TailContext 的构造器 与 HeadContext 的相反, 他调用了父类的AbstractChannelHandlerContext  的构造器, 并传入参数 inbound = true, outbound = false. 即 head 是一个 OutBoundHandler，而tail 是一个InBoundHandler.</p>
<h3 id="6-EventLoop的初始化"><a href="#6-EventLoop的初始化" class="headerlink" title="6. EventLoop的初始化"></a>6. EventLoop的初始化</h3><p>回到最开始的 ChatClient 代码, 我们在一开始就实例化了一个NioEventLoopGroup 对象, 因为我们就从构造器中追踪一下 EventLoop 的初始化过程, 首先来看一下 NioEventLoopGroup 的类继承层次.</p>
<p><img src="http://files.luyanan.com//img/20190925171327.png"></p>
<p>NioEventLoop 有几个重载的构造器, 不过内容都没有太大的区别, 最终都是调用 父类的MultithreadEventLoopGroup的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> &#123;<span class="doctag">@link</span> MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, Executor, Object...)&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其实有个意思的地方是, 如果我们传入的线程数 nThreads 是0, 那么Netty 会为我们设置默认的线程数</p>
<p>DEFAULT_EVENT_LOOP_THREADS, 这个默认的线程数是怎么确定的呢?</p>
<p>其实很简单, 在静态代码中, 会首先确定 DEFAULT_EVENT_LOOP_THREADS的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">            <span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 首先会从系统属性中读取 <code>io.netty.eventLoopThreads</code> 的值, 如果我们没有设置的话, 那么就返回默认的值, 即处理器核心数*2, 回到 MultithreadEventLoopGroup 构造器中继续调用 父类MultithreadEventLoopGroup 的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a new instance.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> nThreads          the number of threads that will be used by this instance.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> executor          the Executor to use, or &#123;<span class="doctag">@code</span> null&#125; if the default should be used.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chooserFactory    the &#123;<span class="doctag">@link</span> EventExecutorChooserFactory&#125; to use.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args              arguments which will passed to each &#123;<span class="doctag">@link</span> #newChild(Executor, Object...)&#125; call</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">          <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              children[i] = newChild(executor, args);</span><br><span class="line">              success = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                      children[j].shutdownGracefully();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                      EventExecutor e = children[j];</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                              e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                          <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                          Thread.currentThread().interrupt();</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                  terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">          e.terminationFuture().addListener(terminationListener);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">      Collections.addAll(childrenSet, children);</span><br><span class="line">      readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>我们可以继续追踪到newChooser 方法里面看看其实现逻辑, 具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEventExecutorChooserFactory</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooserFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultEventExecutorChooserFactory INSTANCE = <span class="keyword">new</span> DefaultEventExecutorChooserFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultEventExecutorChooserFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTowEventExecutorChooser(executors);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTowEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        PowerOfTowEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码逻辑 主要表达的意思是: 即如果nThreads 是2的幂, 即使用 PowerOfTowEventExecutorChooser,否则使用</p>
<p>GenericEventExecutorChooser, 这两个 chooser 方法都重写了next() 方法, next() 方法的主要功能就是将数组索引循环位移, 如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20190925173905.png"></p>
<p>当索引移动最后一个位置的时候， 再调用 next() 方法就会将索引位置重新指向0</p>
<p><img src="http://files.luyanan.com//img/20190925173943.png"></p>
<p>这个运算逻辑其实很简单, 就是每次让索引自增后和数据长度取模 , idx.getAndIncrement() % executors.length . 但是就连一个非常简单的数组索引运算, Netty 都帮我们做了优化, 因为在计算机底层, &amp;与 比% 运算效率更高。</p>
<p>好了, 分析到这里我们就应该非常清楚MultithreadEventExecutorGroup 中的处理逻辑了., 简单做一个总结: </p>
<ol>
<li>创建一个 大小为 nThreads 的SingleThreadEventExecutor 数组</li>
<li>根据nThreads  的大小, 创建不同的 Chooser,即 如果 nThreads  是2的幂, 则使用 PowerOfTowEventExecutorChooser, 反之则使用GenericEventExecutorChooser, 不论使用哪个Chooser,他们的功能都是一样的, 即从 children 数组中 选出一个合适的EventExecutor  实例.</li>
<li>调用 newChild方法初始化 children 数组</li>
</ol>
<p>根据上面的代码. 我们也能知道， MultithreadEventLoopGroup 内部维护了一个 EventExecutor 数组, 而Netty EventLoopGroup的实现机制就是建立在 MultithreadEventLoopGroup之上的, 每当一个Netty 需要一个EventLoop 时， 会调用next() 方法获取一个可用的EventLoop .</p>
<p>上面代码的最后一部分是 newChild()  方法, 这是一个抽象方法, 它的任务是 实例化EventLoop 对象, 我们跟踪一下它的代码, 可以发现, 这个方法在 NioEventLoopGroup类中有实现, 其实内容很简单.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其实逻辑很简单 就是实例化一个 NioEventLoop 对象, 然后返回NioEventLoop 对象</p>
<p>最后总结一下 整个NioEventLoop 的初始化过程.</p>
<ol>
<li><p>EventLoopGroup(其实是MultithreadEventLoopGroup) 内部维护了一个类型为 EventExecutor children 数组, 其大小是nThreads , 这样就构成了一个线程池.<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
</li>
<li><h1 id="如果我们在实例化-NioEventLoopGroup时-如果指定了线程池大小-则nThreads-就是指定的值-反之是处理器核心数-2-oba"><a href="#如果我们在实例化-NioEventLoopGroup时-如果指定了线程池大小-则nThreads-就是指定的值-反之是处理器核心数-2-oba" class="headerlink" title="如果我们在实例化 NioEventLoopGroup时, 如果指定了线程池大小, 则nThreads 就是指定的值, 反之是处理器核心数 * 2 oba"></a>如果我们在实例化 NioEventLoopGroup时, 如果指定了线程池大小, 则nThreads 就是指定的值, 反之是处理器核心数 * 2 oba</h1></li>
<li><p>如果我们在实例化 NioEventLoopGroup时, 如果指定了线程池大小, 则nThreads 就是指定的值, 反之是处理器核心数 * 2 </p>
</li>
<li><p>MultithreadEventLoopGroup 中会调用 newChild 抽象方法来初始化children 数组</p>
</li>
<li><p>抽象方法newChild 是在NioEventLoopGroup 中实现的, 它返回一个NioEventLoop 实例</p>
</li>
<li><p>NioEventLoop 属性赋值</p>
<ul>
<li>provider：在NioEventLoopGroup  构造器中通过SelectorProvider.provider()获取一个 SelectorProvider。</li>
<li>selector: 在 NioEventLoop  构造器中通过调用provider.openSelector()方法 获取一个selector 对象</li>
</ul>
</li>
</ol>
<h3 id="7-Channel-注册到Selector"><a href="#7-Channel-注册到Selector" class="headerlink" title="7. Channel 注册到Selector"></a>7. Channel 注册到Selector</h3><p>   在前面的分析中, 我们提到Channel 会在Bootstrap 的initAndRegister() 中进行初始化, 但是这个方法还会将初始化好的channel 注册到NioEventLoop 的selector中, 接下来我们分析一下Channel的注册过程.</p>
<p>在回顾一下AbstractBootstrap的 initAndRegister 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Channel channel = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         channel = channelFactory.newChannel();</span><br><span class="line">         init(channel);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">         <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">             channel.unsafe().closeForcibly();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">     <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">             channel.close();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             channel.unsafe().closeForcibly();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span></span><br><span class="line">     <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">     <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">     <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">     <span class="comment">//    added to the event loop&#x27;s task queue for later execution.</span></span><br><span class="line">     <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span></span><br><span class="line">     <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">     <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> regFuture;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当channel 初始化后, 紧接着会调用config().group().register() 方法来向 selector 中注册Channel, 我们继续追踪的话, 会发现其调用链如下:</p>
<p><img src="http://files.luyanan.com//img/20190925201913.png"></p>
<p>通过追踪调用链 , 最终我们发现是调用到了 unsafe 的 register 方法, 那么接下来我们仔细看一下</p>
<p>AbstractChannel$AbstractUnsafe.register() 方法中到底做了什么?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">               promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">               promise.setFailure(</span><br><span class="line">                       <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">               register0(promise);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           register0(promise);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.warn(</span><br><span class="line">                           <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                           AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">                   closeForcibly();</span><br><span class="line">                   closeFuture.setClosed();</span><br><span class="line">                   safeSetFailure(promise, t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先, 将 eventLoop 赋值给Channel的 eventLoop 属性, 而我们直到其实这个 eventLoop 对象其实是MultithreadEventLoopGroup 的next() 方法生成的. 根据我们前面的分析, 我们可以确定next() 方法返回的eventLoop 对象是 NioEventLoop 实例, register 方法接着调用了register0 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></span><br><span class="line">             <span class="comment">// call was outside of the eventLoop</span></span><br><span class="line">             <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">             doRegister();</span><br><span class="line">             neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">             registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line">             <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">             pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">             safeSetSuccess(promise);</span><br><span class="line">             pipeline.fireChannelRegistered();</span><br><span class="line">             <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">             <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">             <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                     pipeline.fireChannelActive();</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                     <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></span><br><span class="line">                     <span class="comment">// again so that we process inbound data.</span></span><br><span class="line">                     <span class="comment">//</span></span><br><span class="line">                     <span class="comment">// See https://github.com/netty/netty/issues/4805</span></span><br><span class="line">                     beginRead();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">             closeForcibly();</span><br><span class="line">             closeFuture.setClosed();</span><br><span class="line">             safeSetFailure(promise, t);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<p>register0() 方法又调用了AbstractNioChannel.doRegister() 方法,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到javaChannel 这个方法我们前面已经已经知道了, 它返回的是一个Java Nio 的 SocketChannel 对象, 这里我们将这个SocketChannel 注册到与EventLoop 关联的 selector 上.</p>
<p>我们总结一下Channel的注册过程</p>
<ol>
<li> 首先在AbstractChannel 的 initAndRegister() 方法中, 通过group().register(channel) 调用MultithreadEventLoopGroup的 register() 方法.</li>
<li>在MultithreadEventLoopGroup 的register() 方法中, 调用next() 方法 获取一个可用的 SingleThreadEventLoop,然后调用它的 register()  方法.</li>
<li>在 SingleThreadEventLoop 的 register()  方法中, 调用channel.unsafe().register(this, promise) 方法来获取 channel 的unsafe() 底层操作对象, 然后调用 unsafe的 register 方法.</li>
<li>在AbstractUnsafe 的register() 中, 调用 register0() 方法注册Channel 对象.</li>
<li>在AbstractUnsafe的  register0() 方法中, 调用 AbstractNioChannel 的 doRegister() 方法</li>
<li>AbstractNioChannel的 doRegister() 方法通过javaChannel().register(eventLoop().selector, 0, this); 将channel 对应的Java  NIO 的Socket Channel 注册到 eventLoop 的 selector 中 ,并且将当前channel 作为attachment 与SocketChannel 关联.</li>
</ol>
<p>总的来说, Channel 注册过程所作的工作就是将Chanel 与对应的EventLoop 关联, 这因此体现出了, 在Netty中, 每个Channel 都会关联一个特定的EventLoop ,  并且这个Channel 中的所有操作都是在这个EventLoop 中执行的. 当关联好Channel 和EventLoop 后, 会继续调用底层Java Nio 的SocketChannel 对象的register()  方法, 将底层Java NIO 的SocketChannel 注册到指定的 selector 中, 通过这两步就完成了Netty 对Channel 的注册.</p>
<h3 id="8-Handler-的添加过程"><a href="#8-Handler-的添加过程" class="headerlink" title="8. Handler 的添加过程"></a>8. Handler 的添加过程</h3><p>Netty 有一个强大和灵活的地方就是基于 Pipeline 的自定义header 机制. 基于此, 我们可以像添加插件一样自由组合各种各样的handler来完成业务逻辑。例如我们需要处理http 数据, 那么就可以在 pipeline 之前添加一个针对HTTP 编解码的Handler, 接着添加我们的业务逻辑handler, 这样网络上的数据流就像通过一个管道一样, 从不同的headler 中流过并进行编解码, 最终再到达我们自己的handler中。 </p>
<p>我们先从体验一下自定义handler是如何以及何时添加到ChannelPipeline 中的, 首先我们看一下我们的用户代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hostName, <span class="keyword">int</span> port, String nickName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">           bootstrap.group(group)</span><br><span class="line">                   .channel(NioSocketChannel.class)</span><br><span class="line">                   .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                   .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                           ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> ChatClientHandler(nickName));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">           <span class="comment">// 发起同步连接操作</span></span><br><span class="line">           ChannelFuture future = bootstrap.connect(hostName, port).sync();</span><br><span class="line">           future.channel().closeFuture().sync();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           group.shutdownGracefully();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码片段就是实现了handler 的添加功能, 我们看到 , Bootstrap 的 handler 方法接收一个ChannelInitializer,而我们传的参数是一个派生于抽象类 ChannelInitializer的 匿名类, 它当然也实现了ChannelHandler 接口, 我们来看一下, ChannelInitializer类内到底有什么玄机.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(ChannelInitializer.class);</span><br><span class="line">    <span class="comment">// We use a ConcurrentMap as a ChannelInitializer is usually shared between all Channels in a Bootstrap /</span></span><br><span class="line">    <span class="comment">// ServerBootstrap. This way we can reduce the memory usage compared to use Attributes.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;ChannelHandlerContext, Boolean&gt; initMap = PlatformDependent.newConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method will be called once the &#123;<span class="doctag">@link</span> Channel&#125; was registered. After the method returns this instance</span></span><br><span class="line"><span class="comment">     * will be removed from the &#123;<span class="doctag">@link</span> ChannelPipeline&#125; of the &#123;<span class="doctag">@link</span> Channel&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch            the &#123;<span class="doctag">@link</span> Channel&#125; which was registered.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception    is thrown if an error occurs. In that case it will be handled by</span></span><br><span class="line"><span class="comment">     *                      &#123;<span class="doctag">@link</span> #exceptionCaught(ChannelHandlerContext, Throwable)&#125; which will by default close</span></span><br><span class="line"><span class="comment">     *                      the &#123;<span class="doctag">@link</span> Channel&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Normally this method will never be called as handlerAdded(...) should call initChannel(...) and remove</span></span><br><span class="line">        <span class="comment">// the handler.</span></span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">            <span class="comment">// we called initChannel(...) so we need to call now pipeline.fireChannelRegistered() to ensure we not</span></span><br><span class="line">            <span class="comment">// miss an event.</span></span><br><span class="line">            ctx.pipeline().fireChannelRegistered();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Called initChannel(...) before which is the expected behavior, so just forward the event.</span></span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle the &#123;<span class="doctag">@link</span> Throwable&#125; by logging and closing the &#123;<span class="doctag">@link</span> Channel&#125;. Sub-classes may override this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Failed to initialize a channel. Closing: &quot;</span> + ctx.channel(), cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125; If override this method ensure you call super!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            <span class="comment">// This should always be true with our current DefaultChannelPipeline implementation.</span></span><br><span class="line">            <span class="comment">// The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering</span></span><br><span class="line">            <span class="comment">// suprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers</span></span><br><span class="line">            <span class="comment">// will be added in the expected order.</span></span><br><span class="line">            initChannel(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                initChannel((C) ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">                <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">                exceptionCaught(ctx, cause);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                remove(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            initMap.remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelInitializer 是一个抽象类, 它有一个抽象方法initChannel(), 我们看到的匿名类正是实现了这个方法, 并在这个方法中添加自定义的 handler的. 那么 initChannel() 是在哪里被调用的呢？ 其实是在 ChannelInitializer 的channelRegistered()  方法中.</p>
<p>接下来关注一下 channelRegistered 方法, 从上面的源码中, 我们可以看到, 在channelRegistered() 方法中, 会调用 initChannel()  方法, 将自定义的 handler 添加到 ChannelPipeline 中, 然后调用  ctx.pipeline().remove(this) 将自己从 ChannelPipeline 中删除, 上面的分析过程, 如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20190926200618.png"></p>
<p>接着 initChannle() 方法调用了后, 添加了自定义的 handler</p>
<p><img src="http://files.luyanan.com//img/20190926200710.png"></p>
<p>最后将ChannelInitializer 删除</p>
<p><img src="http://files.luyanan.com//img/20190926200754.png"></p>
<p>分析到这里, 我们已经简单了解自定义的 handler 是如何添加到 ChannelPipeline 中的了, </p>
<h3 id="9-客户端发起连接请求"><a href="#9-客户端发起连接请求" class="headerlink" title="9.  客户端发起连接请求."></a>9.  客户端发起连接请求.</h3><p>经过上面的分析后, 我们大致了解了Netty 客户端初始化时, 所做的工作, 那么接下来直奔主题分析一下客户端是如何发起TCP 连接的.</p>
<p>首先, 客户端通过调用Bootstrap.connect() 方法进行连接, 在 connect() 方法中, 会进行一些参数检查后, 最终调用的是doConnect()  方法. 其代码实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class="line">       <span class="comment">// the pipeline in its channelRegistered() implementation.</span></span><br><span class="line">       <span class="keyword">final</span> Channel channel = connectPromise.channel();</span><br><span class="line">       channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   channel.connect(remoteAddress, connectPromise);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">               &#125;</span><br><span class="line">               connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在doConnect() 中,会有 eventLoop 线程中调用 Channel的 connect() 方法, 而这个Channel的具体类型实际上就是NioSocketChannel, 前面已经分析过了., 继续追踪到到 channel.connect() 方法中, 我们发现它调用的是DefaultChannelPipeline.connect()  方法,  pipeline的  connect()  方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tail 我们已经分析过了, 是一个TailContext 的实例 , 而TailContext 又是 AbstractChannelHandlerContext 的子类, 并且没有实现 connect()  方法, 因此这里调用的其实是 AbstractChannelHandlerContext的connect()  方法, 我们看一下这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">           <span class="comment">// cancelled</span></span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">       EventExecutor executor = next.executor();</span><br><span class="line">       <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">           next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, promise, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> promise;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中有一个关键的地方, 即<code>final AbstractChannelHandlerContext next = findContextOutbound();</code>  这里调用 findContextOutbound() 方法, 从DefaultChannelPipeline 内的双向链表的tail  开始， 不断的向前找到第一个outbound为 true的AbstractChannelHandlerContext,   然后调用它的invokeConnect()  方法, 其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).connect(<span class="keyword">this</span>, remoteAddress, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们有提到, 在DefaultChannelPipeline 的构造器中 , 实例化了 两个对象, head 和 tail . 并形成了双向链表的头和尾. head  是HeadContext是实例, 它实现了ChannelOutboundHandler接口, 并且它的outbound设置为 true,  因此在findContextOutbound()  方法中, 找到的AbstractChannelHandlerContext 对象其实就是head, 进而在invokeConnect()    方法中,我们向上转换为 ChannelOutboundHandler 就是没问题的了. 而又因为 HeadContext 重写了 connect() 方法, 因此实际调用的是HeadContext的connect()  方法, 我们接着追踪到HeadContext的 connect()  方法, 其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 connect() 方法非常简单, 只是调用了 unsafe的connect()  方法, 回顾一下 HeadContext 的构造器. 我们发现这个 unsafe  其实就是  pipeline.channel().unsafe()  返回的Channel 的 unsafe 字段, 到此为止， 我们应该已经知道, 其实是AbstractNioByteChannel.NioByteUnsafe 内部类. 最后, 我们找到创建 Socket 连接的关键代码继续追踪， 其实就是调用AbstractNioUnsafe的 connect()  方法, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// Already a connect in process.</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">             <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">                 fulfillConnectPromise(promise, wasActive);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 connectPromise = promise;</span><br><span class="line">                 requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">                 <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">                 <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                             ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                             ConnectTimeoutException cause =</span><br><span class="line">                                     <span class="keyword">new</span> ConnectTimeoutException(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress);</span><br><span class="line">                             <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                                 close(voidPromise());</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                         <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">                             &#125;</span><br><span class="line">                             connectPromise = <span class="keyword">null</span>;</span><br><span class="line">                             close(voidPromise());</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">             closeIfClosed();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>在这个 conect()  中, 又调用了 doConnect()  方法, 注意，这个方法并不是AbstractNioUnsafe 的方法, 而是AbstractNioChannel的抽象方法, doConnect()    方法是在 NioSocketChannel 中实现的, 因为进入NioSocketChannel的 doConnect()    方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">          doBind0(localAddress);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> connected = javaChannel().connect(remoteAddress);</span><br><span class="line">          <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">              selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">          &#125;</span><br><span class="line">          success = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> connected;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">              doClose();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们终于看到的最关键的代码, 首先是获取Java NIO 的SocketChannel , 获取 NioSocketChannel的 newSocket 返回的SocketChannel  对象,  最后调用 SocketChannel 的connect()   方法完成java NIO 底层的Socket 连接, 最后总结一下, 客户端Bootstrap 发起连接请求的的流程:</p>
<p><img src="http://files.luyanan.com//img/20190926204647.png"> </p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>14e9bd67a584e759133295239250bed1a61e7204</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%9F%BA%E4%BA%8ENetty%E9%87%8D%E6%9E%84RPC%E6%A1%86%E6%9E%B6(4)/" rel="prev" title="基于Netty重构RPC框架(4)">
      <i class="fa fa-chevron-left"></i> 基于Netty重构RPC框架(4)
    </a></div>
      <div class="post-nav-item">
    <a href="/%E6%8F%AD%E5%BC%80ServerBootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1(8)/" rel="next" title="揭开ServerBootstrap的神秘面纱(8)">
      揭开ServerBootstrap的神秘面纱(8) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%AD%E5%BC%80Bootstrap-%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="nav-number">1.</span> <span class="nav-text">揭开Bootstrap 的神秘面纱</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AFBootstrap"><span class="nav-number">1.1.</span> <span class="nav-text">1. 客户端Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Channel%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. Channel简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-NioSocketChannel%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. NioSocketChannel的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AFChannel-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.客户端Channel 的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Unsafe-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. Unsafe 字段的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Pipeline-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. Pipeline 的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-EventLoop%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.6.</span> <span class="nav-text">6. EventLoop的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%AE%9E%E4%BE%8B%E5%8C%96-NioEventLoopGroup%E6%97%B6-%E5%A6%82%E6%9E%9C%E6%8C%87%E5%AE%9A%E4%BA%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F-%E5%88%99nThreads-%E5%B0%B1%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84%E5%80%BC-%E5%8F%8D%E4%B9%8B%E6%98%AF%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8%E5%BF%83%E6%95%B0-2-oba"><span class="nav-number">2.</span> <span class="nav-text">如果我们在实例化 NioEventLoopGroup时, 如果指定了线程池大小, 则nThreads 就是指定的值, 反之是处理器核心数 * 2 oba</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Channel-%E6%B3%A8%E5%86%8C%E5%88%B0Selector"><span class="nav-number">2.0.1.</span> <span class="nav-text">7. Channel 注册到Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Handler-%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">2.0.2.</span> <span class="nav-text">8. Handler 的添加过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">2.0.3.</span> <span class="nav-text">9.  客户端发起连接请求.</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/luyanan0718" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luyanan0718" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/luyanan0718@163.com" title="E-Mail → luyanan0718@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://luyanan.com/" title="https:&#x2F;&#x2F;luyanan.com">Site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
