<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Netty 大动脉Pileline1. Pepeline 设计原理1.1 Channel 与 ChannelPipeline相信大家已经知道了, 在Netty中每个Channel 都有且仅有一个ChannelPipeline 与之对应, 他们的组成关系如下:">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员报社">
<meta property="og:url" content="http://luyanan.com/10.Netty%E5%A4%A7%E5%8A%A8%E8%84%89Pipeline/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="Netty 大动脉Pileline1. Pepeline 设计原理1.1 Channel 与 ChannelPipeline相信大家已经知道了, 在Netty中每个Channel 都有且仅有一个ChannelPipeline 与之对应, 他们的组成关系如下:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20190929092313.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929101344.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929101404.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929105732.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929114633.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929124703.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929134426.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929134625.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929143107.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929145409.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929153135.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929155228.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929160132.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190929163513.png">
<meta property="article:published_time" content="2021-03-01T09:46:51.117Z">
<meta property="article:modified_time" content="2020-12-24T09:34:49.980Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Python, Rust, C++, Go, 爬虫, 深度学习, 服务研发, 对象存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20190929092313.png">

<link rel="canonical" href="http://luyanan.com/10.Netty%E5%A4%A7%E5%8A%A8%E8%84%89Pipeline/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/10.Netty%E5%A4%A7%E5%8A%A8%E8%84%89Pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 17:46:51" itemprop="dateCreated datePublished" datetime="2021-03-01T17:46:51+08:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-24 17:34:49" itemprop="dateModified" datetime="2020-12-24T17:34:49+08:00">2020-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Netty-大动脉Pileline"><a href="#Netty-大动脉Pileline" class="headerlink" title="Netty 大动脉Pileline"></a>Netty 大动脉Pileline</h1><h2 id="1-Pepeline-设计原理"><a href="#1-Pepeline-设计原理" class="headerlink" title="1. Pepeline 设计原理"></a>1. Pepeline 设计原理</h2><h3 id="1-1-Channel-与-ChannelPipeline"><a href="#1-1-Channel-与-ChannelPipeline" class="headerlink" title="1.1 Channel 与 ChannelPipeline"></a>1.1 Channel 与 ChannelPipeline</h3><p>相信大家已经知道了, 在Netty中每个Channel 都有且仅有一个ChannelPipeline 与之对应, 他们的组成关系如下:</p>
<p><img src="http://files.luyanan.com//img/20190929092313.png"></p>
<p>通过上图我们可以看到, 一个Cannel 包含了一个ChannelPipeline,而ChanelPipeline 中又维护了一个由ChannelHandlerContext  组成的双向链表, 这个链表的头是HeadContext, 链表的尾是 TailContext, 并且每个ChannelHandlerContext 中又关联着一个ChannelHandler.</p>
<p>上面的图示给了我们一个对 ChannelPipeline 的直观认识, 但是实际上Netty 实现的 Channel 是否真是这样的呢? 我们继续用源码来说话, 在前我们已经知道了一个Channel 的初始化的基本过程. 下面我们再回顾一下, 下面的代码 AbstractChannel构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.parent = parent;</span><br><span class="line">      id = newId();</span><br><span class="line">      unsafe = newUnsafe();</span><br><span class="line">      pipeline = newChannelPipeline();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AbstractChannel 有一个pipeline 字段,  在构造器中会初始化它为DefaultChannelPipeline的实例, 这里的代码就印证了一点: 每个Channel 都有一个 ChannelPipeline.  接着我们追踪一下 DefaultChannelPipeline的初始化过程. 首先进入到 DefaultChannelPipeline 构造器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DefaultChannelPipeline构造器中, 首先将与之关联的 Channel 保存到 字段 chanel 中, 然后实例化两个 ChannelHandlerContext：一个是HeadContext 的实例head, 另一个 TailContext 实例tail.接着将head和tail 互相指向,构成一个双向链表.</p>
<p>特别注意点是: 我们在开始的示意图中head和tail 并没有包含ChannelHandler, 这里因为  tail 并没有包含 ChannelHandler，这是因为 HeadContext 和 TailContext<br>继承于 AbstractChannelHandlerContext 的同时也实现了 ChannelHandler 接口了，因此它们有 Context 和 Handler<br>的双重属性。</p>
<h3 id="1-2-再谈ChannelPileline-的初始化"><a href="#1-2-再谈ChannelPileline-的初始化" class="headerlink" title="1.2 再谈ChannelPileline 的初始化"></a>1.2 再谈ChannelPileline 的初始化</h3><p>前面我们已经对ChannelPipeline 的初始化有了一个大致的了解, 不过当时重点没有关注ChannelPipeline,因为没有深入的分析它的初始化过程。 那么下面我们就来看一下具体的ChannelPipeline 的初始化都做了哪些工作吧. 先回顾一下, 在实例化一个Channel 时,会伴随着一个ChannelPipeline 的实例化, 并且次Channel 会与这个ChannelPipeline 相互关联, 这一点可以通过 NioSocketChannel 的父类 AbstractChannel的构造器予以佐证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当实例化一个NioSocketChannel  时, 其pipeline 字段就是我们创建的 DefaultChannelPipeline 对象, 那么我们就来看一下 DefaultChannelPipeline的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">     succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">     voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">     head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     head.next = tail;</span><br><span class="line">     tail.prev = head;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 在 DefaultChannelPipeline 的构造方法中，将传入的channel 赋值给字段 this.channel, 接着又实例化了两个特殊的字段, tail与head.这两个字段是一个双向链表的头和尾.  其实在DefaultChannelPipeline 中, 维护了一个以 AbstractChannelHandlerContext 为节点的双向链表, 这个链表是Netty 实现Pipeline 机制的关键, 再回顾一下 head和tail 的类层次结构:</p>
<p><img src="http://files.luyanan.com//img/20190929101344.png"></p>
<p><img src="http://files.luyanan.com//img/20190929101404.png"></p>
<p>从类层次结构图中可以很清楚的看到, head 实现了 ChannelInboundHandler，而tail实现了ChannelOutboundHandler 接口, 并且他们都实现了 ChannelHandlerContext接口, 因此可以说head和tail 即是一个 ChannelHandler，又是一个ChannelHandlerContext.  接着看 HeadContext 构造器的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">         <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">         unsafe = pipeline.channel().unsafe();</span><br><span class="line">         setAddComplete();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>它调用了 父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = false，outbound = true。 而TailContext 的构造器与HeadContext  正好相反 ， 它调用了父类 AbstractChannelHandlerContext的构造器, 并传入参数 inbound = true，outbound = false。 也就是说 header  是一个 OutBoundHandler，而tail是一个 InboundHandler， 关于这一点, 大家要特别注意， 因为在后面的分析中, 我们会反复用到 inbound 和 outbound 这两个属性。</p>
<h3 id="1-3-ChannelInitializer的添加"><a href="#1-3-ChannelInitializer的添加" class="headerlink" title="1.3 ChannelInitializer的添加"></a>1.3 ChannelInitializer的添加</h3><p>前面我们已经分析过了Channel 的组成, 其中我们已经了解过了, 最开始的时候 ChannelPipeline 中含有两个 ChannelHandlerContext（同时也是ChannelHandler),但是这个Pipeline 并不能实现什么特殊的功能, 因为我们还没有给它添加自定义的Channel, 通常来说, 我们在初始化Bootstrap 的时候, 会添加自定义的 ChannelHandler,   就以我们具体的客户端启动代码来举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">           bootstrap.group(group)</span><br><span class="line">                   .channel(NioSocketChannel.class)</span><br><span class="line">                   .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                   .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                           ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> ChatClientHandler(nickName));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的初始化过程， 相信大家都不陌生, 在调用handler时， 传入了ChannelInitializer 对象，它提供了一个initChannel 方法给我们初始化 ChannelHandler,   那么这个初始化过程是怎样的呢? 下面我们来揭开它的神秘面纱, ChannelInitializer 实现了 ChannelHandler，那么它是在什么时候添加到ChannelPipeline 中的呢? 通过代码追踪,我们发现他是在Bootstrap  的init() 方法中添加到ChannelPipeline  中的, 其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     ChannelPipeline p = channel.pipeline();</span><br><span class="line">     p.addLast(config.handler());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">     <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: options.entrySet()) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!channel.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</span><br><span class="line">                     logger.warn(<span class="string">&quot;Unknown channel option: &quot;</span> + e);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 logger.warn(<span class="string">&quot;Failed to set a channel option: &quot;</span> + channel, t);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">     <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">             channel.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码来看, 将handler()  返回的 ChannelHandler 添加到 Pipeline 中, 而 handler()  返回的其实就是我们在初始化Bootstrap    时通过 handler()   方法设置的 ChannelInitializer 实例, 因为这里就是将 ChannelInitializer 插入到了 Pipeline 的末端, 此时Pipeline 的结构如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20190929105732.png"></p>
<p>这时候,有的小伙伴可能就有疑惑了, 我明明插入的是一个 ChannelInitializer 实例, 为什么在 ChannelPipeline 中的双向链表中的元素却是ChannelHandlerContext 呢? 我们继续去源码中寻找答案.</p>
<p>刚才, 我们提到, 在Bootstrap 的init() 方法中会调用p.addLast()  方法,将ChannelInitializer 插入到链表的末端.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">         newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">         addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">         <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">         <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">         <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">             newCtx.setAddPending();</span><br><span class="line">             callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         EventExecutor executor = newCtx.executor();</span><br><span class="line">         <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">             newCtx.setAddPending();</span><br><span class="line">             executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     callHandlerAdded0(newCtx);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     callHandlerAdded0(newCtx);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>addLast() 有很多重载的方法,我们只需要关心这个重要的方法就行. 上面的addLast() 方法中, 首先检查 Channelhandler  的名字是否重复, 如果不重复, 则调用 newContext() 方法为这个Handler 创建一个对应的 DefaultChannelHandlerContext 实例. 并与之关联起来(Contxt  中有一个handler 属性保存着对应的handler 实例). 为了添加一个 handler 到pipeline 中, 必须把此 handler 包装成 ChannelHandlerContext。因此在上面的代码中我们看到新实例化了一个 newCtx 对象,并将handler 作为参数传递到构造方法中,。 那么我们来看一下实例化 DefaultChannelHandlerContext  到底有什么玄机吧, 首先来看一下他的构造器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">          DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">      <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 DefaultChannelHandlerContext  的构造器中, 调用了两个很有意思的方法, isInbound()与 isOutbound()，这两个方法是做什么呢? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInbound</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelInboundHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOutbound</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelOutboundHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到, 当一个hanler 实现了 ChannelInboundHandler 接口, 则 isInbound 返回true,类似的当一个 handler 实现了 ChannelOutboundHandler 接口, 则 isOutbound 就返回true. 而这两个 boolean 变量会传递到父类 AbstractChannelHandlerContext 中, 并初始化父类的这两个字段：inbound 与 outbound。</p>
<p>那么这里的  ChannelInitializer 所对应的 的DefaultChannelHandlerContext的inbound与inbound字段分别是什么呢? 那就看一下  ChannelInitializer  到底实现了哪个接口不就行了? 如下是 ChannelInitializer  的类结构图</p>
<p><img src="http://files.luyanan.com//img/20190929114633.png"></p>
<p>从类图中可以清楚的看到, ChannelInitializer  仅仅实现了 ChannelInboundHandler 接口，因此这里实例化的 DefaultChannelHandlerContext 的 inbound = true，outbound = false。</p>
<p>兜了这么大一圈, 不就是 是 inbound 和 outbound 两个字段嘛， 为什么需要这么大费周折的去分析一番? 其实这两个字段关系到 pipeline 的事件的流向和分类, 因为是十分关键的. 至此, 我们 先记住一个结论. ChannelInitializer   所对应的 DefaultChannelHandlerContext  的  inbound = true，outbound = false。</p>
<p>当创建好 Context 之后, 就将这个Context 插入到 Pipeline的双向链表中, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">      AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">      newCtx.prev = prev;</span><br><span class="line">      newCtx.next = tail;</span><br><span class="line">      prev.next = newCtx;</span><br><span class="line">      tail.prev = newCtx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4-自定义ChannelHandler-的添加过程"><a href="#1-4-自定义ChannelHandler-的添加过程" class="headerlink" title="1.4 自定义ChannelHandler 的添加过程"></a>1.4 自定义ChannelHandler 的添加过程</h3><p>前面我们已经分析过 ChannelInitializer 是如何添加到Pipeline 中的, 接下来就来探究 ChannelInitializer 在哪里被调用? ChannelInitializer 的作用以及我们自定义的ChannelInitializer 是如何插入到Pipeline 中的.</p>
<p>先简单来复习一下 Channel 的注册过程:</p>
<ol>
<li>首先在AbstractBootstrap 的 initAndRegister()  中, 通过group().register(channel) , 调用 MultithreadEventLoopGroup 的 register()  方法.</li>
<li>在 MultithreadEventLoopGroup 的register()   中调用 next()   获取一个可用的 SingleThreadEventLoop，然后调用他的 register()  方法.</li>
<li>在 SingleThreadEventLoop 的 register()   方法中, 通过 channel.unsafe().register(this.promise) 方法获取channel 的 unsafe 底层的IO操作对象, 然后调用它的 register()  方法.</li>
<li>在  AbstractUnsafe 的register()  方法中, 调用 register0() 方法注册channel 对象</li>
<li>在AbstractUnsafe的 register0() 方法中, 调用 AbstractNioChannel 的doRegister() 方法.</li>
<li>AbstractNioChannel 的 doRegister()方法调用 javaChannel().register(eventLoop().selector, 0, this)将 Channel<br>对应的 Java NIO 的 SockerChannel 对象注册到一个 eventLoop 的 Selector 中，并且将当前 Channel 作为 attachment。</li>
</ol>
<p>而我们自定义的ChannelHandler  的添加过程, 发生在 AbstractUnsafe的 register0() 方法中, 在这个方法中调用了 pipeline.fireChannelRegistered()方法, 其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看  AbstractChannelHandlerContext.invokeChannelRegistered(head); 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然, 这个代码会从head开始遍历Pipeline 的双向链表, 然后找到第一个属性 为 true 的<br>ChannelHandlerContext 实例. 想起来没, 我们在前面分析 ChannelInitializer 时， 花费了大量的篇幅来分析了inbound<br>和 outbound 属性 , 现在这里就用上了. 回想一下, ChannelInitializer  实现了 ChannelInboudHandler ,因此他对应的 ChannelHandlerContext 的inbound  属性就是true.  因此这里返回的就是  ChannelInitializer  实例所对应的 ChannelHandlerContext  对象. 如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20190929124703.png"></p>
<p>当获取到 inbound 的Context时，就调用它的 invokeChannelRegistered()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRegistered(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经知道, 每个ChannelHandler 都和一个ChannelHandlerContext 相关联.我们可以通过ChannelHandlerContext 获取到对应的ChannelHandler.因此很明显, 这里的handler() 发那会的对象其实就是一开始我们就实例化的 ChannelInitializer 对象, 并接着调用了 ChannelInitializer 的 channelRegistered() 方法. 看到这里, 应该就会觉得眼熟了. ChannelInitializer 的 channelRegistered()这个方法我们一开始就已经接触到了, 但是我么么并没有深入的分析这个方法的调用过程, 下来我们俩看看这个方法中到底有什么玄机？ 继续看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Normally this method will never be called as handlerAdded(...) should call initChannel(...) and remove</span></span><br><span class="line">    <span class="comment">// the handler.</span></span><br><span class="line">    <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">        <span class="comment">// we called initChannel(...) so we need to call now pipeline.fireChannelRegistered() to ensure we not</span></span><br><span class="line">        <span class="comment">// miss an event.</span></span><br><span class="line">        ctx.pipeline().fireChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Called initChannel(...) before which is the expected behavior, so just forward the event.</span></span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">            <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> initChannel((C) ctx.channel())  这个方法我们也很熟悉, 他就是在我们初始化Bootstrap 的时候, 调用handler 方法传入的匿名内部类所实现的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                           ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                           pipeline.addLast(<span class="keyword">new</span> ChatClientHandler(nickName));</span><br><span class="line">                       &#125;</span><br></pre></td></tr></table></figure>

<p>当调用这个方法后,我们自定义的ChannelHandler 就插入到Pipeline中了, 此时Pipeline 的状态如下图所示：</p>
<p><img src="http://files.luyanan.com//img/20190929134426.png"></p>
<p>当添加完自定义的ChannelHandler 后, 在 finally 代码块中就会删除自定义的 ChannelInitializer，也就是 remove(ctx); 最终调用 ctx.pipeline.remove(this); 因此最后的Pipeline 的状态如下:</p>
<p><img src="http://files.luyanan.com//img/20190929134625.png"></p>
<p>至此, 自定义的ChannelHandler 的添加过程就分析的差不多了.</p>
<h3 id="1-5-给ChannelHandler-命令"><a href="#1-5-给ChannelHandler-命令" class="headerlink" title="1.5. 给ChannelHandler  命令"></a>1.5. 给ChannelHandler  命令</h3><p>不知道大家注意到没, pipeline.addXXX  都有一个重载的方法, 例如 addLast() 它有一个重载的版本是:</p>
<blockquote>
<p>ChannelPipeline addLast(String name, ChannelHandler handler);</p>
</blockquote>
<p>第一个参数指定添加的 handler 的名字,(更加准确的是ChannelHandlerContext的名字),那么handler的名字有什么用呢? 如果我们不设置name, 那么handler默认的名字是怎样的呢? 带着这些疑问? 我们依旧去源代码去找答案, 还是以addLast() 方法为例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addFirst(<span class="keyword">null</span>, name, handler);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法会调用重载的 addLast()  方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           checkMultiplicity(handler);</span><br><span class="line">           name = filterName(name, handler);</span><br><span class="line"></span><br><span class="line">           newCtx = newContext(group, name, handler);</span><br><span class="line"></span><br><span class="line">           addFirst0(newCtx);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">           <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">           <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">           <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">               newCtx.setAddPending();</span><br><span class="line">               callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           EventExecutor executor = newCtx.executor();</span><br><span class="line">           <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">               newCtx.setAddPending();</span><br><span class="line">               executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       callHandlerAdded0(newCtx);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       callHandlerAdded0(newCtx);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数被设置为null, 我们不需要去关心它, 第二个参数就是这个handler的名字, 看代码可知, 在添加一个handler之前, 需要调用 checkMultiplicity(handler) 方法来确定新添加的handler 名字是否与已经添加的handler 的名字重复.</p>
<h3 id="1-6-ChannelHandler-默认命名规则"><a href="#1-6-ChannelHandler-默认命名规则" class="headerlink" title="1.6 ChannelHandler 默认命名规则"></a>1.6 ChannelHandler 默认命名规则</h3><p>如果我们调用的是如下的addLast()  方法</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline addLast(ChannelHandler... handlers);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>那么Netty 就会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">filterName</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> generateName(handler);</span><br><span class="line">       &#125;</span><br><span class="line">       checkDuplicateName(name);</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateName</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">       Map&lt;Class&lt;?&gt;, String&gt; cache = nameCaches.get();</span><br><span class="line">       Class&lt;?&gt; handlerType = handler.getClass();</span><br><span class="line">       String name = cache.get(handlerType);</span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">           name = generateName0(handlerType);</span><br><span class="line">           cache.put(handlerType, name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// It&#x27;s not very likely for a user to put more than one handler of the same type, but make sure to avoid</span></span><br><span class="line">       <span class="comment">// any name conflicts.  Note that we don&#x27;t cache the names generated here.</span></span><br><span class="line">       <span class="keyword">if</span> (context0(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           String baseName = name.substring(<span class="number">0</span>, name.length() - <span class="number">1</span>); <span class="comment">// Strip the trailing &#x27;0&#x27;.</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i ++) &#123;</span><br><span class="line">               String newName = baseName + i;</span><br><span class="line">               <span class="keyword">if</span> (context0(newName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   name = newName;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而  generateName() 方法会接着调用 generateName0()  方法来实际生成一个新的handler 名字:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateName0</span><span class="params">(Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> StringUtil.simpleClassName(handlerType) + <span class="string">&quot;#0&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>默认的命名规则很简单, 就是反射获取handler 的simpleClassName 加上 “#0”, 因为我们的自定义ChatClientHandler 的名字就是 “ChatClientHandler#0”</p>
<h2 id="2-Pipeline-的事件传播机制"><a href="#2-Pipeline-的事件传播机制" class="headerlink" title="2. Pipeline 的事件传播机制"></a>2. Pipeline 的事件传播机制</h2><p>我们已经知道 AbstractChannelHandlerContext 中有 inbound 和 outbound 两个 boolean 变量,分别用于标识 Context 所对应的handler 类型, 即:</p>
<ol>
<li> inbound 为true时表示其对应的 ChannelHandler 是 ChannelInboundHandler的子类.</li>
<li>outbound 为true时，表示对应的ChannelHandler 是 ChannelOutboundHandler 的子类.</li>
</ol>
<p>这里大家肯定还有很多疑惑 , 不知道这两个字段到底有什么用? 这还要从ChannelPipeline  的事件传播机制说起， Netty 的事件传播机制可以分为两种: inbound 事件和outbound 事件, 如下是从Netty 对这两个事件的说明;‘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">* &lt;pre&gt;</span><br><span class="line">*                                                 I/O Request</span><br><span class="line">*                                            via &#123;<span class="meta">@link</span> Channel&#125; or</span><br><span class="line">*                                        &#123;<span class="meta">@link</span> ChannelHandlerContext&#125;</span><br><span class="line">*                                                      |</span><br><span class="line">*  +---------------------------------------------------+---------------+</span><br><span class="line">*  |                           ChannelPipeline         |               |</span><br><span class="line">*  |                                                  \|/              |</span><br><span class="line">*  |    +---------------------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  N  |            | Outbound Handler  <span class="number">1</span>  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler N-<span class="number">1</span> |            | Outbound Handler  <span class="number">2</span>  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  .               |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">*  |        [ method call]                       [method call]         |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  |               .                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  <span class="number">2</span>  |            | Outbound Handler M-<span class="number">1</span> |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  <span class="number">1</span>  |            | Outbound Handler  M  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*                  |                                  \|/</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*  |               |                                   |               |</span><br><span class="line">*  |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">*  |                                                                   |</span><br><span class="line">*  |  Netty Internal I/<span class="function">O <span class="title">Threads</span> <span class="params">(Transport Implementation)</span>            |</span></span><br><span class="line"><span class="function">*  +-------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>



<p>从上图可以看出, inbound  事件和outbound 事件 的流向是不一样的, inbound 事件的流行是从下往上的, 而 outbound 刚好相反, 是从上到下的. 并且 inbound 的传递方式是通过调用相应的ChannelHandlerContext.fireIN_EVT()方法，而 outbound 方法的传递方式是调用 ChannelHandlerContext.OUT_EVT()方法。例如：ChannelHandlerContext<br>的 fireChannelRegistered()调用会发送一个 ChannelRegistered 的 inbound 给下一个 ChannelHandlerContext，而<br>ChannelHandlerContext 的 bind()方法调用时会发送一个 bind 的 outbound 事件给下一个 ChannelHandlerContext</p>
<p><strong>inbound 事件传播的方法有：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; was registered with its &#123;<span class="doctag">@link</span> EventLoop&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; was unregistered from its &#123;<span class="doctag">@link</span> EventLoop&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; is now active</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; was registered is now inactive and reached its</span></span><br><span class="line"><span class="comment">     * end of lifetime.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the current &#123;<span class="doctag">@link</span> Channel&#125; has read a message from the peer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the last message read by the current read operation has been consumed by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #channelRead(ChannelHandlerContext, Object)&#125;.  If &#123;<span class="doctag">@link</span> ChannelOption#AUTO_READ&#125; is off, no further</span></span><br><span class="line"><span class="comment">     * attempt to read an inbound data from the current &#123;<span class="doctag">@link</span> Channel&#125; will be made until</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ChannelHandlerContext#read()&#125; is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called if an user event was triggered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called once the writable state of a &#123;<span class="doctag">@link</span> Channel&#125; changed. You can check the state with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Channel#isWritable()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called if a &#123;<span class="doctag">@link</span> Throwable&#125; was thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>outbound 事件传播方法有：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelOutboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called once a bind operation is made.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx           the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the bind operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localAddress  the &#123;<span class="doctag">@link</span> SocketAddress&#125; to which it should bound</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise       the &#123;<span class="doctag">@link</span> ChannelPromise&#125; to notify once the operation completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception    thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called once a connect operation is made.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx               the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the connect operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAddress     the &#123;<span class="doctag">@link</span> SocketAddress&#125; to which it should connect</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localAddress      the &#123;<span class="doctag">@link</span> SocketAddress&#125; which is used as source on connect</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise           the &#123;<span class="doctag">@link</span> ChannelPromise&#125; to notify once the operation completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception        thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called once a disconnect operation is made.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx               the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the disconnect operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise           the &#123;<span class="doctag">@link</span> ChannelPromise&#125; to notify once the operation completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception        thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called once a close operation is made.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx               the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the close operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise           the &#123;<span class="doctag">@link</span> ChannelPromise&#125; to notify once the operation completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception        thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called once a deregister operation is made from the current registered &#123;<span class="doctag">@link</span> EventLoop&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx               the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the close operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise           the &#123;<span class="doctag">@link</span> ChannelPromise&#125; to notify once the operation completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception        thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Intercepts &#123;<span class="doctag">@link</span> ChannelHandlerContext#read()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called once a write operation is made. The write operation will write the messages through the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ChannelPipeline&#125;. Those are then ready to be flushed to the actual &#123;<span class="doctag">@link</span> Channel&#125; once</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Channel#flush()&#125; is called</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx               the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the write operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg               the message to write</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise           the &#123;<span class="doctag">@link</span> ChannelPromise&#125; to notify once the operation completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception        thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called once a flush operation is made. The flush operation will try to flush out all previous written messages</span></span><br><span class="line"><span class="comment">     * that are pending.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx               the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; for which the flush operation is made</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception        thrown if an error accour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大家应该发现了规律, inbound 类似于的事件回调(响应请求的事件),而outbound 类似于主动触发(发起请求的事件) . 注意,如果我们捕获了一个事件, 并想让这个事件继续传递下去, 那么需要调用Context 对应的传播方法 fireXX, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上面的代码, MyInboundHandler 收到了一个 channelActive 事件, 他在处理完成后, 如果希望将事件继续传播下去, 那么需要接着调用 ctx.fireChannelActive();方法.</p>
<h3 id="2-1-Outbound-事件传播方式"><a href="#2-1-Outbound-事件传播方式" class="headerlink" title="2.1 Outbound 事件传播方式"></a>2.1 Outbound 事件传播方式</h3><p>outbound  事件都是请求事件(request event), 即请求某些事件的发生, 然后通过Outbound 事件进行通知, </p>
<p>outbound 事件的传播方向是:  tail -&gt;customContext -&gt;head.</p>
<p>我们接下来以 connect事件为例, 分析一下 Outbound 事件的传播机制。</p>
<p>首先, 当用户调用了 Bootstrap 的 connect() 方法时, 就会触发一个Connect 请求事件, 此调用会出发如下调用链:</p>
<p><img src="http://files.luyanan.com//img/20190929143107.png"></p>
<p>继续追踪, 我们就会发现 AbstractChannel的connect()  其实调用了 DefaultChannelPipeline 的connect()  方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而  pipeline.connect(remoteAddress, localAddress, promise） 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 当outbound(这里是 connect事件) 传递到Pipeline 后, 它其实是以tail 为起点开始传播的.</p>
<p>而 tail.connect 其实调用的是 AbstractChannelHandlerContext 的 connect()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// cancelled</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findContextOutbound() 方法顾名思义, 他的作用是以当前Context 为起点, 想Pipeline 中的Context 双向链表的前端寻找第一个 outbound  属性为true 的Context(即关联ChannelOutboundHandler的Context), 然后返回.</p>
<p> findContextOutbound 的方法的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!ctx.outbound);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们找到一个 outbound 的Context后， 就调用它的 invokeConnect() 方法, 这个方法中会调用Context 其关联的ChannelHandler 的connect()  方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).connect(<span class="keyword">this</span>, remoteAddress, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户没有重写 ChannelHandler 的 connect()  方法, 那么就会调用 ChannelOutboundHandlerAdapter 的 connect()<br>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">         SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到， ChannelOutboundHandlerAdapter 的connect() 仅仅调用了 ctx.connect , 而这个又调回到了Context.connect -&gt; Connect.findContextOutbound -&gt; next.invokeConnect -&gt; handler.connect -&gt; Context.connect<br>这样的循环中，直到connect()  事件传递到了  DefaultChannelPipeline 的双向链表的头节点, 即head中,为什么会传递到head中呢? 回想一下, head实现了  ChannelOutboundHandler，因此它的outbound 的属性是true</p>
<p>因为head本身即是一个 ChannelHandlerContext，又实现了ChannelOutboundHandler 接口, 因此当 connect()  消息传递到head后, 会将消息转传递到对应的ChannelHandler 中处理, 而head的 handler() 方法返回的就是head本身.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>因此 最终 connect()  事件是在head中被处理的, head的 connect() 事件处理逻辑如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">           SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">           ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>到这里, 整个connect()  请求事件就结束了, 下图中描述了整个 connect()  请求事件的处理过程.</p>
<p><img src="http://files.luyanan.com//img/20190929145409.png"></p>
<p>我们仅仅以 connect()  请求事件为例, 分析了 outbound 事件的传播过程, 但是其实所有的 outbound 事件的传播都遵循一样的传播规律, </p>
<h3 id="2-2-inbound-事件传播方式"><a href="#2-2-inbound-事件传播方式" class="headerlink" title="2.2 inbound 事件传播方式"></a>2.2 inbound 事件传播方式</h3><p>inbound 事件和 outbound 事件的处理过程是类似的, 只不过传播方向不同.</p>
<p>inbound 事件是一个通知事件,即某事件已经发生了, 然后通过inbound 事件进行通知， inbound 通常发生在Channel 的状态的改变或者IO事件就绪.</p>
<p>inboud 的特点是它的传播方向 是 head -&gt; customContext -&gt; tail。</p>
<p>上面我们分析了 connect()  这个outbound 事件, 那么接着分析  connect()  事件后会发生什么 inbound 事件, 并最终找到  inbound 和outbound 事件的联系. 当 connect() 这个outbound 传播到 unsafe 后, 其实是在 AbstractNioUnsafe 的connect() 方法中进行处理的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// Already a connect in process.</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">              <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">                  fulfillConnectPromise(promise, wasActive);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  connectPromise = promise;</span><br><span class="line">                  requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">                  <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">                  <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                              ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                              ConnectTimeoutException cause =</span><br><span class="line">                                      <span class="keyword">new</span> ConnectTimeoutException(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress);</span><br><span class="line">                              <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                                  close(voidPromise());</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                          <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">                              &#125;</span><br><span class="line">                              connectPromise = <span class="keyword">null</span>;</span><br><span class="line">                              close(voidPromise());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">              closeIfClosed();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在 AbstractNioUnsafe 的 connect() 方法中, 首先调用doConnect()   方法进行实际上的Socket连接, 当连接上后会调用 fulfillConnectPromise() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (promise == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Closed via cancellation and the promise has been notified already.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span></span><br><span class="line">           <span class="comment">// We still need to ensure we call fireChannelActive() in this case.</span></span><br><span class="line">           <span class="keyword">boolean</span> active = isActive();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// trySuccess() will return false if a user cancelled the connection attempt.</span></span><br><span class="line">           <span class="keyword">boolean</span> promiseSet = promise.trySuccess();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span></span><br><span class="line">           <span class="comment">// because what happened is what happened.</span></span><br><span class="line">           <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">               pipeline().fireChannelActive();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If a user cancelled the connection attempt, close the channel, which is followed by channelInactive().</span></span><br><span class="line">           <span class="keyword">if</span> (!promiseSet) &#123;</span><br><span class="line">               close(voidPromise());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到,在fulfillConnectPromise() 中, 会通过调用 pipeline().fireChannelActive() 方法将通道激活的消息(即Socket 连接成功) 发送出去, 而这里, 当调用 pipeline.fireXXX 后, 就是 inbound 事件的起点, 因此当调用  pipeline().fireChannelActive(); 后， 就产生了一个 ChannelActive  inbound 事件, 我们就从这里看这个 inbound 事件是怎么传播的?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然在 fireChannelActive 方法中, 调用的是 head.invokeChannelActive()  , 因此可以证明 inbound 事件在Pipeline 中的传输的起点是 head,那么在 head.invokeChannelActive()  中又做了什么呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码应该很熟悉了, 回想一下, 在outbound 事件(例如connect() 事假 )的传输过程 中, 我们也有类似的操作.</p>
<ol>
<li><p>首先调用 findContextInbound() , 从Pipeline 的双向链表中找到第一个属性inbound 为true 的Context, 然后将其返回.</p>
</li>
<li><p>调用Context的invokeChannelActive() 方法, invokeChannelActive 方法的源码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ((ChannelInboundHandler) handler()).channelActive(<span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              notifyHandlerException(t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          fireChannelActive();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法和Outbound 的对应方法(如：invokeConnect()方法) 如出一辙, 与outbound 一样, 如果用户没有重写channelActive()  方法,那么就会调用 ChannelInboundHandlerAdapter 的 channelActive()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地, 在 ChannelInboundHandlerAdapter 的 channelActive()中，仅仅调用了 ctx.fireChannelActive()方法，因此就<br>会进入 Context.fireChannelActive() -&gt; Connect.findContextInbound() -&gt; nextContext.invokeChannelActive() -&gt;<br>nextHandler.channelActive() -&gt; nextContext.fireChannelActive()这样的循环中。同理，tail 本身既实现了<br>ChannelInboundHandler 接口，又实现了 ChannelHandlerContext 接口，因此当 channelActive()消息传递到 tail 后，<br>会将消息转递到对应的 ChannelHandler 中处理，而 tail 的 handler()返回的就是 tail 本身：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>因此， channelActive 的  inbound 事件最终是在tail 中处理的， 我们看一下他的处理方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>TailContext 的 channelActive()  方法是空的, 如果大家自行查看 TailContext 的inbound 处理方法的时候就会发现，他们的实现都是空的, 可见, 如果是inbound, 当用户没有实现自定义的处理器时, 那么默认是不处理的. 下图描述了inbound 事件的传输过程.</p>
<p><img src="http://files.luyanan.com//img/20190929153135.png"></p>
<h3 id="2-3-Pipeline-事件传播小结"><a href="#2-3-Pipeline-事件传播小结" class="headerlink" title="2.3 Pipeline 事件传播小结"></a>2.3 Pipeline 事件传播小结</h3><h4 id="outbound-事件总结"><a href="#outbound-事件总结" class="headerlink" title="outbound 事件总结:"></a>outbound 事件总结:</h4><ol>
<li>OutBound 事件是请求事件(由 connect() 发起一个请求, 并最终由 unsafe 处理这个请求)</li>
<li>outbound   事件的发起者是 Channel</li>
<li>Outbound 事件的处理者是 unsafe</li>
<li>outbound  事件在Pipeline 中的传播方向是 tail -&gt; head.</li>
<li>在ChannelHandler 中处理事件时,如果这个handler 不是最后一个handler, 则需要调用 ctx 的方法(如ctx.connect()) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播就会提前终止.</li>
<li>Outbound 事件流：Context.OUT_EVT() -&gt; Connect.findContextOutbound() -&gt; nextContext.invokeOUT_EVT() -&gt; nextHandler.OUT_EVT() -&gt; nextContext.OUT_EVT()</li>
</ol>
<h4 id="inbound-事件总结"><a href="#inbound-事件总结" class="headerlink" title="inbound 事件总结"></a>inbound 事件总结</h4><ol>
<li>inbound 事件是通知事件, 当某件事情已经就绪后, 通知上层.</li>
<li>inbound 事件发起者是 unsafe</li>
<li>inbound 事件处理者是Channel, 如果没有实现自定义的处理方法, 那么inbound 事件默认的处理者是TailContext, 并且其处理方法是空实现.</li>
<li>inbound 事件在 pipeline 中传输方向是head -&gt;tail</li>
<li>在 ChannelHandler 中处理事件时，如果这个 Handler 不是最后一个 Handler，则需要调用 ctx.fireIN_EVT()事<br>件（如：ctx.fireChannelActive()方法）将此事件继续传播下去。如果不这样做，那么此事件的传播会提前终止。</li>
<li>Outbound 事件流：Context.fireIN_EVT() -&gt; Connect.findContextInbound() -&gt; nextContext.invokeIN_EVT() -&gt;<br>nextHandler.IN_EVT() -&gt; nextContext.fireIN_EVT().</li>
</ol>
<p>outbound  和inbound 事件设计上十分相似, 并且Context 与Handler 直接的调用关系也容易混淆,因此我们在阅读这里的源码时, 需要特别的注意.</p>
<h2 id="3-Handler-的各种姿势"><a href="#3-Handler-的各种姿势" class="headerlink" title="3. Handler 的各种姿势"></a>3. Handler 的各种姿势</h2><h3 id="1-ChannelHandlerContext"><a href="#1-ChannelHandlerContext" class="headerlink" title="1. ChannelHandlerContext"></a>1. ChannelHandlerContext</h3><p>每个ChannelHandler 被添加到ChannelPipeline 后,都会创建一个 ChannelHandlerContext  并与之创建的ChannelHandler  关联绑定, ChannelHandlerContext 允许 ChannelHandler 与其他的 ChannelHander  实现进行交互, ChannelHandlerContext 不会改变添加到其中的 ChannelHandler, 因此它是安全的. 下图描述了 ChannelHandlerContext、ChannelHandler、ChannelPipeline 的关系.</p>
<p><img src="http://files.luyanan.com//img/20190929155228.png"></p>
<h3 id="2-Channel-的生命周期"><a href="#2-Channel-的生命周期" class="headerlink" title="2. Channel 的生命周期"></a>2. Channel 的生命周期</h3><p>Netty 有一个简单但很强大的状态模型, 并完美映射到 ChannelInboundHandler 的各个方法上, 下面是Channel 的生命周期中的四个不同的状态.</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>channelUnregistered()</td>
<td>Channel 已创建, 还未注册到一个EventLoop</td>
</tr>
<tr>
<td>channelRegistered()</td>
<td>Channel  已经注册到一个EventLoop</td>
</tr>
<tr>
<td>channelActive()</td>
<td>Channel 是活跃状态(连接到某个远端) 可以收发数据</td>
</tr>
<tr>
<td>channelInactive()</td>
<td>Channel 未连接到远端</td>
</tr>
</tbody></table>
<p>一个Channel 正常的生命周期如下图所示, 随着状态发生变化相应的事件产生, 这些事件被转发到ChannePipeline 中的ChannelHandler  来触发相应的操作.</p>
<p><img src="http://files.luyanan.com//img/20190929160132.png"></p>
<h3 id="3-ChannelHandler-常用的API"><a href="#3-ChannelHandler-常用的API" class="headerlink" title="3. ChannelHandler 常用的API"></a>3. ChannelHandler 常用的API</h3><p>先看一个Netty 中整个Handler 体系的类关系图</p>
<p><img src="http://files.luyanan.com//img/20190929163513.png"></p>
<p>Netty 定义了良好的类型层次结构来标识不同的处理程序类型, 所有的类型的父类是ChannelHandler. ChannelHandler 提供了在其生命周期中添加或从ChannelPipeline 中删除的方法.</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>handlerAdded()</td>
<td>ChannelHandler 添加到实际上下文汇中准备处理事件</td>
</tr>
<tr>
<td>handlerRemoved()</td>
<td>将ChannelHandler 从实际上下文中删除, 不在处理事件</td>
</tr>
<tr>
<td>exceptionCaught()</td>
<td>处理抛出的异常</td>
</tr>
</tbody></table>
<p>Netty 还提供了一个实现了ChannelHandler 的抽象类ChannelHandlerAdapter。ChannelHandlerAdapter 实现了父类的所有方法, 基本上就是传递事件到ChannelPipeline 中的下一个ChannelHandler  直到结束. 我们也可以直接继承于ChannelHandlerAdapter ,然后重写里面的方法.</p>
<h3 id="4-ChannelInboundHandler"><a href="#4-ChannelInboundHandler" class="headerlink" title="4 ChannelInboundHandler"></a>4 ChannelInboundHandler</h3><p>ChannelInboundHandler  提供了一些方法再接受或者Channel 状态改变时被调用, 下面是 ChannelInboundHandler 的一些方法:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>channelRegistered()</td>
<td>ChannelHandlerContext的Channel被注册到EventLoop</td>
</tr>
<tr>
<td>channelUnregistered()</td>
<td>ChannelHandlerContext的Channel从EventLoop中注销</td>
</tr>
<tr>
<td>channelActive()</td>
<td>ChannelHandlerContext的Channel已激活</td>
</tr>
<tr>
<td>channelInactive</td>
<td>ChannelHanderContxt的Channel结束生命周期</td>
</tr>
<tr>
<td>channelRead</td>
<td>从当前Channel的对端读取消息</td>
</tr>
<tr>
<td>channelReadComplete</td>
<td>消息读取完成后执行</td>
</tr>
<tr>
<td>userEventTriggered</td>
<td>一个用户事件被触发</td>
</tr>
<tr>
<td>channelWritabilityChanged</td>
<td>改变通道的可写状态，可以使用Channel.isWritable()检查</td>
</tr>
<tr>
<td>exceptionCaught</td>
<td>重写父类ChannelHandler的方法，处理异常</td>
</tr>
</tbody></table>
<p>Netty 提供了一个实现了 ChannelInboundHandler 接 口 并 继 承 ChannelHandlerAdapter 的 类 ：<br>ChannelInboundHandlerAdapter。ChannelInboundHandlerAdapter 实现了 ChannelInboundHandler 的所有方法，<br>作用就是处理消息并将消息转发到 ChannelPipeline 中的下一个 ChannelHandler。ChannelInboundHandlerAdapter<br>的 channelRead() 方 法 处 理 完 消 息 后 不 会 自 动 释 放 消 息 ， 若 想 自 动 释 放 收 到 的 消 息 ， 可 以 使 用<br>SimpleChannelInboundHandler，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreleaseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//手动释放消息</span></span><br><span class="line">       ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleChannelInboundHandler 会自动释放消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReleaseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="comment">//不需要手动释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelInitializer 用来初始化 ChannelHandler，将自定义的各种 ChannelHandler 添加到 ChannelPipeline 中。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/1.%20Java%20IO%20%20%20%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/11.Promise%20%E4%B8%8E%20Future%20%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty-%E5%A4%A7%E5%8A%A8%E8%84%89Pileline"><span class="nav-number">1.</span> <span class="nav-text">Netty 大动脉Pileline</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Pepeline-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">1. Pepeline 设计原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Channel-%E4%B8%8E-ChannelPipeline"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 Channel 与 ChannelPipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%86%8D%E8%B0%88ChannelPileline-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 再谈ChannelPileline 的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-ChannelInitializer%E7%9A%84%E6%B7%BB%E5%8A%A0"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 ChannelInitializer的添加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%87%AA%E5%AE%9A%E4%B9%89ChannelHandler-%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 自定义ChannelHandler 的添加过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E7%BB%99ChannelHandler-%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5. 给ChannelHandler  命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-ChannelHandler-%E9%BB%98%E8%AE%A4%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6 ChannelHandler 默认命名规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Pipeline-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.</span> <span class="nav-text">2. Pipeline 的事件传播机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Outbound-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 Outbound 事件传播方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-inbound-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 inbound 事件传播方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Pipeline-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E5%B0%8F%E7%BB%93"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 Pipeline 事件传播小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#outbound-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">outbound 事件总结:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inbound-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">inbound 事件总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Handler-%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF"><span class="nav-number">1.3.</span> <span class="nav-text">3. Handler 的各种姿势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ChannelHandlerContext"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. ChannelHandlerContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Channel-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. Channel 的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ChannelHandler-%E5%B8%B8%E7%94%A8%E7%9A%84API"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. ChannelHandler 常用的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ChannelInboundHandler"><span class="nav-number">1.3.4.</span> <span class="nav-text">4 ChannelInboundHandler</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">214</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
