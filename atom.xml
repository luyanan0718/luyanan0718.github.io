<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员报社</title>
  
  <subtitle>程序员报社</subtitle>
  <link href="http://luyanan.com/atom.xml" rel="self"/>
  
  <link href="http://luyanan.com/"/>
  <updated>2020-12-24T09:34:50.101Z</updated>
  <id>http://luyanan.com/</id>
  
  <author>
    <name>luyanan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/Spring%20Boot%20%E5%87%BA%E7%8E%B0Failed%20to%20decode%20downloaded%20font%E5%92%8COTS%20parsing%20error%20Failed%20to%20convert%20WOFF%202.0%20font%20to%20SFNT/"/>
    <id>http://luyanan.com/Spring%20Boot%20%E5%87%BA%E7%8E%B0Failed%20to%20decode%20downloaded%20font%E5%92%8COTS%20parsing%20error%20Failed%20to%20convert%20WOFF%202.0%20font%20to%20SFNT/</id>
    <published>2021-03-01T09:46:53.003Z</published>
    <updated>2020-12-24T09:34:50.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-出现”Failed-to-decode-downloaded-font”和”OTS-parsing-error-Failed-to-convert-WOFF-2-0-font-to-SFNT”"><a href="#Spring-Boot-出现”Failed-to-decode-downloaded-font”和”OTS-parsing-error-Failed-to-convert-WOFF-2-0-font-to-SFNT”" class="headerlink" title="Spring Boot 出现”Failed to decode downloaded font”和”OTS parsing error: Failed to convert WOFF 2.0 font to SFNT”"></a>Spring Boot 出现”Failed to decode downloaded font”和”OTS parsing error: Failed to convert WOFF 2.0 font to SFNT”</h1><p>准确来讲，应该是maven项目使用Bootstrap时，出现</p><p>“<strong>Failed to decode downloaded font</strong>“和”<strong>OTS parsing error: Failed to convert WOFF 2.0 font to SFNT</strong>“</p><p>导致图标出不来的问题。</p><p>解决方案：</p><p>设置filter，font文件不需要filter，见下面示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>static/fonts/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>static/fonts/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原因：</p><p>上面的xml里也写了，因为经过maven的filter，会破坏font文件的二进制文件格式，到时前台解析出错。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Boot-出现”Failed-to-decode-downloaded-font”和”OTS-parsing-error-Failed-to-convert-WOFF-2-0-font-to-SFNT”&quot;&gt;&lt;a href=&quot;#Spring-Boot-出现”Failed-to-decode-downloaded-font”和”OTS-parsing-error-Failed-to-convert-WOFF-2-0-font-to-SFNT”&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 出现”Failed to decode downloaded font”和”OTS parsing error: Failed to convert WOFF 2.0 font to SFNT”&quot;&gt;&lt;/a&gt;Spring Boot 出现”Failed to decode downloaded font”和”OTS parsing error: Failed to convert WOFF 2.0 font to SFNT”&lt;/h1&gt;&lt;p&gt;准确来讲，应该是maven项目使用Bootstrap时，出现&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;Failed to decode downloaded font&lt;/strong&gt;“和”&lt;strong&gt;OTS parsing error: Failed to convert WOFF 2.0 font to SFNT&lt;/strong&gt;“&lt;/p&gt;
&lt;p&gt;导致图标出不来的问题。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/elasticsratch%E9%97%AE%E9%A2%98/"/>
    <id>http://luyanan.com/elasticsratch%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-01T09:46:52.995Z</published>
    <updated>2020-12-24T09:34:50.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least"><a href="#max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least" class="headerlink" title="max virtual memory areas vm.max_map_count [65530] is too low, increase to at least "></a><code>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least </code></h2><p>修改/etc/sysctl.conf文件，增加配置vm.max_map_count=262144</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>　执行命令sysctl -p生效</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>新建用户，每台服务器都要新建，ES不允许root用户运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd elsearch                                    新增elsearch用户组</span><br><span class="line">useradd elsearch -g elsearch -p elasticsearch        创建elsearch用户</span><br><span class="line">chown -R elsearch:elsearch ./elasticsearch-6.6.1     用户目录权限</span><br></pre></td></tr></table></figure><p>3.切换到elsearch用户下，启动ES</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su elsearch</span><br><span class="line">cd /opt/dp/elasticsearch-6.6.1/bin</span><br><span class="line">./elasticsearch &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least&quot;&gt;&lt;a href=&quot;#max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least&quot; class=&quot;headerlink&quot; title=&quot;max virtual memory areas vm.max_map_count [65530] is too low, increase to at least &quot;&gt;&lt;/a&gt;&lt;code&gt;max virtual memory areas vm.max_map_count [65530] is too low, increase to at least &lt;/code&gt;&lt;/h2&gt;&lt;p&gt;修改/etc/sysctl.conf文件，增加配置vm.max_map_count=262144&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vi &amp;#x2F;etc&amp;#x2F;sysctl.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysctl -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;　执行命令sysctl -p生效&lt;/p&gt;
&lt;h2 id=&quot;创建用户&quot;&gt;&lt;a href=&quot;#创建用户&quot; class=&quot;headerlink&quot; title=&quot;创建用户&quot;&gt;&lt;/a&gt;创建用户&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/CENTOS%207%20%E5%92%8C%20JDK%20%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/"/>
    <id>http://luyanan.com/CENTOS%207%20%E5%92%8C%20JDK%20%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/</id>
    <published>2021-03-01T09:46:52.988Z</published>
    <updated>2020-12-24T09:34:50.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CENTOS-7-和-JDK-添加中文字体"><a href="#CENTOS-7-和-JDK-添加中文字体" class="headerlink" title="CENTOS 7 和 JDK 添加中文字体"></a>CENTOS 7 和 JDK 添加中文字体</h1><p>【1】在我们的 Windows 的 <strong>C:\Windows\Fonts</strong> 下面选择一个中文字体，如宋体，先拷贝到桌面，然后字体就变成了英文的：*<strong>*SIMSUN.TTC**</strong></p><p> <img src="https://img2018.cnblogs.com/blog/979767/201809/979767-20180920164849487-905318821.png" alt="img"></p><p>备注：我这里只是写了 Windows 的，没有用过 Mac 系列的 …</p><p> 【2】在服务器上面建立相关目录，为了便于区分，我们把目录名字叫做 <strong><em>\</em>zh_CN**</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;zh_CN</span><br></pre></td></tr></table></figure><p> 【3】上传我们的字体到该目录下并改名为 <strong>simsun.ttf</strong>，上传可以在 CENTOS 上面 <strong>yum 安装 lrzsz</strong>，之后我们就能直接敲 <strong><em>\</em>rz**</strong> 命令或者拖拽进行交互式上传文件了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;zh_CN</span><br><span class="line">mv SIMSUN.TTC simsun.ttf</span><br></pre></td></tr></table></figure><p> 【4】收集系统的字体，保存到相关文件，此时会在当前目录生成 <strong>fonts.scale</strong> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ttmkfdir</span><br><span class="line">ttmkfdir -e &#x2F;usr&#x2F;share&#x2F;X11&#x2F;fonts&#x2F;encodings&#x2F;encodings.dir</span><br></pre></td></tr></table></figure><p>【5】为了不重启机器，我们手动添加配置，强迫症顺便还帮他调整了一下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;fonts&#x2F;fonts.conf</span><br><span class="line"></span><br><span class="line"># 内容如下</span><br><span class="line">&lt;dir&gt;&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;zh_CN&lt;&#x2F;dir&gt;</span><br></pre></td></tr></table></figure><h1 id="给JDK添加中文字体"><a href="#给JDK添加中文字体" class="headerlink" title="给JDK添加中文字体"></a>给JDK添加中文字体</h1><p> 由于 JDK 添加中文字体比较简单，这里就直接给出方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 进入 JDK 的目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;jdk1.7.0_79&#x2F;jre&#x2F;lib&#x2F;fonts</span><br><span class="line">yum install mkfontscale</span><br><span class="line">yum install fontconfig</span><br><span class="line"># 创建目录</span><br><span class="line">mkdir fallback</span><br><span class="line">cd fallback</span><br><span class="line"></span><br><span class="line"># 将公共系统那个中文字体拷贝过来</span><br><span class="line">cp &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;zh_CN&#x2F;simsun.ttf .</span><br><span class="line"></span><br><span class="line"># 生效</span><br><span class="line">mkfontscale</span><br><span class="line">mkfontdi</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CENTOS-7-和-JDK-添加中文字体&quot;&gt;&lt;a href=&quot;#CENTOS-7-和-JDK-添加中文字体&quot; class=&quot;headerlink&quot; title=&quot;CENTOS 7 和 JDK 添加中文字体&quot;&gt;&lt;/a&gt;CENTOS 7 和 JDK 添加中文字体&lt;/h1&gt;&lt;p&gt;【1】在我们的 Windows 的 &lt;strong&gt;C:\Windows\Fonts&lt;/strong&gt; 下面选择一个中文字体，如宋体，先拷贝到桌面，然后字体就变成了英文的：*&lt;strong&gt;*SIMSUN.TTC**&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/979767/201809/979767-20180920164849487-905318821.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;备注：我这里只是写了 Windows 的，没有用过 Mac 系列的 …&lt;/p&gt;
&lt;p&gt; 【2】在服务器上面建立相关目录，为了便于区分，我们把目录名字叫做 &lt;strong&gt;&lt;em&gt;\&lt;/em&gt;zh_CN**&lt;/strong&gt;：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1/"/>
    <id>http://luyanan.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-03-01T09:46:52.979Z</published>
    <updated>2020-12-24T09:34:50.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务架构下的服务注册中心设计"><a href="#微服务架构下的服务注册中心设计" class="headerlink" title="微服务架构下的服务注册中心设计"></a>微服务架构下的服务注册中心设计</h1><p>这里以一个电商网站进行模拟</p><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>传统的单体架构(all in one) </p><p><img src="http://files.luyanan.com//img/20191104093834.png"></p><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p>假设一个电商的下单场景,完成一笔订单入库操作,需要做以下几个操作:</p><ol><li>创建订单</li><li>卡券抵扣</li><li>库存扣减</li></ol><p>那么在分布式架构的调用链下, 可能是下面这种情况. 那么服务和服务之间势必会存在远程通信. </p><p><img src="http://files.luyanan.com//img/20191104094509.png"></p><p>为了让大家更好的理解服务之间的通信, 我们来基于SpringBoot 模拟出上面的这种应用场景.</p><h3 id="使用SpringBoot-RestTemplate-创建两个服务"><a href="#使用SpringBoot-RestTemplate-创建两个服务" class="headerlink" title="使用SpringBoot + RestTemplate 创建两个服务"></a>使用SpringBoot + RestTemplate 创建两个服务</h3><p>创建两个SpringBoot 工程</p><ul><li>订单服务(order-service)</li><li>库存服务(repo-service)</li></ul><p>分别创建 controller</p><p> OrderController </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplateBuilder restTemplateBuilder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">     RestTemplate rt=restTemplateBuilder.build();</span><br><span class="line">     System.out.println(<span class="string">&quot;开始创建订单&quot;</span>);</span><br><span class="line">     rt.put(<span class="string">&quot;http://localhost:8081/repo/&#123;1&#125;&quot;</span>,<span class="keyword">null</span>,<span class="number">10001</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> RepoController </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/repo/&#123;pid&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serverMsg</span><span class="params">(<span class="meta">@PathVariable(&quot;pid&quot;)</span> String pid)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;扣减库存,商品 ID:&quot;</span>+pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="简单了解-RestTemplate"><a href="#简单了解-RestTemplate" class="headerlink" title="简单了解 RestTemplate"></a>简单了解 RestTemplate</h3><p>服务与服务之间, 一定不是相互隔离的, 而是必须要互相联系进行数据通信才能实现完整的功能. 所以在刚才的案例中, 我妈们拆分出来的服务使用RestTemplate 来进行远程通信. </p><p>在了解RestTemplate 之前, 先来简单了解下HTTP Client, 我们实现对于http 服务的远程调用,常见的手段是基于Apache 提供的httpclient, 或者是Square 公司开源的Okhttp. 还有Netflix 提供的Feign等等.</p><p>简单来说,RestTemplate 是Spring 提供了用来访问REST 服务的客户端, 以前我们使用Apache HttpClient  来进行远程调用的时候, 需要些非常多的代码,还需要考虑各种资源回收的问题. 而RestTemplate 简化了Http 服务的通信, 我们只需要提供URL，RestTemplate 会帮我们搞定这一切. </p><p>另外,需要注意的是, RestTemplate 并没有重复造轮子, 而是利用现有的技术,如JDK或者Apache HttpClient、Okhttp 等实现http 远程调用. </p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>RestTemplate 需要使用一个实现了 ClientHttpRequestFactory  接口的类为其提供 ClientHttpRequest  实现。 而  ClientHttpRequest  则实现封装了组装、发送HTTP消息以及解析响应的底层细节.</p><p>目前( 5.1.8.RELEASE) 的RestTemplate 主要有四种  ClientHttpRequestFactory  的实现, 他们分别是: </p><ol><li>基于JDK HttpUrlConnection 的 SimpleClientHttpRequestFactory </li><li>基于Apache HttpComponents Client 的 HttpComponentsClientHttpRequestFactory </li><li>基于Okhttp2(Okhttp 最新版本为3, 有较大改动, 包名有变动, 不和老版本兼容)的  OkHttpClientHttpRequestFactory </li><li>基于Netty4 的 Netty4ClientHttpRequestFactory </li></ol><h4 id="消息读取的转化"><a href="#消息读取的转化" class="headerlink" title="消息读取的转化"></a>消息读取的转化</h4><p>RestTemplate 对于服务端端返回消息的读取, 提供了消息转化器, 可以把目标消息转换为用户指定的格式( 通过 Class responseType 参数指定 ) 指定. 类似于写消息的处理,读消息的处理也是通过 ContentType 和 responseType 来选择的相应 HttpMessageConverter 来进 行的。 </p><h3 id="Http-和RPC框架的区别"><a href="#Http-和RPC框架的区别" class="headerlink" title="Http 和RPC框架的区别"></a>Http 和RPC框架的区别</h3><p>虽然现在服务间的调用越来越多的使用了RPC 和消息队列, 但是HTTP 仍然有适合它的场景. </p><p>RCP 的优势在于高效的网络传输模型(常使用NIO来实现),以及针对服务调用场景专门设计协议和高效的序列化技术. </p><p>HTTP的优势在于它的成熟稳定、使用简单、被广泛支持、兼容性好、防火墙友好、消息的可读性高. 所以HTTP 协议在开放API、跨平台的服务调用,对性能要求不苛刻的场景中有广泛的使用.</p><h2 id="微服务通信带来的问题"><a href="#微服务通信带来的问题" class="headerlink" title="微服务通信带来的问题"></a>微服务通信带来的问题</h2><p>有了远程通信以后, 我们势必会考虑几个问题:</p><ol><li>目标服务肯定会做扩容,扩容以后,客户端会带来一些变化.</li><li>客户端对于目标服务如何进行负载均衡.</li><li>客户端如何维护目标服务的地址信息</li><li>服务端的服务状态变化, 如何让客户端尽心感知.</li></ol><p><img src="http://files.luyanan.com//img/20191104103842.png"></p><h2 id="引入注册中心"><a href="#引入注册中心" class="headerlink" title="引入注册中心"></a>引入注册中心</h2><p>服务注册中心主要用于实现服务的注册和服务的发现功能, 在微服务架构中, 它起到了非常大的作用. </p><h3 id="注册中心的实现"><a href="#注册中心的实现" class="headerlink" title="注册中心的实现"></a>注册中心的实现</h3><p>Dubbo 体系中的Zookeeper、SpringCloud 中的Eureka 和Consul</p><h2 id="重新认识Zookeeper"><a href="#重新认识Zookeeper" class="headerlink" title="重新认识Zookeeper"></a>重新认识Zookeeper</h2><h3 id="Zookeeper-的前生今世"><a href="#Zookeeper-的前生今世" class="headerlink" title="Zookeeper 的前生今世"></a>Zookeeper 的前生今世</h3><p>Apache Zookeeper 是一个高可用的分布式协调中间件。 它是Google Chubby 的一个开源实现, 那么它主要是解决什么问题的呢? 那就得先了解 Google Chubby</p><p>Google Chubby 是谷歌的一个用来解决分布式一致性问题的组件, 同时, 也是粗粒度的分布式锁服务. </p><h3 id="分布式一致性问题"><a href="#分布式一致性问题" class="headerlink" title="分布式一致性问题"></a>分布式一致性问题</h3><p>什么是分布式一致性问题呢? 简单来说, 就是在一个分布式系统中, 有多个节点,每个节点都会提出一个请求,但是在所有节点中只能确定一个请求被通过.而这个通过是需要所有节点达成一致的结果. 所以所谓的一致性就是在提出的所有的请求中能够选出最终一个请求, 并且这个请求选出来以后, 所有的节点都要知道. </p><p>这个就是典型的拜占庭问题. </p><p>拜占庭将军问题说的是：拜占庭帝国军队的将军们必须通过投票达成一致来决定是否对某一个国家发起进攻. 但是这些将军在地理位置上是分开的, 并且在将军中存在叛徒. 叛徒可以通过任意行动来达到自己的目标. </p><ol><li>欺骗某些将军采取进攻行动. </li><li>促使一个不是所有将军都同意的决定, 比如将军们本意是不希望进攻, 但是叛徒可以促成进攻行动. </li><li>迷惑将军使得他们无法做出决定.</li></ol><p>如果叛徒达到了任意一个目标, 那么这次行动必然失败. 只有完全达成一致那么这次进攻才可能胜利. </p><p>拜占庭问题是本质是,由于网络通信存在不可靠的问题, 也就是可能存在消息丢失, 或者网络延迟. 如何在这样的背景下对某一个请求达成一致. </p><p>为了解决这个问题, 很多人提出了各种协议, 比如大名鼎鼎的Paxos. 也就是在不可信的网络环境中, 按照paxos 这个协议能够针对某个提议达成一致. </p><p>所以分布式一致性的本质就是在分布式系统中, 多个节点就某一个提议如何达成一致.</p><blockquote><p>这个和Google Chubby  有什么关系呢？ </p></blockquote><p>在Google  有一个GFS(Google file system), 他们有一个需求就是要从多个 GFS server中选出一个master Server . 这个就是典型的一致性问题, 5个分布在不同节点的server,需要确定一个master server,而他们要达成的一致性目标是: 确定某一个节点为master,并且所有节点要同意. </p><p>而GFS 就是使用chubby 来解决这个问题的. </p><p><strong>实现原理</strong>:</p><p>所有的server 通过chubby 提供的通信协议到Chubby Server 上创建同一个文件, 当然, 最终只有一个server 能够获取创建的这个文件. 这个server 就成为了master, 它会在这个文件中写入自己的地址, 这样其他的server 通过读取这个文件就能知道被选出master 的地址. </p><p><img src="http://files.luyanan.com//img/20191104112256.png"></p><h3 id="分布式锁服务"><a href="#分布式锁服务" class="headerlink" title="分布式锁服务"></a>分布式锁服务</h3><p>从另外一个层面来看, Chubby 提供了一种粗粒度的分布式锁服务, Chubby 是通过创建文件的形式来提供锁的功能. server 向chubby 中创建文件其实就表示加锁操作， 创建文件成功表示抢占到了锁. </p><p>由于Chubby 没有开源, 所以雅虎公司就基于Chubby 的思想, 开发出了一个类似的分布式协调组件Zookeeper, 后面捐赠给了Apache</p><p>所以,大家一定要了解, zookeeper 并不是作为注册中心而设计的, 而是作为分布式锁的一种设计. 而注册中心只是它能实现的一种功能而已. </p><h2 id="Zookeeper-的设计猜想"><a href="#Zookeeper-的设计猜想" class="headerlink" title="Zookeeper 的设计猜想"></a>Zookeeper 的设计猜想</h2><p>基于Zookeeper 本身的一个设计目标, zookeeper主要是解决分布式环境下的服务协调问题而产生的, 我们来猜想一下, 如果我们要去设计一个zookeeper, 需要满足哪些功能呢?</p><h3 id="防单点故障"><a href="#防单点故障" class="headerlink" title="防单点故障"></a>防单点故障</h3><p>首先, 在分布式架构中, 任何的节点都不能以单点的方式存在, 因此我们需要解决单点的问题. 常见的解决单点的问题的方式就是集群. </p><p>大家来思考一下, 这个集群需要满足哪些功能? </p><ol><li>集群中要有主节点和从节点(也就是集群要有角色)</li><li>集群要能做到数据同步, 当主节点出现故障, 从节点能够顶替主节点继续工作, 但是继续工作的前提是数据必须要主从节点保持一致. </li><li>主节点挂了以后, 从节点如何接替成为主节点, 是人工干预还是自动选举? </li></ol><p>所以基于这几个问题, 我们先把zookeeper 的集群节点画出来. </p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>接着上面的那个结论思考, 如果要满足这样的一个高性能集群, 我们最直观的想法应该是每个节点都能接收到请求, 并且每个节点的数据都必须要保持一致. 要实现各个节点的数据一致性, 就势必要一个leader 节点负责协调和数据同步操作. 这个我向大家知道,如果在这样一个集群中没有leader节点，每个节点都可以接受所有请求, 那么这个集群的数据同步的复杂度是非常大的. </p><p>所以, 当客户端请求过来, 需要满足,事务性数据和非事务性数据的分开处理方式, 就是leader 节点可以处理事务和非事务性数据.而follower 节点只能处理非事务性数据. 原因是: 对于数据变更的操作, 应该由一个节点来维护, 使得集群数据处理的简化. 同时,数据需要能能够通过leader 进行分发使得数据在集群中各个节点的一致性. </p><p><img src="http://files.luyanan.com//img/20191106095911.png"></p><p>leader节点如何与其他节点保证数据一致性,并且要求是强一致的. 在分布式系统中, 每一个机器节点虽然都能够明确知道自己进行的事务操作是成功还是失败,但是却无法直接获取其他分布式节点的操作过程. 所以当一个事务操作涉及到跨节点的时候, 就需要用到分布式事务, 分布式事务的数据一致性协议有2PC 协议和3PC协议. </p><h4 id="关于2PC-提交"><a href="#关于2PC-提交" class="headerlink" title="关于2PC 提交"></a>关于2PC 提交</h4><p>(Two Phase Commitment Protocol) 当一个事务操作需要跨域多个分布式节点的时候, 为了保证事务处理的ACID 特性, 就需要引入一个”协调者”(TM)来统一调度所有分布式节点的执行逻辑,这些被调度的分布式节点被称为AP。 TM 负责调度AP的行为, 并最终决定这些AP是否要把事务真正进行提交,因为整个事务是分为两个阶段提交, 所以叫2PC。</p><p><img src="http://files.luyanan.com//img/20191106100832.png"></p><p><img src="http://files.luyanan.com//img/20191106101036.png"></p><h5 id="阶段一-提交事务请求-投票"><a href="#阶段一-提交事务请求-投票" class="headerlink" title="阶段一: 提交事务请求(投票)"></a>阶段一: 提交事务请求(投票)</h5><ol><li><p>事务询问 </p><blockquote><p>协调者向所有的参与者发送事务内容, 询问是否可以执行事务提交操作, 并开始等待各参与者的响应. </p></blockquote></li><li><p>执行事务</p><blockquote><p>在这个阶段, 协调者会根据和参与者的反馈情况来决定最终是否可以进行事务提交操作, 正常情况下包含两种可能: 执行事务、中断事务. </p></blockquote><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3></li></ol><h4 id="Leader-角色"><a href="#Leader-角色" class="headerlink" title="Leader  角色"></a>Leader  角色</h4><p>Leader 服务器是整个zookeeper 集群的核心, 主要的工作是有两项:</p><ol><li>事务请求的唯一调度和处理者, 保证集群事务处理的顺序性. </li><li>集群内部各服务器的调度者. </li></ol><h4 id="Follower-角色"><a href="#Follower-角色" class="headerlink" title="Follower  角色"></a>Follower  角色</h4><p>Follower  角色的主要职责是: </p><ol><li>处理客户端非事务请求, 转发事务请求给leader 服务器</li><li>参与事务请求proposal 的投票(需要半数以上服务器通过才能通知leader  commit 数据, Leader 发起的提案, 要求Follower 投票)</li><li>参数Leader 选举的投票</li></ol><h4 id="Observer-角色"><a href="#Observer-角色" class="headerlink" title="Observer 角色"></a>Observer 角色</h4><p>Observer 是Zookeeper3.3 开始引入的一个全新的服务器角色, 从字面来理解, 该角色充当了观察者的角色。 </p><p>观察Observel 集群中的最新状态变化并将这些状态变化同步到Observer 服务器上, Observer 的工作原理与follower 角色基本一致, 而它和follower 角色唯一的不同在于Observer 不参与任何形式的投票,包括事务请求Proposal 的投票和leader 选举的投票. 简单来说, observer 服务器只提供非事务请求服务, 通常在于不影响集群处理能力的前提下提升集群非事务处理能力. </p><h3 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h3><p>当Leader 挂了, 需要从其他follower 节点中选择一个新的节点进行处理, 这个时候就需要设计到leader 选举. </p><h3 id="集群组成"><a href="#集群组成" class="headerlink" title="集群组成"></a>集群组成</h3><p>通常zookeeper 是由2n+1台server组成, 每个server 都知道彼此的存在。每个server 都维护的内存状态镜像以及持久化存储的事务日志和快照. 对于2n-1台server , 只要有 n+1 台(大多数) server 可用, 整个系统保持可用.  我们已经了解到, 一个zookeeper 集群如果要对外提供可用的服务, 那么集群中必须要有过半的集群正常工作并且彼此之间能够正常通信, 基于这个特性, 如果想搭建一个能够允许F台集群down 掉的集群, 那么就要部署2*F+1 台服务器构成的zookeeper 集群. 因此3台集群组成的zookeeper 集群能够在挂掉一台机器后仍然正常工作. 一个5台机器集群的服务,能够对2台机器坏掉的情况下进行容灾. 如果一台由6台服务构成的集群, 同样只能挂掉两台. 因此, 5台和6台在容灾能力上并没有优势, 反而增加了网络通信负担. 系统启动时, 集群中的server 会选举出一台server 为Leader, 其他的就作为follower(这里先不考虑observer 角色).</p><blockquote><p>之所以要满足这样一个等式, 是因为一个节点要称为集群中的leader, 需要有超过集群过半的节点支持, 这个涉及到leader 的选举算法, 同时也涉及到事务请求的提交投票. </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;微服务架构下的服务注册中心设计&quot;&gt;&lt;a href=&quot;#微服务架构下的服务注册中心设计&quot; class=&quot;headerlink&quot; title=&quot;微服务架构下的服务注册中心设计&quot;&gt;&lt;/a&gt;微服务架构下的服务注册中心设计&lt;/h1&gt;&lt;p&gt;这里以一个电商网站进行模拟&lt;/p&gt;
&lt;h2 id=&quot;单体架构&quot;&gt;&lt;a href=&quot;#单体架构&quot; class=&quot;headerlink&quot; title=&quot;单体架构&quot;&gt;&lt;/a&gt;单体架构&lt;/h2&gt;&lt;p&gt;传统的单体架构(all in one) &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20191104093834.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="zookeeper" scheme="http://luyanan.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/%E5%9F%BA%E4%BA%8EZookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://luyanan.com/%E5%9F%BA%E4%BA%8EZookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-03-01T09:46:52.969Z</published>
    <updated>2020-12-24T09:34:50.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Zookeeper-实现分布式锁"><a href="#基于Zookeeper-实现分布式锁" class="headerlink" title="基于Zookeeper 实现分布式锁"></a>基于Zookeeper 实现分布式锁</h1><h2 id="分布式锁的基本场景"><a href="#分布式锁的基本场景" class="headerlink" title="分布式锁的基本场景"></a>分布式锁的基本场景</h2><p>如果在多线程并行情况下去访问某一个共享资源,比如说共享变量, 那么势必会造成线程安全问题. 那么我们可以用很多种方法来解决, 比如synchronized、比如Lock 之类的锁操作来解决线程问题, 那么在分布式架构下,涉及到多个进程访问某一个共享资源的情况下, 比如说在电商平台中商品库存问题, 在库存中只有10个的情况下进来100个用户, 如果能够避免超卖呢? 所以这个时候就要一个互斥的手段来防止彼此之间的干扰. </p><p>然后在分布式情况下, synchronized 或者Lock 之类的锁只能控制单一进程的资源访问, 在多进程架构下, 这些API就没办法解决我们的问题了, 怎么办呢? </p><h2 id="用Zookeeper-来实现分布式锁"><a href="#用Zookeeper-来实现分布式锁" class="headerlink" title="用Zookeeper 来实现分布式锁"></a>用Zookeeper 来实现分布式锁</h2><p>我们可以利用zoookeeper 的特性来实现独占锁, 就是同级节点的唯一性,多个进程往zookeeper的指定节点下创建一个相同名称的节点, 只有一个能成功, 另外一个是创建失败. 创建失败的节点全部通过zookeeper的watcher 机制来监听zookeeper 这个子节点的变化, 一旦监听到子节点的删除事件, 则再次触发所有进程去写锁. </p><p><img src="http://files.luyanan.com//img/20191111113744.png"></p><p>这种实现方式很简单, 但是会产生”惊群效应”,简单来说, 就是如果存在修多的客户端在等待获取锁, 当成功获取到锁的进程释放该节点后, 所有处于等待状态的客户端都会被唤醒, 这个时候zookeeper 在短时间内发送大量子节点变更事件给所有待获取锁的客户端, 然后实际情况是只会有一个客户端获取锁. 如果在集群规模比较大的情况下, 会对zookeeper 服务器的性能产生比较大的影响. </p><h2 id="利用有序节点来实现分布式锁"><a href="#利用有序节点来实现分布式锁" class="headerlink" title="利用有序节点来实现分布式锁"></a>利用有序节点来实现分布式锁</h2><p>我们可以通过有序节点来实现分布式锁, 每个客户端都往指定的节点下注册一个临时有序节点, 越早创建的节点, 节点的顺序编号就越小, 那么我们可以判断子节点中最小的节点设置为获取锁. 如果自己的节点不是所有子节点中最小的, 意味着还没有获取锁. 这个锁的实现和前面单节点的实现的差异在于, 每个节点只需要监听比自己小的节点, 当比自己小的节点删除以后, 客户端会受到watcher 事件, 此时再次判断自己的节点是不是所有子节点中最小的, 如果是则获取锁, 否则就不断重复这个过程, 这样就不会导致”惊群效应”,因为每个客户端只需要监听一个节点. </p><h2 id="curator-分布式锁的基本使用"><a href="#curator-分布式锁的基本使用" class="headerlink" title="curator 分布式锁的基本使用"></a>curator 分布式锁的基本使用</h2><p>curator 对于锁这块做了一些封装, curator 提供了 InterProcessMutex  这样一个API。除了分布式锁之外, 还提供了Leader 选举,、分布式队列等常用的功能. </p><ul><li><p> InterProcessMutex：分布式可重入排它锁 </p></li><li><p> InterProcessSemaphoreMutex：分布式排它锁 </p></li><li><p> InterProcessReadWriteLock：分布式读写锁 </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zk.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMultiLock;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/11</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;分布式锁&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String connect = <span class="string">&quot;192.168.91.128:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">        CuratorFramework framework = createClient(connect);</span><br><span class="line"></span><br><span class="line">        framework.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(framework, <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 尝试获得锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 已经获得锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="string">&quot;thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title">createClient</span><span class="params">(String connect)</span> </span>&#123;</span><br><span class="line">        CuratorFramework framework = CuratorFrameworkFactory</span><br><span class="line">                .builder()</span><br><span class="line">                <span class="comment">// 连接信息</span></span><br><span class="line">                .connectString(connect)</span><br><span class="line">                <span class="comment">// 会话超时时间</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//失败重试机制</span></span><br><span class="line">                <span class="comment">//ExponentialBackoffRetry</span></span><br><span class="line">                <span class="comment">//RetryOneTime  仅仅只重试一次</span></span><br><span class="line">                <span class="comment">//RetryUntilElapsed</span></span><br><span class="line">                <span class="comment">//RetryNTimes</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="curator-实现分布式锁的基本原理"><a href="#curator-实现分布式锁的基本原理" class="headerlink" title="curator 实现分布式锁的基本原理"></a>curator 实现分布式锁的基本原理</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//  Zookeeper 利用path 创建临时顺序节点, 实现公平锁的核心</span></span><br><span class="line">      <span class="keyword">this</span>(client, path, <span class="keyword">new</span> StandardLockInternalsDriver());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path, LockInternalsDriver driver)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// maxLeases  =1 表示可以获取分布式锁的线程数量(跨JVM)为1, 即为互斥锁</span></span><br><span class="line">    <span class="keyword">this</span>(client, path, <span class="string">&quot;lock-&quot;</span>, <span class="number">1</span>, driver);</span><br><span class="line">   &#125;</span><br><span class="line"> InterProcessMutex(CuratorFramework client, String path, String lockName, <span class="keyword">int</span> maxLeases, LockInternalsDriver driver) &#123;</span><br><span class="line">       <span class="keyword">this</span>.threadData = Maps.newConcurrentMap();</span><br><span class="line">       <span class="keyword">this</span>.basePath = PathUtils.validatePath(path);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// internals 的类型为 LockInternals, InterProcessMutex 将分布式锁的申请和释放操作委托给 internals 执行</span></span><br><span class="line">     <span class="keyword">this</span>.internals = <span class="keyword">new</span> LockInternals(client, driver, path, lockName, maxLeases);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="InterProcessMutex-acquire-获取锁"><a href="#InterProcessMutex-acquire-获取锁" class="headerlink" title="InterProcessMutex.acquire();   获取锁"></a>InterProcessMutex.acquire();   获取锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限等待 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.internalLock(-<span class="number">1L</span>, (TimeUnit)<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Lost connection while trying to acquire lock: &quot;</span> + <span class="keyword">this</span>.basePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 限时等待</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.internalLock(time, unit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="InterProcessMutex-internalLock"><a href="#InterProcessMutex-internalLock" class="headerlink" title="InterProcessMutex.internalLock();"></a>InterProcessMutex.internalLock();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        InterProcessMutex.LockData lockData = (InterProcessMutex.LockData)<span class="keyword">this</span>.threadData.get(currentThread);</span><br><span class="line">        <span class="keyword">if</span> (lockData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 实现可重入</span></span><br><span class="line">            <span class="comment">// 同一个线程再次 acquire, 首先判断当前的映射表内(threadData) 是否有该线程的锁信息, 如果有, 则原子+1, 然后返回. </span></span><br><span class="line">            lockData.lockCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 映射表中没有对应的锁信息, 尝试通过LockInternals 获取锁. </span></span><br><span class="line">            String lockPath = <span class="keyword">this</span>.internals.attemptLock(time, unit, <span class="keyword">this</span>.getLockNodeBytes());</span><br><span class="line">            <span class="keyword">if</span> (lockPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 成功获取锁, 记录信息到映射表</span></span><br><span class="line">                InterProcessMutex.LockData newLockData = <span class="keyword">new</span> InterProcessMutex.LockData(currentThread, lockPath);</span><br><span class="line">                <span class="keyword">this</span>.threadData.put(currentThread, newLockData);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射表</span></span><br><span class="line"><span class="comment">// 记录线程与锁信息的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Thread, InterProcessMutex.LockData&gt; threadData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁信息</span></span><br><span class="line"><span class="comment">// Zookeeper 中一个临时顺序节点对应一个锁, 但让锁生效激活需要排队(公平锁),下面会继续分析</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread owningThread;</span><br><span class="line">        <span class="keyword">final</span> String lockPath;</span><br><span class="line">       <span class="comment">// 分布式锁重入次数</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger lockCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LockData</span><span class="params">(Thread owningThread, String lockPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lockCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.owningThread = owningThread;</span><br><span class="line">            <span class="keyword">this</span>.lockPath = lockPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="InterProcessMutex-attemptLock"><a href="#InterProcessMutex-attemptLock" class="headerlink" title="InterProcessMutex.attemptLock"></a>InterProcessMutex.attemptLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁, 并返回锁对应的zookeeper 临时顺序节点的路径 </span></span><br><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> startMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 无限等待时, millisToWait 为null</span></span><br><span class="line">        Long millisToWait = unit != <span class="keyword">null</span> ? unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 创建ZNode 节点时的数据内容, 无关紧要, 这里为null, 采用默认值(ip地址)</span></span><br><span class="line">        <span class="keyword">byte</span>[] localLockNodeBytes = <span class="keyword">this</span>.revocable.get() != <span class="keyword">null</span> ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">    <span class="comment">// 当前已经重试次数, 与    CuratorFramework的重试策略有关. </span></span><br><span class="line">    <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在zookeeper 中创建的临时顺序节点的路径相当于一把待激活的分布式锁.</span></span><br><span class="line">    <span class="comment">// 激活条件: 同级目录下子节点, 名字排序最小(排队、公平锁) </span></span><br><span class="line">        String ourPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 是否已经持有分布式锁. </span></span><br><span class="line">        <span class="keyword">boolean</span> hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已经完成了尝试获取分布式锁的操作 </span></span><br><span class="line">        <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!isDone) &#123;</span><br><span class="line">            isDone = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从InterProcessMutex 的构造函数可知实际driver 为StandardLockInternalsDriver 的实例. </span></span><br><span class="line">                <span class="comment">// 在zookeeper 中创建顺序临时节点. </span></span><br><span class="line">                ourPath = <span class="keyword">this</span>.driver.createsTheLock(<span class="keyword">this</span>.client, <span class="keyword">this</span>.path, localLockNodeBytes);</span><br><span class="line">                <span class="comment">// 循环等待来激活分布式锁, 实现锁的公平性</span></span><br><span class="line">                hasTheLock = <span class="keyword">this</span>.internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoNodeException var14) &#123;</span><br><span class="line">                <span class="comment">// 容错处理</span></span><br><span class="line">                <span class="comment">// 因为绘会话过期等原因,StandardLockInternalsDriver 因为无法找到创建的临时顺序节点而抛出NoNodeException 异常. </span></span><br><span class="line">                <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 满足重试策略尝试重新获取锁</span></span><br><span class="line">                    isDone = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 不满足重试策略则继续抛出 NoNodeException 异常. </span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( hasTheLock )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 成功获取分布式锁, 返回临时顺序节点的路径, 上层将其封装成锁信息记录在映射表中, 方便锁重入</span></span><br><span class="line">            <span class="keyword">return</span> ourPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分布式锁失败, 返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="createsTheLock"><a href="#createsTheLock" class="headerlink" title="createsTheLock"></a>createsTheLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 在zookeeper中创建临时顺序节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ourPath;</span><br><span class="line">        <span class="keyword">if</span> ( lockNodeBytes != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lockNodeBytes 不为null 则作为数据节点内容, 否则采用默认内容(ip地址)</span></span><br><span class="line">            <span class="comment">// creatingParentContainersIfNeeded: 用于创建父节点, 如果不支持 CreateMode.CONTAINER</span></span><br><span class="line">            <span class="comment">// 那么将采用 CreateMode.PERSISTENT</span></span><br><span class="line">            <span class="comment">// withProtection: 临时子节点会添加 GUID 前缀</span></span><br><span class="line">            ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">            <span class="comment">// CreateMode.EPHEMERAL_SEQUENTIAL: 临时顺序节点, zookeeper 能保证在节点产生的顺序性.</span></span><br><span class="line">            <span class="comment">// 依据顺序来激活分布式锁, 从而实现了分布式锁的公平性,</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ourPath;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="LockInternals-internalLockLoop"><a href="#LockInternals-internalLockLoop" class="headerlink" title="LockInternals.internalLockLoop"></a>LockInternals.internalLockLoop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环等待来激活分布式锁,实现锁的公平性.  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经持有分布式锁</span></span><br><span class="line">        <span class="keyword">boolean</span>     haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否需要删除子节点</span></span><br><span class="line">        <span class="keyword">boolean</span>     doDelete = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取排序后的子节点的顺序</span></span><br><span class="line">                List&lt;String&gt;        children = getSortedChildren();</span><br><span class="line">                <span class="comment">// 获取前面自己创建的临时顺序子节点的名称</span></span><br><span class="line">                String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 实现锁的公平性的核心逻辑. </span></span><br><span class="line">                PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">                <span class="keyword">if</span> ( predicateResults.getsTheLock() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取了锁, 中断循环, 继续返回上层</span></span><br><span class="line">                    haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 没有获取锁, 监听上一临时顺序节点</span></span><br><span class="line">                    String  previousSequencePath = basePath + <span class="string">&quot;/&quot;</span> + predicateResults.getPathToWatch();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</span></span><br><span class="line">                            <span class="comment">// exists  会导致资源泄露, 因此exists() 可以监听不存在的ZNode, 因为采用 getData</span></span><br><span class="line">                            <span class="comment">//  上一临时顺序节点如果被删除, 会唤醒当前线程继续竞争锁,正常情况下能直接获得锁, 因为锁是公平的. </span></span><br><span class="line">                            </span><br><span class="line">                            client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                                millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                                startMillis = System.currentTimeMillis();</span><br><span class="line">                                <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">// 获取锁超时, 标记删除之前创建的临时顺序节点</span></span><br><span class="line">                                    doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 等待被唤醒, 限时等待</span></span><br><span class="line">                                wait(millisToWait);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// 等待被唤醒, 无限等待</span></span><br><span class="line">                                wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> ( KeeperException.NoNodeException e ) </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 容错处理, </span></span><br><span class="line">                            <span class="comment">// client.getData()  可能调用时抛出 NoNodeException，原因可能是锁被释放或会话过期(连接丢失)等. </span></span><br><span class="line">                            <span class="comment">// 这里并没有做任何处理, 因为外层是while 循环, 再次执行driver.getsTheLock 会调用 validateOurIndex</span></span><br><span class="line">                            <span class="comment">// 此时会抛出NoNodeException, 从而进入下面的catch 和finally 逻辑, 重新抛出上层尝试重试获取锁并删除临时顺序节点</span></span><br><span class="line">                            <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">        &#123;</span><br><span class="line">            ThreadUtils.checkInterrupted(e);</span><br><span class="line">            <span class="comment">// 标记删除, 在finally 删除之前创建的临时顺序节点(后台不断尝试)</span></span><br><span class="line">            doDelete = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//  重新抛出,尝试重新获取锁. </span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( doDelete )</span><br><span class="line">            &#123;</span><br><span class="line">                deleteOurPath(ourPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> haveTheLock;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="getsTheLock"><a href="#getsTheLock" class="headerlink" title="getsTheLock"></a>getsTheLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// 之前创建的临时顺序节点在排序后的子节点中的索引</span></span><br><span class="line">       <span class="keyword">int</span>             ourIndex = children.indexOf(sequenceNodeName);</span><br><span class="line">       <span class="comment">// 校验之前创建的临时顺寻节点是否有效</span></span><br><span class="line">       validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 锁公平性的核心逻辑</span></span><br><span class="line">       <span class="comment">// 由InterProcessMutex 的构造函数可知,maxLeases 为1, 即只有ourIndex 为0时, 线程才能持有锁, 或者说该线程创建的临时顺序节点激活了锁.</span></span><br><span class="line">       <span class="comment">// Zookeeper 的临时顺序节点特性能够保证跨多个JVM 的线程并发创建节点的顺序性, 越早创建临时顺序节点成功的线程会更早的激活锁或获取锁. </span></span><br><span class="line">      </span><br><span class="line">       <span class="keyword">boolean</span>         getsTheLock = ourIndex &lt; maxLeases;</span><br><span class="line">      <span class="comment">// 如果 已经获取到锁, 则无需监听任何节点, 否则需要监听上一个顺序节点(ourIndex -1)</span></span><br><span class="line">       <span class="comment">// 因为锁是公平的, 因为无需监听除了(ourIndex -1) 以外 的所有节点, 这时为了减少羊群效应, 非常巧妙的涉及. </span></span><br><span class="line">       String          pathToWatch = getsTheLock ? <span class="keyword">null</span> : children.get(ourIndex - maxLeases);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回获取锁的结果, 交由上层继续处理(添加监听等操作)</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(pathToWatch, getsTheLock);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validateOurIndex</span><span class="params">(String sequenceNodeName, <span class="keyword">int</span> ourIndex)</span> <span class="keyword">throws</span> KeeperException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ( ourIndex &lt; <span class="number">0</span> )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 容错处理</span></span><br><span class="line">           <span class="comment">// 由于会话过期或连接丢失等原因, 该线程创建的临时顺序节点被zookee 服务端删除, 往外抛出NoNodeException</span></span><br><span class="line">           <span class="comment">// 如果在重试策略允许范围内, 则进行重新禅师获取锁, 这会重新生成临时顺序节点</span></span><br><span class="line">          </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException(<span class="string">&quot;Sequential path not found: &quot;</span> + sequenceNodeName);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁-InterProcessMutex-release"><a href="#释放锁-InterProcessMutex-release" class="headerlink" title="释放锁  InterProcessMutex.release();"></a>释放锁  InterProcessMutex.release();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Note on concurrency: a given lockData instance</span></span><br><span class="line"><span class="comment">            can be only acted on by a single thread so locking isn&#x27;t necessary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        LockData lockData = threadData.get(currentThread);</span><br><span class="line">        <span class="keyword">if</span> ( lockData == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  无法从映射表中获取锁信息, 不持有锁. </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">&quot;You do not own the lock: &quot;</span> + basePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> ( newLockCount &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">// 锁是可重入的, 初始值为1 原子为-1 到0, 锁才释放. </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( newLockCount &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 理论上无法执行该路径</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">&quot;Lock count has gone negative for lock: &quot;</span> + basePath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  lockData != null &amp;&amp; newLockCount ==</span></span><br><span class="line"><span class="number">0</span>，释放锁资源</span><br><span class="line">            internals.releaseLock(lockData.lockPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 最后从映射表中移除当前线程的锁信息. </span></span><br><span class="line">            threadData.remove(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="LockInternals-releaseLock"><a href="#LockInternals-releaseLock" class="headerlink" title="LockInternals.releaseLock"></a>LockInternals.releaseLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      client.removeWatchers();</span><br><span class="line">      revocable.set(<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 删除临时顺序节点, 只会触发后一顺序节点去获取锁, 理论上不存在竞争, 只排队, 非抢占, 公平锁.先到先得</span></span><br><span class="line">      deleteOurPath(lockPath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOurPath</span><span class="params">(String ourPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 后台不断尝试删除.</span></span><br><span class="line">          client.delete().guaranteed().forPath(ourPath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 已经删除(可能会话过期到期),不做处理. </span></span><br><span class="line">          <span class="comment">// ignore - already deleted (possibly expired session, etc.)</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基于Zookeeper-实现分布式锁&quot;&gt;&lt;a href=&quot;#基于Zookeeper-实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;基于Zookeeper 实现分布式锁&quot;&gt;&lt;/a&gt;基于Zookeeper 实现分布式锁&lt;/h1&gt;&lt;h2 id=&quot;分布式锁的基本场景&quot;&gt;&lt;a href=&quot;#分布式锁的基本场景&quot; class=&quot;headerlink&quot; title=&quot;分布式锁的基本场景&quot;&gt;&lt;/a&gt;分布式锁的基本场景&lt;/h2&gt;&lt;p&gt;如果在多线程并行情况下去访问某一个共享资源,比如说共享变量, 那么势必会造成线程安全问题. 那么我们可以用很多种方法来解决, 比如synchronized、比如Lock 之类的锁操作来解决线程问题, 那么在分布式架构下,涉及到多个进程访问某一个共享资源的情况下, 比如说在电商平台中商品库存问题, 在库存中只有10个的情况下进来100个用户, 如果能够避免超卖呢? 所以这个时候就要一个互斥的手段来防止彼此之间的干扰. &lt;/p&gt;
&lt;p&gt;然后在分布式情况下, synchronized 或者Lock 之类的锁只能控制单一进程的资源访问, 在多进程架构下, 这些API就没办法解决我们的问题了, 怎么办呢? &lt;/p&gt;
&lt;h2 id=&quot;用Zookeeper-来实现分布式锁&quot;&gt;&lt;a href=&quot;#用Zookeeper-来实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;用Zookeeper 来实现分布式锁&quot;&gt;&lt;/a&gt;用Zookeeper 来实现分布式锁&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/%E5%9F%BA%E4%BA%8EZookeeper%20%E5%AE%9E%E7%8E%B0Leader%E9%80%89%E4%B8%BE/"/>
    <id>http://luyanan.com/%E5%9F%BA%E4%BA%8EZookeeper%20%E5%AE%9E%E7%8E%B0Leader%E9%80%89%E4%B8%BE/</id>
    <published>2021-03-01T09:46:52.961Z</published>
    <updated>2020-12-24T09:34:50.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Zookeeper-实现Leader选举"><a href="#基于Zookeeper-实现Leader选举" class="headerlink" title="基于Zookeeper 实现Leader选举"></a>基于Zookeeper 实现Leader选举</h1><p>在分布式计算中,leader election 是很重要的一个功能, 这个选举过程是这样子的: 指派一个进程作为组织者, 将任务分发给各节点。 在任务开始之前, 哪个节点都不知道谁是leader 或者coordinator. 当选举算法开始执行后, 每个节点最终会得到一个唯一的节点作为任务leader. 除此之外, 选举还经常会发生在leader 意外宕机的情况下, 新的leader 要被选举出来. </p><p>curatot 有两种选举recipe(Leader Latch 和Leader Election)</p><h2 id="Leader-Latch"><a href="#Leader-Latch" class="headerlink" title="Leader Latch"></a>Leader Latch</h2><p>参与选举的所有节点, 会创建一个顺序节点, 其中最小的节点会设置为master节点, 没抢到leader 节点的都监听前一个节点的删除事件, 在前一个节点还是删除后进行重新抢主, 当master 节点手动调用close() 方法或者master  节点挂了之后, 后续的子节点会抢占master</p><p>其中spark 使用的就是这种方法 </p><h2 id="LeaderSelector"><a href="#LeaderSelector" class="headerlink" title="LeaderSelector"></a>LeaderSelector</h2><p>LeaderSelector 和Leader Latch 最大的区别在于, leader 在释放领导权以后, 还可以继续参与竞争. </p><h3 id="LeaderSelector-案例演示"><a href="#LeaderSelector-案例演示" class="headerlink" title="LeaderSelector 案例演示"></a>LeaderSelector 案例演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zk.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/12</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;使用LeaderSelector 实现选举&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorDemo</span> <span class="keyword">extends</span> <span class="title">LeaderSelectorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaderSelectorDemo</span><span class="params">(CuratorFramework framework, String name, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 利用一个给定路径创建一个leaderSelector</span></span><br><span class="line">        <span class="comment">// 执行leader选举的的所有参与者对应的路径必须是一样的.</span></span><br><span class="line">        <span class="keyword">this</span>.leaderSelector = <span class="keyword">new</span> LeaderSelector(framework, path, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 在大多数情况下, 我们会希望一个selector 放弃leader 后还要重新参与leader 选举</span></span><br><span class="line">        leaderSelector.autoRequeue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        leaderSelector.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        leaderSelector.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;现在是leader了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞, 让当前获取leader权限的节点一直持有,直到该进程关闭.</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String connect = <span class="string">&quot;192.168.91.128:2181&quot;</span>;</span><br><span class="line">        CuratorFramework framework = createClient(connect);</span><br><span class="line">        framework.start();</span><br><span class="line">        LeaderSelectorDemo demo = <span class="keyword">new</span> LeaderSelectorDemo(framework, <span class="string">&quot;ClientA&quot;</span>, <span class="string">&quot;/leader&quot;</span>);</span><br><span class="line">        demo.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title">createClient</span><span class="params">(String connect)</span> </span>&#123;</span><br><span class="line">        CuratorFramework framework = CuratorFrameworkFactory</span><br><span class="line">                .builder()</span><br><span class="line">                <span class="comment">// 连接信息</span></span><br><span class="line">                .connectString(connect)</span><br><span class="line">                <span class="comment">// 会话超时时间</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//失败重试机制</span></span><br><span class="line">                <span class="comment">//ExponentialBackoffRetry</span></span><br><span class="line">                <span class="comment">//RetryOneTime  仅仅只重试一次</span></span><br><span class="line">                <span class="comment">//RetryUntilElapsed</span></span><br><span class="line">                <span class="comment">//RetryNTimes</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基于Zookeeper-实现Leader选举&quot;&gt;&lt;a href=&quot;#基于Zookeeper-实现Leader选举&quot; class=&quot;headerlink&quot; title=&quot;基于Zookeeper 实现Leader选举&quot;&gt;&lt;/a&gt;基于Zookeeper 实现Leader选举&lt;/h1&gt;&lt;p&gt;在分布式计算中,leader election 是很重要的一个功能, 这个选举过程是这样子的: 指派一个进程作为组织者, 将任务分发给各节点。 在任务开始之前, 哪个节点都不知道谁是leader 或者coordinator. 当选举算法开始执行后, 每个节点最终会得到一个唯一的节点作为任务leader. 除此之外, 选举还经常会发生在leader 意外宕机的情况下, 新的leader 要被选举出来. &lt;/p&gt;
&lt;p&gt;curatot 有两种选举recipe(Leader Latch 和Leader Election)&lt;/p&gt;
&lt;h2 id=&quot;Leader-Latch&quot;&gt;&lt;a href=&quot;#Leader-Latch&quot; class=&quot;headerlink&quot; title=&quot;Leader Latch&quot;&gt;&lt;/a&gt;Leader Latch&lt;/h2&gt;&lt;p&gt;参与选举的所有节点, 会创建一个顺序节点, 其中最小的节点会设置为master节点, 没抢到leader 节点的都监听前一个节点的删除事件, 在前一个节点还是删除后进行重新抢主, 当master 节点手动调用close() 方法或者master  节点挂了之后, 后续的子节点会抢占master&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E7%9A%84zookeeper%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/"/>
    <id>http://luyanan.com/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1%E7%9A%84zookeeper%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/</id>
    <published>2021-03-01T09:46:52.952Z</published>
    <updated>2020-12-24T09:34:50.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式协调服务的zookeeper应用实战"><a href="#分布式协调服务的zookeeper应用实战" class="headerlink" title="分布式协调服务的zookeeper应用实战"></a>分布式协调服务的zookeeper应用实战</h1><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><p><img src="http://files.luyanan.com//img/20191106154252.png"></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>zookeeper的视图结构和标准的文件系统非常类似, 每一个节点称之为ZNode, 是zookeeper的最小单元. 每个znode 上都可以保存数据以及挂载子节点. 构成一个层次化树形结构. </p><h3 id="持久节点-PERSISTENT"><a href="#持久节点-PERSISTENT" class="headerlink" title="持久节点( PERSISTENT )"></a>持久节点( PERSISTENT )</h3><p>创建后会一直存在zookeeper服务器上, 直到主动删除</p><h3 id="持久有序节点-PERSISTENT-SEQUENTIAL"><a href="#持久有序节点-PERSISTENT-SEQUENTIAL" class="headerlink" title="持久有序节点( PERSISTENT_SEQUENTIAL )"></a>持久有序节点( PERSISTENT_SEQUENTIAL )</h3><p>每个节点都会为它的一级子节点维护一个顺序</p><h3 id="临时节点-EPHEMERAL"><a href="#临时节点-EPHEMERAL" class="headerlink" title="临时节点( EPHEMERAL )"></a>临时节点( EPHEMERAL )</h3><p>临时节点的声明周期和客户端的会话绑定在一起, 当客户端会话失效则该节点自动清理</p><h3 id="临时有序节点-EPHEMERAL"><a href="#临时有序节点-EPHEMERAL" class="headerlink" title="临时有序节点( EPHEMERAL )"></a>临时有序节点( EPHEMERAL )</h3><p>在临时节点的基础上多了一个顺序性. </p><p> CONTAINER  当子节点都被删除后,  CONTAINER  也随即删除,  PERSISTENT_WITH_TTL  超过TTL 未被删除,且没有子节点  PERSISTENT_SEQUENTIAL_WITH_TTL  客户端断开连接后不会主动删除Znode, 如果该Znode 没有子Znode 且在给定的TTL 时间无修改, 该Znode 将会被删除;TTL 单位是毫秒, 必须大于0 且小于或等于  EphemeralType.MAX_TTL </p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><img src="http://files.luyanan.com//img/20191107165150.png"></p><ol><li>Client 初始化连接, 状态转为  CONNECTING ( ① )</li><li>Client 与Server 成功建立连接, 状态改为 CONNECTED(②) </li><li>Client 丢失了与Server 的连接或者没有接收到Server 的响应, 状态改为  CONNECTING(③) </li><li>Client 连上另外的Server 或连接上了之前的Server, 状态改为 CONNECTED(②) </li><li>若会话过期(是Server 负责声明会话过期, 而不是Client),状态改为 CLOSED(⑤)， </li><li>Client 也可以主动关闭会话 (④)， 状态转为 CLOSED </li></ol><h3 id="stat-状态信息"><a href="#stat-状态信息" class="headerlink" title="stat 状态信息"></a>stat 状态信息</h3><p>每个节点除了存储数据内容以外,还存储了数据节点本身的一些状态信息, 通过get命令可以获取状态信息的详细内容. </p><p><img src="http://files.luyanan.com//img/20191107211935.png"></p><h3 id="版本-保证分布式数据原子性"><a href="#版本-保证分布式数据原子性" class="headerlink" title="版本-保证分布式数据原子性"></a>版本-保证分布式数据原子性</h3><p>zookeeper为数据节点引入了版本的概念, 每个数据节点都有三类版本信息, 对数据节点任何更新操作都会引起版本号的变化. </p><p><img src="http://files.luyanan.com//img/20191107212207.png"></p><p>版本有点和我们经常使用的乐观锁类似. 这里有两个概念说一下，一个是悲观锁, 一个是乐观锁. </p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁:"></a>悲观锁:</h4><p>是数据库中一种非常典型且非常严格的并发控制策略. 假如一个事务A 正在对数据进行处理, 那么在整个处理过程中, 都会将数据处于锁定状态, 在这期间其他事务无法对数据进行更新操作 . </p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁和悲观锁正好相反, 它假定多个事务在处理过程中不会彼此影响, 因此在事务处理过程中不需要进行加锁处理, 如果多个事务对同一数据做更改, 那么在更新请求提交之前,每个事务都会首先检查当前事务读取事务后,是否有其他事务对数据进行了修改. 如果有修改, 则回滚事务再回到zookeeper. version 属性就是用来实现乐观锁机制的”写入校验”的. </p><h2 id="Watcher-机制"><a href="#Watcher-机制" class="headerlink" title="Watcher 机制"></a>Watcher 机制</h2><p>zookeeper 提供了分布式数据的发布/订阅功能,zookeeper 允许客户端向服务端注册一个watcher 监听, 当服务端的一些指定事件触发了watcher, 那么服务器就会向客户端发送一个事件通知. </p><p>值得注意的是, watcher 通知是一次性的,即一旦触发一次通知后,该watcher 就失效了, 因此客户端需要反复注册Wacher,即程序中在process 里面又注册了watcher , 否则, 将无法获取c3节点的创建而导致子节点变化的事件. </p><h2 id="zookeeper-基于Java-访问"><a href="#zookeeper-基于Java-访问" class="headerlink" title="zookeeper 基于Java 访问"></a>zookeeper 基于Java 访问</h2><p>针对zookeeper, 比较常用的java 客户端有 zkclient、curator. 由于curator 对于zookeeper 的抽象层次比较高, 简化了zookeeper 客户端的开发量. 使得curator 逐步被广泛使用. </p><ol><li><p>封装了 zookeeper client 与 zookeeper server 之间的连接处理. </p></li><li><p>提供了一套 fluent 风格的操作API. </p></li><li><p>提供了 zookeeper的各种应用场景(共享锁、leader 选举)的抽象封装. </p><h3 id="依赖jar"><a href="#依赖jar" class="headerlink" title="依赖jar"></a>依赖jar</h3></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zookeeper的jar--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework framework = CuratorFrameworkFactory</span><br><span class="line">            .builder()</span><br><span class="line">            <span class="comment">// 连接信息</span></span><br><span class="line">            .connectString(connect)</span><br><span class="line">            <span class="comment">// 会话超时时间</span></span><br><span class="line">            .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">            <span class="comment">//失败重试机制</span></span><br><span class="line">            <span class="comment">//ExponentialBackoffRetry</span></span><br><span class="line">            <span class="comment">//RetryOneTime  仅仅只重试一次</span></span><br><span class="line">            <span class="comment">//RetryUntilElapsed</span></span><br><span class="line">            <span class="comment">//RetryNTimes</span></span><br><span class="line">            .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略:"></a>重试策略:</h3><p>Curator 内部实现的几种重试策略: </p><ul><li> ExponentialBackoffRetry : 重试指定的次数, 且每一次重试之后停顿的时间逐渐增加. </li><li> RetryNTimes : 指定最大重试次数的重试策略. </li><li> RetryOneTime : 仅重试一次. </li><li> RetryUntilElapsed : 一直重试直到达到规定的时间. </li></ul><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>值得注意的是 session2 会话含有隔离命名空间, 即客户端对zookeeper  上数据节点 的任何操作都是相对/curator 目录进行的, 这有利于实现不同的zookeeper 的业务之间的隔离. </p></blockquote><h3 id="节点的增删改查"><a href="#节点的增删改查" class="headerlink" title="节点的增删改查"></a>节点的增删改查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    String connect = <span class="string">&quot;192.168.13.102:2181,192.168.13.103:2181,192.168.13.104:2181&quot;</span>;</span><br><span class="line">    String path = <span class="string">&quot;/data/program&quot;</span>;</span><br><span class="line">    String value = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    CuratorFramework framework = createClient(connect);</span><br><span class="line">    <span class="comment">// 创建数据节点</span></span><br><span class="line">    createData(framework, path, value);</span><br><span class="line">    System.out.println(<span class="string">&quot;创建的&quot;</span> + path + <span class="string">&quot;节点,数据为:&quot;</span> + getData(framework, path));</span><br><span class="line">    <span class="comment">// 修改节点</span></span><br><span class="line">    updateData(framework, path, <span class="string">&quot;newTest&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改的&quot;</span> + path + <span class="string">&quot;节点,数据为:&quot;</span> + getData(framework, path));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    deleteData(framework, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;删除节点&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> framework</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">(CuratorFramework framework, String nodePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">    String value = <span class="keyword">new</span> String(framework.getData().storingStatIn(stat).forPath(nodePath));</span><br><span class="line">    framework.delete().withVersion(stat.getAversion()).forPath(nodePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;修改节点&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> framework</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodePath  节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value     新的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(CuratorFramework framework, String nodePath, String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    framework.setData().forPath(nodePath, value.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;查询节点&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(CuratorFramework framework, String nodePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(framework.getData().forPath(nodePath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;创建节点&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> framework</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createData</span><span class="params">(CuratorFramework framework, String nodePath, String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    framework</span><br><span class="line">            .create()</span><br><span class="line">            <span class="comment">//如果没有父节点则创建</span></span><br><span class="line">            .creatingParentsIfNeeded()</span><br><span class="line">            <span class="comment">// 节点类型</span></span><br><span class="line">            .withMode(CreateMode.PERSISTENT)</span><br><span class="line">            .forPath(nodePath, value.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title">createClient</span><span class="params">(String connect)</span> </span>&#123;</span><br><span class="line">    CuratorFramework framework = CuratorFrameworkFactory</span><br><span class="line">            .builder()</span><br><span class="line">            <span class="comment">// 连接信息</span></span><br><span class="line">            .connectString(connect)</span><br><span class="line">            <span class="comment">// 会话超时时间</span></span><br><span class="line">            .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">            <span class="comment">//失败重试机制</span></span><br><span class="line">            <span class="comment">//ExponentialBackoffRetry</span></span><br><span class="line">            <span class="comment">//RetryOneTime  仅仅只重试一次</span></span><br><span class="line">            <span class="comment">//RetryUntilElapsed</span></span><br><span class="line">            <span class="comment">//RetryNTimes</span></span><br><span class="line">            .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> framework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="节点权限设置"><a href="#节点权限设置" class="headerlink" title="节点权限设置"></a>节点权限设置</h3><p>zookeeper 作为一个分布式协调框架, 内部存储了一些分布式系统运行时的状态的数据, 比如master 选举、比如分布式锁. 对这些数据的操作会直接影响到分布式系统的运行状态。 因此, 为了保证zookeeper 中的数据的安全性, 避免误操作带来的影响. zookeeper 提供了一套ACL 权限控制机制来保证数据的安全. </p><h4 id="权限控制的案例演示"><a href="#权限控制的案例演示" class="headerlink" title="权限控制的案例演示"></a>权限控制的案例演示</h4><h5 id="给节点赋权"><a href="#给节点赋权" class="headerlink" title="给节点赋权"></a>给节点赋权</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给节点赋权</span></span><br><span class="line"> List&lt;ACL&gt; aclList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> Id id1 = <span class="keyword">new</span> Id(<span class="string">&quot;digest&quot;</span>, DigestAuthenticationProvider.generateDigest(<span class="string">&quot;u1:uu&quot;</span>));</span><br><span class="line"> Id id2 = <span class="keyword">new</span> Id(<span class="string">&quot;digest&quot;</span>, DigestAuthenticationProvider.generateDigest(<span class="string">&quot;u2:uu&quot;</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// u1 有所有的权限</span></span><br><span class="line"> aclList.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL, id1));</span><br><span class="line"> <span class="comment">// u2 有读和删除的权限</span></span><br><span class="line"> aclList.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ  | ZooDefs.Perms.DELETE, id2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> framework.create().withACL(aclList).forPath(<span class="string">&quot;/data&quot;</span>);</span><br><span class="line"> framework.create().withACL(ZooDefs.Ids.CREATOR_ALL_ACL).forPath(<span class="string">&quot;/data&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="访问授权的节点"><a href="#访问授权的节点" class="headerlink" title="访问授权的节点"></a>访问授权的节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String connect = <span class="string">&quot;192.168.13.102:2181,192.168.13.103:2181,192.168.13.104:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">  CuratorFramework framework = CuratorFrameworkFactory.builder()</span><br><span class="line">          .connectString(connect)</span><br><span class="line">          <span class="comment">// 带着用户信息创建连接</span></span><br><span class="line">          .authorization(<span class="string">&quot;digest&quot;</span>,<span class="string">&quot;admin:admin&quot;</span>.getBytes())</span><br><span class="line">          .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">          .namespace(<span class="string">&quot;curator&quot;</span>)</span><br><span class="line">          .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="修改已经存在节点的权限"><a href="#修改已经存在节点的权限" class="headerlink" title="修改已经存在节点的权限"></a>修改已经存在节点的权限</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改已经存在节点的权限</span></span><br><span class="line">framework.setACL().withACL(aclList).forPath(<span class="string">&quot;/data&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h4><p> 权限模式分为 Schema 和授权对象, 比如 IP地址、username:passwrod,用来确定权限验证过程中使用的验证策略</p><ol><li><strong>IP</strong> : 通过ip 地址粒度来进行权限控制, 例如配置 [ip:192.168.0.1],或者按照网段 [ip:192.168.0.1/24]</li><li><strong>Digest</strong> :  最常见的控制模式, 类似于 username:password,  设置的时候需要 DigestAuthenticationProvider.generateDigest() SHA- 加 密 和 base64 编码 </li><li><strong>World</strong> : 最开放的控制模式, 这种权限控制几乎没有任何作用, 数据的访问权限对所有用户开发,  <code>world:anyone</code></li><li><strong>Super</strong>:  超级用户, 可以对节点做任何操作. </li></ol><h4 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h4><p>指权限赋予的用户或者一个指定的实体, 不同的权限模式下，授权对象不同. </p><p><img src="http://files.luyanan.com//img/20191107221435.png"></p><blockquote><p>  Id ipId1 = new Id(“ip”, “192.168.190.1”);</p><p> Id ANYONE_ID_UNSAFE = new Id(“world”, “anyone”);  </p></blockquote><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>指通过权限检查后的可以被允许的操作, create/delete/read/write/admin</p><ul><li>create: 允许对子节点create 操作. </li><li>read:  允许对本节点getCliendren  和getData 操作. </li><li>write : 允许对本节点setData 操作. </li><li>delete : 允许对子节点 delete 操作. </li><li>admin: 允许对本节点 setAcl 操作. </li></ul><h3 id="节点事件监听"><a href="#节点事件监听" class="headerlink" title="节点事件监听"></a>节点事件监听</h3><p>Watcher 监听机制是Zookeeper 中非常重要的特性, 我们基于zookeeper 上创建的节点, 可以对这些节点绑定监听事件. 比如可以监听节点数据变更、节点删除、子节点状态变更等事件.通过这个事件机制, 可以基于zookeeper 实现分布式锁、集群管理等功能. </p><table><thead><tr><th>zookeeper 事件</th><th>事件含义</th></tr></thead><tbody><tr><td>EventType.NodeCreated</td><td>当node-x 这个节点被创建时, 该事件被触发</td></tr><tr><td>EventType.NodeChildrenChanged</td><td>当node-x 这个节点的直接子节点被创建、删除、修改的时候触发</td></tr><tr><td>EventType.NodeDataChanged</td><td>当 node-x  这个节点的数据发生变更的时候,该事件被触发</td></tr><tr><td>EventType.NodeDeleted</td><td>当node-x 这个节点被删除的时候,该事件被触发</td></tr><tr><td>EventType.None</td><td>当zookeeper客户端的连接状态发生变更时, 被 触发</td></tr></tbody></table><p>watcher 机制有一个特性,当数据发生改变的时候, 那么zookeeper 会产生一个watcher 事件并发送到客户端,但是客户端只会收到一次这样的通知，如果以后这个数据再发生变化, 那么之前设置watch】的客户端不会再收到消息. 因为他是一次性的, 如果要实现永久监听, 可以通过循环注册来实现. </p><p>curator 对节点事件的监听提供了很完善的api, 接下来简单来演示一下 curator 事件监听的基本使用. </p><p>curator 提供了三种Watcher 来监听节点的变化</p><ul><li>PathChildCache: 监视一个路径下孩子节点的创建、删除、更新. </li><li>NodeCache: 监视当前节点的创建、更新、删除并将节点的数据缓存在本地. </li><li>TreeCache: PathChildCache 和NodeCache 的结合体, 监视路径下的创建、更新、删除事件, 并缓存路径下的所有孩子节点的数据. </li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;分布式协调服务的zookeeper应用实战&quot;&gt;&lt;a href=&quot;#分布式协调服务的zookeeper应用实战&quot; class=&quot;headerlink&quot; title=&quot;分布式协调服务的zookeeper应用实战&quot;&gt;&lt;/a&gt;分布式协调服务的zookeeper应用实战&lt;/h1&gt;&lt;h2 id=&quot;集群角色&quot;&gt;&lt;a href=&quot;#集群角色&quot; class=&quot;headerlink&quot; title=&quot;集群角色&quot;&gt;&lt;/a&gt;集群角色&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20191106154252.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据模型&quot;&gt;&lt;a href=&quot;#数据模型&quot; class=&quot;headerlink&quot; title=&quot;数据模型&quot;&gt;&lt;/a&gt;数据模型&lt;/h2&gt;&lt;p&gt;zookeeper的视图结构和标准的文件系统非常类似, 每一个节点称之为ZNode, 是zookeeper的最小单元. 每个znode 上都可以保存数据以及挂载子节点. 构成一个层次化树形结构. &lt;/p&gt;</summary>
    
    
    
    
    <category term="zookeeper" scheme="http://luyanan.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/Zookeeper%E5%8E%9F%E7%90%86%E4%B9%8BLeader%E9%80%89%E4%B8%BE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://luyanan.com/Zookeeper%E5%8E%9F%E7%90%86%E4%B9%8BLeader%E9%80%89%E4%B8%BE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-03-01T09:46:52.942Z</published>
    <updated>2020-12-24T09:34:50.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper原理之Leader选举源码分析"><a href="#Zookeeper原理之Leader选举源码分析" class="headerlink" title="Zookeeper原理之Leader选举源码分析"></a>Zookeeper原理之Leader选举源码分析</h1><h2 id="Zookeeper-的一致性"><a href="#Zookeeper-的一致性" class="headerlink" title="Zookeeper 的一致性"></a>Zookeeper 的一致性</h2><h3 id="Zookeeper-的来源"><a href="#Zookeeper-的来源" class="headerlink" title="Zookeeper 的来源"></a>Zookeeper 的来源</h3><p>对于zookeeper的一致性问题, 我们再从来源问题梳理一遍一致性的问题. </p><p>我们知道zookeeper的来源, 是来自于Google chubby, 为了分布式环境下, 如何从多个server 中选举出master server. 那么这么多个server 就需要涉及到一致性问题, 这个一致性体现的是多个server 就master 这个投票在分布式环境下达成一致性. 简单来说, 就是最终听谁的. 但是在网络环境中由于网络环境的不可靠性, 会存在消息丢失或者被篡改等问题. 所以如何在这样一个环境中快速并且正确的在多个server 中对某一个数据达成一致性并且保证无论发生任何异常, 都不会破坏整个系统一致性呢? </p><p>所以Lampot大神设计了一套Paxos算法, 多个server 基于这个算法就可以达成一致性。而Google chubby 就是基于paxos 算法的实现, 用来实现分布式锁服务. 并且提供了master 选举的服务. </p><h3 id="Paxos-在chubby-中的应用"><a href="#Paxos-在chubby-中的应用" class="headerlink" title="Paxos 在chubby 中的应用"></a>Paxos 在chubby 中的应用</h3><p>也许大家会有疑问, Chubby 于paxos 算法有什么关系呢? Chubby 本来应该被设计成一个包含Paxos 算法的协议库, 使得应用程序可以基于这个库方便的使用paxos 算法, 但是它并没有这么做, 而是把chubby 设计成了一个需要访问中心化节点的分布式锁服务. 既然是 一个服务, 那么它肯定需要是一个高可靠的服务. 所以Chubby 被构建成了一个集群, 集群中存在一个中心节点(master), 采用paxos协议, 通过投票的方式来选举一个获取过半皮票数的服务器作为master, 在chubby集群中, 每个服务器都会维护一份数据的副本, 在实际运行的过程中, 只有master  服务器能执行事务操作, 其他服务器都是使用paxos 协议从master 节点同步最新的数据, 而zookeeper 是chubby 的开源实现, 所以实现原理和chubby 基本是一致性的. </p><h3 id="zookeeper-的一致性是什么情况呢"><a href="#zookeeper-的一致性是什么情况呢" class="headerlink" title="zookeeper 的一致性是什么情况呢?"></a>zookeeper 的一致性是什么情况呢?</h3><p>zookeeper的一致性, 体现的是什么一致性呢? </p><p>根据前面讲的zab 协议的同步流程, 在zookeeper 集群内部的数据副本同步,是基于过半提交的策略,意味着他是最终一致性, 并不满足强一致性的要求. </p><p>其实正确来说, zookeeper是一个顺序一致性模型. 由于zookeeper 设计出来是提供分布式锁服务, 那么意味着它本身需要实现顺序一致性 （ <a href="http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.ht">http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.ht</a> ml#ch_zkGuarantees ） </p><p>顺序一致性是在分布式环境下实现分布式锁的基本要求, 比如当一个多个程序来争抢锁, 如果ClientA 获得锁后,后续所有来挣钱锁的程序看到的锁的状态都应该是被ClientA 锁定了, 而不是其他状态. </p><h3 id="什么是顺序一致性"><a href="#什么是顺序一致性" class="headerlink" title="什么是顺序一致性"></a>什么是顺序一致性</h3><p>在讲顺序一致性之前, 咱们先思考一个问题, 假如说zookeeper是 一个最终一致性模型, 那么它会发生什么情况? </p><p>ClientA/B/C 假设只串行执行, ClientA 更新zookeeper 上的一个值x. ClientB 和ClientC 分别读取集群中的不同副本, 返回的x 的值是不一样的. ClientC 的读取操作是发生在clientB 之后, 但是却读到了过期的值. 很明显, 这是一种弱一致性模型. 如果用它来实现锁机制是有问题的. </p><p><img src="http://files.luyanan.com//img/20191113100127.png"></p><p>顺序一致性提供了更强的一致性保证, 我们来观察下面这个图, 从时间轴来看, B0 发生在A0之前, 读取的值是0, B2 发生在A0之后，读取到的x 的值为1, 而读操作B1/C0/C1 和写操作A0 在时间轴上有重叠, 因此他们可能读的旧的值为0, 也有可能读取到新的值1, 但是在强顺序一致性模型中, 如果B1得到的x的值为1, 那么C1看到的值也一定为1. </p><p><img src="http://files.luyanan.com//img/20191113100912.png"></p><p>需要注意的是,由于网络的延迟以及系统本身执行请求的不确定性, 会导致请求发起的客户端不一定会在服务端执行的早。最终以服务端执行的结果为准. </p><p>简单来说: 顺序一致性是针对单个操作, 单个数据对象. 属于CAP中C 这个范畴. 一个数据被更新后, 能够立马被后续的操作读到. </p><p>但是zookeeper的 顺序一致性实现是缩水版本, 在下面的这个网页中,可以看到官网对于一致性的这块做了解释. </p><p><a href="http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.html#ch_zkGuarantees">http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.html#ch_zkGuarantees</a></p><p>zookeeper 不保证在每个实例中, 两个不同的客户端具有相同的zookeeper 数据视图, 由于网络延迟等因素, 一个客户端可能会在另外一个客户端收到更改通知之前执行更新, </p><p>考虑到2个客户端A 和B 的场景, 如果A 把znode /a 的值从0设置为1, 然后告诉客户端B 读取/a, 则客户端B 可能读取到旧的值0, 具体取决于他连接到的服务器, 如果客户端A 和B 要读取 必须要读取到想听的值, 那么ClientB 在读取操作之前要执行sync方法. </p><p>除此之外, zookeeper 基于zxid 以及阻塞队列的方式来实现请求的顺序一致性. 如果client 连接到一个最新的follower 上, 那么它read 读取到了最近的数据, 然后client 由于网络原因重新连接到zookeeper 节点, 而这个时候连接到一个还没有完成数据同步的follower节点, 那么这一次读取到的数据不就是旧的数据了吗? 实际上zookeeper 处理了这种情况, client 会记录自己已经读取到的最大的zxid, 如果client 重连到server 发现client 的zxid 比自己的大. 连接会失败. </p><h3 id="Single-System-Image-的理解"><a href="#Single-System-Image-的理解" class="headerlink" title="Single System Image 的理解"></a>Single System Image 的理解</h3><p> zookeeper 官网还说它保证了 “Single System Image “, 其解释为 “ A client will see the same view of the service regardless of the server that it connects to ”. 实际上看来这个解释还是有一点误导性的. 其实由上面的zxid 原理就可以看出来, 它表达的意思是 client 只要连接过一次zookeeper, 就不会有历史的倒退. </p><p><a href="https://github.com/apache/zookeeper/pull/931">https://github.com/apache/zookeeper/pull/931</a></p><h2 id="Leader选举的原理"><a href="#Leader选举的原理" class="headerlink" title="Leader选举的原理"></a>Leader选举的原理</h2><p>接下来我们基于源码来分析leader 选举的整个过程, </p><p>Leader 选举存在两个阶段, 一个是服务器启动时的leader 选举, 另一个是运行过程中leader 节点宕机导致的leader 选举。 </p><blockquote><p>在开始分析选举的原理之前, 先了解几个重要的参数。</p><h4 id="服务器id-myid"><a href="#服务器id-myid" class="headerlink" title="服务器id(myid)"></a>服务器id(myid)</h4><p>​    比如有三台服务器, 编号分别是1,2,3</p><p>​    编号越大在选择算法中的权重越大</p><p>​    zxid 事务id</p><p>值越大说明数据越新,在选举算法中的权重也越大</p><h4 id="逻辑时钟-epoch-logicalclock"><a href="#逻辑时钟-epoch-logicalclock" class="headerlink" title="逻辑时钟(epoch - logicalclock)"></a>逻辑时钟(epoch - logicalclock)</h4><p>或者叫投票的次数, 同一轮投票过程中的逻辑时钟值是相同的. 每投完一票这个数据就会增加, 然后与接收到的其他服务器返回的投票信息中的数值相比,根据不同的值做出不同的判断. </p><h4 id="选举状态"><a href="#选举状态" class="headerlink" title="选举状态"></a>选举状态</h4><p>​    LOOKING: 竞选状态。 </p><p>​    FOLLOWING: 随从状态, 同步leader 状态, 参与投票</p><p>​    OBSERVING : 观察状态, 同步leader 状态, 不参与投票. </p><p>​      LEADING :  领导者状态</p></blockquote><h3 id="服务器启动的时候leader-选举"><a href="#服务器启动的时候leader-选举" class="headerlink" title="服务器启动的时候leader 选举"></a>服务器启动的时候leader 选举</h3><p>每个节点启动的时候状态都是LOOKING ,处于观望状态, 接下来就进行选主流程. </p><p>若进行leader选举, 则至少需要两台机器, 这里选取3台机器组成的服务器集群为例. 在集群初始化阶段,当有一台服务器server1 启动时, 其单独无法进行和完成leader 选举。 当第二台服务器server2 启动的时候, 此时两台机器可以相互通信,每台机器都试图找到leader, 于是进入leader 选举过程. 选举过程如下:</p><ol><li><p>每个server 发出一个投票, 由于是初始情况, server1 和server2 都会将自己作为leader 服务器来进行投票, 每次投票都会包含所推荐的服务器的myid 和zxid、rpoch,使用(myid,zxid,epoch)来标识, 此时server1 的投票为(1,0),server2 的投票为(2,0),然后各自将这个投票发送给集群中的其他机器. </p></li><li><p>接受来自各个服务器的投票, 集群的每个服务器收到投票后, 首先判断该投票的有效性, 如检查是否为本轮投票(epoch)、是否来自 LOOKING  状态的服务器. </p></li><li><p>处理投票, 针对每一个投票, 服务器都需要将别人的投票来自己的投票进行PK,PK 规则如下: </p><ol><li><p>优先比较 epoch</p></li><li><p>其次检查zxid, zxid 比较大的服务器优先为leader</p></li><li><p>如果zxid 相同,  那么比较myid, myid 较大的服务器作为leader 服务器. </p><p>对于server1 而言,它的投票是(1,0),  接受server2 的投票 为(2,0), 首先会比较两者的zxid,均为0, 再比较myid, 此时server2 的myid 最大, 于是更新自己的投票为(2,0), 然后重新开始投票, 对于server2而言, 其无需更新自己的投票, 只是再次向集群中所有寄去发出上一个投票信息即可. </p></li></ol></li><li><p>统计投票</p><p>   每次投票后, 服务器都会统计投票信息, 判断是否已经有过接受到相同的投票信息, 对于server1 、server2而言, 都统计出集群中已经有2台机器接受了(2,0) 的投票信息, 此时便认为已经选出了leader. </p></li><li><p>改变服务器状态</p><p>  一旦确定了leader, 每个服务器都会更新自己的状态, 如果是follower, 那么就变更为following, 如果是leader, 就变更为leading. </p></li></ol><h3 id="运行过程中的leader-选举"><a href="#运行过程中的leader-选举" class="headerlink" title="运行过程中的leader 选举"></a>运行过程中的leader 选举</h3><p>当集群中的leader 服务器出现宕机或者不可用的情况下, 那么整个集群将无法对外提供服务, 而是进入新一轮的leader 选举, 服务器运行期间的leader 选举和启动时候的leader 选举基本过程是一致的. </p><ol><li><p>变更状态</p><p> Leader 挂后, 余下的废Observer 服务器都会将自己的服务器状态变更为LOOKING，然后进入到leader 选举过程. </p></li><li><p>每个server 会发出一个投票, 在运行期间, 每个服务器的zxid 可能不同, 此时假设server1 的zxid 为123, server3的zxid 为122, 在第一轮的投票中,server1 和server3 都投自己, 产生投票(1,123),(3,122), 然后各自将投票发送给集群中所有机器. 接受来自各个服务器的投票,与启动时过程相同. </p></li><li><p>处理投票, 与启动时过程相同, 此时， server1 将会成为leader</p></li><li><p>统计投票.与启动时过程相同. </p></li><li><p>改变服务器状态</p></li></ol><p><img src="http://files.luyanan.com//img/20191113134052.png"></p><h2 id="Leader-选举的源码分析"><a href="#Leader-选举的源码分析" class="headerlink" title="Leader 选举的源码分析"></a>Leader 选举的源码分析</h2><p>源码分析, 最关键是要好一个入口, 对于zk 的leader 选举, 并不是由客户端触发的, 而是在启动的时候会触发一次选举. 所以我们们可以直接去看启动脚本 zkServer.sh 中的命令. </p><p>ZOOMAIN 就是QuorumPeerMain,我们基于这个入口来看</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup &quot;$JAVA&quot; $ZOO_DATADIR_AUTOCREATE &quot;-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;&quot; \&quot;-Dzookeeper.log.file=$&#123;ZOO_LOG_FILE&#125;&quot; &quot;-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;&quot; \-XX:+HeapDumpOnOutOfMemoryError -XX:OnOutOfMemoryError=&#x27;kill -9 %p&#x27; \-cp &quot;$CLASSPATH&quot; $JVMFLAGS $ZOOMAIN &quot;$ZOOCFG&quot; &gt; &quot;$_ZOO_DAEMON_OUT&quot; 2&gt;&amp;1 &lt; /dev/null &amp;</span><br></pre></td></tr></table></figure></blockquote><h3 id="QuorumPeerMain-的main方法"><a href="#QuorumPeerMain-的main方法" class="headerlink" title="QuorumPeerMain 的main方法"></a>QuorumPeerMain 的main方法</h3><p>main方法中,调用了initializeAndRun()  方法进行初始化并且运行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> ConfigException, IOException, AdminServerException </span>&#123;</span><br><span class="line">       <span class="comment">// 设置配置参数, 如果args 不为0, 可以基于外部的配置路径来进行解析</span></span><br><span class="line">       QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">       <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">           config.parse(args[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">       <span class="comment">// 这里启动了一个线程, 来定时对日志进行清理</span></span><br><span class="line">       DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">               .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">               .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">       purgeMgr.start();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果是集群模式, 会调用runFromConfig servers 其实就是我们在zoo.cfg 中配置的集群节点</span></span><br><span class="line">       <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">           runFromConfig(config);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Either no config or no quorum defined in config, running &quot;</span></span><br><span class="line">                   + <span class="string">&quot; in standalone mode&quot;</span>);</span><br><span class="line">           <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">           ZooKeeperServerMain.main(args);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="runFromConfig-config"><a href="#runFromConfig-config" class="headerlink" title="runFromConfig(config)"></a>runFromConfig(config)</h4><p>从名字可以看出, 是基于配置文件来进行启动。</p><p>所以整个方法都是对参数进行解析和设置, 直接看核心的代码quorumPeer.start();,启动一个线程, 那么从这句代码可以看出来 QuorumPeerMain 其实是继承了一个Thread, 那么这里面一定有一个run方法. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, AdminServerException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ManagedUtil.registerLog4jMBeans();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMException e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Unable to register log4j JMX control&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerCnxnFactory cnxnFactory = <span class="keyword">null</span>;</span><br><span class="line">            ServerCnxnFactory secureCnxnFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (config.getClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">                cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                        config.getMaxClientCnxns(),</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (config.getSecureClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                secureCnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">                secureCnxnFactory.configure(config.getSecureClientPortAddress(),</span><br><span class="line">                        config.getMaxClientCnxns(),</span><br><span class="line">                        <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            quorumPeer = getQuorumPeer();</span><br><span class="line">            quorumPeer.setTxnFactory(<span class="keyword">new</span> FileTxnSnapLog(</span><br><span class="line">                    config.getDataLogDir(),</span><br><span class="line">                    config.getDataDir()));</span><br><span class="line">            quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());</span><br><span class="line">            quorumPeer.enableLocalSessionsUpgrading(</span><br><span class="line">                    config.isLocalSessionsUpgradingEnabled());</span><br><span class="line">            <span class="comment">//quorumPeer.setQuorumPeers(config.getAllMembers());</span></span><br><span class="line">            quorumPeer.setElectionType(config.getElectionAlg());</span><br><span class="line">            quorumPeer.setMyid(config.getServerId());</span><br><span class="line">            quorumPeer.setTickTime(config.getTickTime());</span><br><span class="line">            quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span><br><span class="line">            quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span><br><span class="line">            quorumPeer.setInitLimit(config.getInitLimit());</span><br><span class="line">            quorumPeer.setSyncLimit(config.getSyncLimit());</span><br><span class="line">            quorumPeer.setConfigFileName(config.getConfigFilename());</span><br><span class="line">            quorumPeer.setZKDatabase(<span class="keyword">new</span> ZKDatabase(quorumPeer.getTxnFactory()));</span><br><span class="line">            quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (config.getLastSeenQuorumVerifier() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            quorumPeer.initConfigInZKDatabase();</span><br><span class="line">            quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">            quorumPeer.setSecureCnxnFactory(secureCnxnFactory);</span><br><span class="line">            quorumPeer.setSslQuorum(config.isSslQuorum());</span><br><span class="line">            quorumPeer.setUsePortUnification(config.shouldUsePortUnification());</span><br><span class="line">            quorumPeer.setLearnerType(config.getPeerType());</span><br><span class="line">            quorumPeer.setSyncEnabled(config.getSyncEnabled());</span><br><span class="line">            <span class="comment">// 投票决定方式, 默认超过半数就通过. </span></span><br><span class="line">            quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</span><br><span class="line">            <span class="keyword">if</span> (config.sslQuorumReloadCertFiles) &#123;</span><br><span class="line">                quorumPeer.getX509Util().enableCertFileReloading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sets quorum sasl authentication configurations</span></span><br><span class="line">            quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</span><br><span class="line">            <span class="keyword">if</span> (quorumPeer.isQuorumSaslAuthEnabled()) &#123;</span><br><span class="line">                quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</span><br><span class="line">                quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</span><br><span class="line">                quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</span><br><span class="line">                quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</span><br><span class="line">                quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</span><br><span class="line">            &#125;</span><br><span class="line">            quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</span><br><span class="line">            quorumPeer.initialize();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动主线程. </span></span><br><span class="line">            quorumPeer.start();</span><br><span class="line">            quorumPeer.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">            LOG.warn(<span class="string">&quot;Quorum Peer interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="quorumPeer-start"><a href="#quorumPeer-start" class="headerlink" title="quorumPeer.start()"></a>quorumPeer.start()</h4><p> quorumPeer.start() 方法,重写了Thread.start() 方法, 也就是在线程启动之前，会做以下操作:</p><ol><li><p>通过loadDataBase() 恢复快照数据</p></li><li><p>cnxnFactory.start() 启动zkServer, 相当于用户可以通过2181 这个端口号进行通信了. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 恢复快照数据</span></span><br><span class="line">       loadDataBase();</span><br><span class="line">       <span class="comment">// 启动zk服务</span></span><br><span class="line">       startServerCnxnFactory();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           adminServer.start();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">           System.out.println(e);</span><br><span class="line">       &#125;</span><br><span class="line">       startLeaderElection();</span><br><span class="line">       <span class="keyword">super</span>.start();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServerCnxnFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cnxnFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">           cnxnFactory.start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (secureCnxnFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">           secureCnxnFactory.start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="startLeaderElection"><a href="#startLeaderElection" class="headerlink" title="startLeaderElection()"></a>startLeaderElection()</h4><p>leader  选举的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 构建一个票据, 用于投票</span></span><br><span class="line">           currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">           re.setStackTrace(e.getStackTrace());</span><br><span class="line">           <span class="keyword">throw</span> re;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 这个 getView() 返回是在配置文件中配置的server.myid=ip:port:port</span></span><br><span class="line">       <span class="keyword">for</span> (QuorumServer p : getView().values()) &#123;</span><br><span class="line">           <span class="comment">// 获得当前zkserver myid 对应的ip地址</span></span><br><span class="line">           <span class="keyword">if</span> (p.id == myid) &#123;</span><br><span class="line">               myQuorumAddr = p.addr;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (myQuorumAddr == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据electionType 匹配对应的选举算法, electionType 默认值为3, 可以在配置文件中动态生成. </span></span><br><span class="line">       <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               udpSocket = <span class="keyword">new</span> DatagramSocket(myQuorumAddr.getPort());</span><br><span class="line">               responder = <span class="keyword">new</span> ResponderThread();</span><br><span class="line">               responder.start();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="QuorumPeer-createElectionAlgorithm"><a href="#QuorumPeer-createElectionAlgorithm" class="headerlink" title="QuorumPeer.createElectionAlgorithm"></a>QuorumPeer.createElectionAlgorithm</h4><p>根据对应的标识创建选举算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span> </span>&#123;</span><br><span class="line">       Election le = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">       <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">               le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               qcm = createCnxnManager();</span><br><span class="line">               QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">               <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 启动监听</span></span><br><span class="line">                   listener.start();</span><br><span class="line">                   <span class="comment">// 初始化 FastLeaderElection</span></span><br><span class="line">                   le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   LOG.error(<span class="string">&quot;Null listener when initializing cnx manager&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> le;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="FastLeaderElection"><a href="#FastLeaderElection" class="headerlink" title="FastLeaderElection"></a><strong>FastLeaderElection</strong></h4><p>初始化FastLeaderElection , QuorumCnxManager 是一个很核心的对象, 用来实现 领导选举中的网络连接管理功能, </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastLeaderElection</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">this</span>.manager = manager;</span><br><span class="line">       starter(self, manager);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="FastLeaderElection-starter"><a href="#FastLeaderElection-starter" class="headerlink" title="FastLeaderElection.starter"></a>FastLeaderElection.starter</h4><p>starter 方法里面, 设置了一些成员属性, 并且构建了两个阻塞队列, 分别是 sendQueue  和 recvqueue . 并且实例化了一个Messenger </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">starter</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.self = self;</span><br><span class="line">       proposedLeader = -<span class="number">1</span>;</span><br><span class="line">       proposedZxid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       sendqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;ToSend&gt;();</span><br><span class="line">       recvqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Notification&gt;();</span><br><span class="line">       <span class="keyword">this</span>.messenger = <span class="keyword">new</span> Messenger(manager);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h4><p>在 Messenger 中构建了两个线程, 一个是WorkerSender, 一个是WorkerReceiver. 这两个线程是分别用来发送和接受消息的线程. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Messenger(QuorumCnxManager manager) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.ws = <span class="keyword">new</span> WorkerSender(manager);</span><br><span class="line"></span><br><span class="line">          Thread t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.ws,</span><br><span class="line">                  <span class="string">&quot;WorkerSender[myid=&quot;</span> + self.getId() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">          t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">          t.start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.wr = <span class="keyword">new</span> WorkerReceiver(manager);</span><br><span class="line"></span><br><span class="line">          t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.wr,</span><br><span class="line">                  <span class="string">&quot;WorkerReceiver[myid=&quot;</span> + self.getId() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">          t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="阶段性提交"><a href="#阶段性提交" class="headerlink" title="阶段性提交"></a>阶段性提交</h4><p>分析到这里,先做一个简单的总结, 通过一个流程图把前面部分的功能串联起来。 </p><p><img src="http://files.luyanan.com//img/20191113161725.png"></p><h4 id="getView-的解析过程"><a href="#getView-的解析过程" class="headerlink" title="getView() 的解析过程"></a>getView() 的解析过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Long, QuorumPeer.QuorumServer&gt; getView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(<span class="keyword">this</span>.quorumPeers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getView()  里面实际上返回是一个quorumPeers, 就是参与本次投票的成员有哪些? 这个属性在哪里赋值呢?</p><h4 id="QuorumPeerMain-runFromConfig"><a href="#QuorumPeerMain-runFromConfig" class="headerlink" title="QuorumPeerMain.runFromConfig"></a>QuorumPeerMain.runFromConfig</h4><p>设置了一个值为config.getServers(), </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quorumPeer.setQuorumPeers(config.getServers());</span><br></pre></td></tr></table></figure></blockquote><p>config  这个配置信息又是通过 initializeAndRun  方法中初始化的. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置配置参数, 如果args 不为0, 可以基于外部的配置路径来解析</span><br><span class="line">      QuorumPeerConfig config &#x3D; new QuorumPeerConfig();</span><br><span class="line">      if (args.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">          config.parse(args[0]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="QuorumPeerConfig-parse"><a href="#QuorumPeerConfig-parse" class="headerlink" title="QuorumPeerConfig.parse"></a>QuorumPeerConfig.parse</h4><p>这里会根据一个外部的文件去解析, 然后其中一段是这样的, 解析对应的集群信息放到servers 这个集合中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;server.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> dot = key.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="keyword">long</span> sid = Long.parseLong(key.substring(dot + <span class="number">1</span>));</span><br><span class="line">                String parts[] = splitWithLeadingHostname(value);</span><br><span class="line">                <span class="keyword">if</span> ((parts.length != <span class="number">2</span>) &amp;&amp; (parts.length != <span class="number">3</span>) &amp;&amp; (parts.length !=<span class="number">4</span>)) &#123;</span><br><span class="line">                    LOG.error(value</span><br><span class="line">                       + <span class="string">&quot; does not have the form host:port or host:port:port &quot;</span> +</span><br><span class="line">                       <span class="string">&quot; or host:port:port:type&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                LearnerType type = <span class="keyword">null</span>;</span><br><span class="line">                String hostname = parts[<span class="number">0</span>];</span><br><span class="line">                Integer port = Integer.parseInt(parts[<span class="number">1</span>]);</span><br><span class="line">                Integer electionPort = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                electionPort=Integer.parseInt(parts[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">&quot;observer&quot;</span>)) &#123;</span><br><span class="line">                        type = LearnerType.OBSERVER;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">&quot;participant&quot;</span>)) &#123;</span><br><span class="line">                        type = LearnerType.PARTICIPANT;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">&quot;Unrecognised peertype: &quot;</span> + value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (type == LearnerType.OBSERVER)&#123;</span><br><span class="line">                    observers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    servers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h2 id="Zookeeper-服务启动的逻辑"><a href="#Zookeeper-服务启动的逻辑" class="headerlink" title="Zookeeper 服务启动的逻辑"></a>Zookeeper 服务启动的逻辑</h2><p>在讲leader 选举的时候, 有一个 cnxnFactory.start()  方法来启动zk 服务, 这块具体做了什么呢? 我们来分析看看</p><h3 id="QuorumPeerMain-runFromConfig-1"><a href="#QuorumPeerMain-runFromConfig-1" class="headerlink" title="QuorumPeerMain.runFromConfig"></a>QuorumPeerMain.runFromConfig</h3><p>在runFromConfig中， 构建了一个ServerCnxnFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ManagedUtil.registerLog4jMBeans();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (JMException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Unable to register log4j JMX control&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.info(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">          cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                  config.getMaxClientCnxns());</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这个明显是一个工厂模式, 基于这个工厂类创建什么呢? 打开createFactory() 方法看看就知道了. </p><h3 id="ServerCnxnFactory-createFactory"><a href="#ServerCnxnFactory-createFactory" class="headerlink" title="ServerCnxnFactory.createFactory()"></a>ServerCnxnFactory.createFactory()</h3><p>这个方法里面是根据<code>ZOOKEEPER_SERVER_CNXN_FACTORY</code>  来决定创建NIO Server 还是Netty Server</p><p>而默认情况下, 应该是创建一个 NIOServerCnxnFactory </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> ServerCnxnFactory <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      String serverCnxnFactoryName =</span><br><span class="line">          System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</span><br><span class="line">      <span class="keyword">if</span> (serverCnxnFactoryName == <span class="keyword">null</span>) &#123;</span><br><span class="line">          serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</span><br><span class="line">                  .getDeclaredConstructor().newInstance();</span><br><span class="line">          LOG.info(<span class="string">&quot;Using &#123;&#125; as server connection factory&quot;</span>, serverCnxnFactoryName);</span><br><span class="line">          <span class="keyword">return</span> serverCnxnFactory;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          IOException ioe = <span class="keyword">new</span> IOException(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span></span><br><span class="line">                  + serverCnxnFactoryName);</span><br><span class="line">          ioe.initCause(e);</span><br><span class="line">          <span class="keyword">throw</span> ioe;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="quorumPeer-start-1"><a href="#quorumPeer-start-1" class="headerlink" title="quorumPeer.start();"></a>quorumPeer.start();</h3><p>因此, 我们再回到 quorumPeer.start(); 方法中,  cnxnFactory.start()，  应该会调用NIOServerCnxnFactory 这个类去启动一个线程. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 恢复快照数据</span></span><br><span class="line">     loadDataBase();</span><br><span class="line">     <span class="comment">// 启动zk 服务</span></span><br><span class="line">     cnxnFactory.start();</span><br><span class="line">     startLeaderElection();</span><br><span class="line">     <span class="keyword">super</span>.start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="NIOServerCnxnFactory-start"><a href="#NIOServerCnxnFactory-start" class="headerlink" title="NIOServerCnxnFactory.start()"></a>NIOServerCnxnFactory.start()</h3><p>这里通过thread.start  启动一个线程, 那thread 是一个什么对象呢? </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// ensure thread is started once and only once</span></span><br><span class="line">     <span class="keyword">if</span> (thread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">         thread.start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="NIOServerCnxnFactory-configure"><a href="#NIOServerCnxnFactory-configure" class="headerlink" title="NIOServerCnxnFactory.configure"></a>NIOServerCnxnFactory.configure</h3><p>thread  其实构建的是一个zookeeperThread 线程, 并且线程的参数为this, 表示当前NIOServerCnxnFactory 也是实现了线程的类, 那么它必须要重写run() 方法, NIOServer 的初始化以及启动过程就完成的. 并且对2181 这个端口号进行监听, 一旦发现有请求进来, 就执行相应的处理即可. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread thread;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(InetSocketAddress addr, <span class="keyword">int</span> maxcc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        configureSaslLogin();</span><br><span class="line"></span><br><span class="line">        thread = <span class="keyword">new</span> ZooKeeperThread(<span class="keyword">this</span>, <span class="string">&quot;NIOServerCxn.Factory:&quot;</span> + addr);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        maxClientCnxns = maxcc;</span><br><span class="line">        <span class="keyword">this</span>.ss = ServerSocketChannel.open();</span><br><span class="line">        ss.socket().setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        LOG.info(<span class="string">&quot;binding to port &quot;</span> + addr);</span><br><span class="line">        ss.socket().bind(addr);</span><br><span class="line">        ss.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ss.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="选举流程分析"><a href="#选举流程分析" class="headerlink" title="选举流程分析"></a>选举流程分析</h2><p>接下来我们正式分析leader 选举的过程. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 恢复快照数据</span></span><br><span class="line">     loadDataBase();</span><br><span class="line">     <span class="comment">// 启动zk 服务</span></span><br><span class="line">     cnxnFactory.start();</span><br><span class="line">     startLeaderElection();</span><br><span class="line">     <span class="keyword">super</span>.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>很明显,super.start()  表示当前类QuorumPeer 继承了线程, 线程必须要重写run() 方法, 所以我们可以在 QuorumPeer 中找到一个run方法</p><h3 id="QuorumPeer-run"><a href="#QuorumPeer-run" class="headerlink" title="QuorumPeer.run()"></a>QuorumPeer.run()</h3><p>这段代码的逻辑比较长, 粗略看一下结构, 好像也不难 </p><p> PeerState  有几种状态, 分别是: </p><ol><li> LOOKING : 竞选状态</li><li> FOLLOWING:  随从状态. 同步leader 状态, 参与投票</li><li> OBSERVING : 观察状态, 同步leader 状态, 不参与投票. </li><li> LEADING : 领导者状态. </li></ol><p>对于选举来说, 默认都是  LOOKING  状态. </p><p>只有 LOOKING  状态才会去执行选举算法, 每个服务器在启动的时候都会选择自己作为领导，然后将投票信息发送出去, 循环一直到选举出领导为止. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       setName(<span class="string">&quot;QuorumPeer&quot;</span> + <span class="string">&quot;[myid=&quot;</span> + getId() + <span class="string">&quot;]&quot;</span> +</span><br><span class="line">               cnxnFactory.getLocalAddress());</span><br><span class="line"></span><br><span class="line">       LOG.debug(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           jmxQuorumBean = <span class="keyword">new</span> QuorumBean(<span class="keyword">this</span>);</span><br><span class="line">           MBeanRegistry.getInstance().register(jmxQuorumBean, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">for</span> (QuorumServer s : getView().values()) &#123;</span><br><span class="line">               ZKMBeanInfo p;</span><br><span class="line">               <span class="keyword">if</span> (getId() == s.id) &#123;</span><br><span class="line">                   p = jmxLocalPeerBean = <span class="keyword">new</span> LocalPeerBean(<span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">                       jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   p = <span class="keyword">new</span> RemotePeerBean(s);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">           jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Main loop</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 根据选举状态, 选择不同的处理方式</span></span><br><span class="line">           <span class="keyword">while</span> (running) &#123;</span><br><span class="line">               <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">                   <span class="keyword">case</span> LOOKING:</span><br><span class="line">                       LOG.info(<span class="string">&quot;LOOKING&quot;</span>);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 判断是否为只读模式, 通过readonlymode.enabled 开启</span></span><br><span class="line">                       <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;readonlymode.enabled&quot;</span>)) &#123;</span><br><span class="line">                           LOG.info(<span class="string">&quot;Attempting to start ReadOnlyZooKeeperServer&quot;</span>);</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 只读模式的启动流程</span></span><br><span class="line">                           <span class="comment">// Create read-only server but don&#x27;t start it immediately</span></span><br><span class="line">                           <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk = <span class="keyword">new</span> ReadOnlyZooKeeperServer(</span><br><span class="line">                                   logFactory, <span class="keyword">this</span>,</span><br><span class="line">                                   <span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(),</span><br><span class="line">                                   <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                           <span class="comment">// period before we decide we&#x27;re partitioned.</span></span><br><span class="line">                           <span class="comment">//</span></span><br><span class="line">                           <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                           <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                           <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                           Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                   <span class="keyword">try</span> &#123;</span><br><span class="line">                                       <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                       sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                       <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                           roZk.startup();</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                       LOG.info(<span class="string">&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;</span>);</span><br><span class="line">                                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                       LOG.error(<span class="string">&quot;FAILED to start ReadOnlyZooKeeperServer&quot;</span>, e);</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               roZkMgr.start();</span><br><span class="line">                               setBCVote(<span class="keyword">null</span>);</span><br><span class="line">                               <span class="comment">// 设置当前的投票, 通过策略模式来决定当前用哪个选举算法来进行领导选举</span></span><br><span class="line">                               setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                               LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                               setPeerState(ServerState.LOOKING);</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                               <span class="comment">// to come out of waiting.</span></span><br><span class="line">                               roZkMgr.interrupt();</span><br><span class="line">                               roZk.shutdown();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               setBCVote(<span class="keyword">null</span>);</span><br><span class="line">                               setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                               LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                               setPeerState(ServerState.LOOKING);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           LOG.info(<span class="string">&quot;OBSERVING&quot;</span>);</span><br><span class="line">                           setObserver(makeObserver(logFactory));</span><br><span class="line">                           observer.observeLeader();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           observer.shutdown();</span><br><span class="line">                           setObserver(<span class="keyword">null</span>);</span><br><span class="line">                           setPeerState(ServerState.LOOKING);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           LOG.info(<span class="string">&quot;FOLLOWING&quot;</span>);</span><br><span class="line">                           setFollower(makeFollower(logFactory));</span><br><span class="line">                           follower.followLeader();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           follower.shutdown();</span><br><span class="line">                           setFollower(<span class="keyword">null</span>);</span><br><span class="line">                           setPeerState(ServerState.LOOKING);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> LEADING:</span><br><span class="line">                       LOG.info(<span class="string">&quot;LEADING&quot;</span>);</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           setLeader(makeLeader(logFactory));</span><br><span class="line">                           leader.lead();</span><br><span class="line">                           setLeader(<span class="keyword">null</span>);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               leader.shutdown(<span class="string">&quot;Forcing shutdown&quot;</span>);</span><br><span class="line">                               setLeader(<span class="keyword">null</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                           setPeerState(ServerState.LOOKING);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;QuorumPeer main thread exited&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               MBeanRegistry.getInstance().unregisterAll();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               LOG.warn(<span class="string">&quot;Failed to unregister with JMX&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">           jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="FastLeaderElection-lookForLeader"><a href="#FastLeaderElection-lookForLeader" class="headerlink" title="FastLeaderElection .lookForLeader()"></a>FastLeaderElection .lookForLeader()</h3><p>开始发起投票流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           self.jmxLeaderElectionBean = <span class="keyword">new</span> LeaderElectionBean();</span><br><span class="line">           MBeanRegistry.getInstance().register(</span><br><span class="line">                   self.jmxLeaderElectionBean, self.jmxLocalPeerBean);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">           self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (self.start_fle == <span class="number">0</span>) &#123;</span><br><span class="line">           self.start_fle = Time.currentElapsedTime();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">           HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> notTimeout = finalizeWait;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// 更新逻辑时钟, 用来判断是否在同一轮选举周期</span></span><br><span class="line">               logicalclock.incrementAndGet();</span><br><span class="line">               <span class="comment">// 初始化选票数据, 这里其实就是把当前节点的myid,zxid,epoch 更新到本地的成员属性</span></span><br><span class="line">               updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           LOG.info(<span class="string">&quot;New election. My id =  &quot;</span> + self.getId() +</span><br><span class="line">                   <span class="string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(proposedZxid));</span><br><span class="line">           <span class="comment">// 异步发送选举消息</span></span><br><span class="line">           sendNotifications();</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Loop in which we exchange notifications until we find a leader</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 不断循环, 根据投票信息进行leader 选举</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                   (!stop)) &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Remove next notification from queue, times out after 2 times</span></span><br><span class="line"><span class="comment">                * the termination time</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 从 recvqueue 中获取消息</span></span><br><span class="line">               Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                       TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Sends more notifications if haven&#x27;t received enough.</span></span><br><span class="line"><span class="comment">                * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 如果没有获取到外部的投票, 有可能是集群之间的节点没有真正连接上</span></span><br><span class="line">               <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 判断发送队列是否由数据,如果发送队列为空,再发一次自己的选票</span></span><br><span class="line">                   <span class="keyword">if</span> (manager.haveDelivered()) &#123;</span><br><span class="line">                       sendNotifications();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// 再次发起集群节点之间的连接</span></span><br><span class="line">                       manager.connectAll();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Exponential backoff</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="keyword">int</span> tmpTimeOut = notTimeout * <span class="number">2</span>;</span><br><span class="line">                   notTimeout = (tmpTimeOut &lt; maxNotificationInterval ?</span><br><span class="line">                           tmpTimeOut : maxNotificationInterval);</span><br><span class="line">                   LOG.info(<span class="string">&quot;Notification time out: &quot;</span> + notTimeout);</span><br><span class="line">                   ...</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><h3 id="选票的判断逻辑-核心代码"><a href="#选票的判断逻辑-核心代码" class="headerlink" title="选票的判断逻辑(核心代码)"></a>选票的判断逻辑(核心代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 判断收到的选票中的sid 和选举的leader 的sid 是否存在与我们集群锁配置的myid 范围.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</span><br><span class="line">                <span class="comment">// 判断接受到的投票者的状态, 默认是LOOKING 状态, 说明当前发起投票的服务器也是找leader</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Only proceed if the vote comes from a replica in the</span></span><br><span class="line"><span class="comment">                 * voting view for a replica in the voting view.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">switch</span> (n.state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> LOOKING:</span><br><span class="line">                        <span class="comment">// 说明当前发起投票的服务器也是在找leader</span></span><br><span class="line">                        <span class="comment">// 如果收到的投票的逻辑时钟大于当前的节点的逻辑时钟</span></span><br><span class="line">                        <span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line">                        <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">// 更新成新一轮的逻辑时钟</span></span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            recvset.clear();</span><br><span class="line">                            <span class="comment">// 比较接收到的投票和当前节点的细腻些进行比较,比较的顺序</span></span><br><span class="line">                            <span class="comment">// epoch、zxid、myid,如果返回的为true,  在更新当前节点大票据</span></span><br><span class="line">                            <span class="comment">// (sid、zxid、epoch)</span></span><br><span class="line">                            <span class="comment">//那么下一次再发起投票的时候, 就不再选自己了</span></span><br><span class="line">                            <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 否则, 说明当前节点的票据优先级更高, 再次更新自己的票据</span></span><br><span class="line">                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 再次发送消息把当前的票据发出去,告诉大家要选择n.leader  为leader</span></span><br><span class="line">                            sendNotifications();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">// 如果小于, 说明收到的票据已经过期,直接把这张票丢掉</span></span><br><span class="line">                            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                                LOG.debug(<span class="string">&quot;Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x&quot;</span> + Long.toHexString(n.electionEpoch) + <span class="string">&quot;, logicalclock=0x&quot;</span> + Long.toHexString(logicalclock.get()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 这个判断表示收到的票据epoch 是想同的, 那么按照epoch、zxid、myid顺序进行比较,比较成功后,把对方的票据信息更新到自己的节点</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            sendNotifications();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                            LOG.debug(<span class="string">&quot;Adding vote: from=&quot;</span> + n.sid + <span class="string">&quot;, proposed leader=&quot;</span> + n.leader + <span class="string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(n.zxid) + <span class="string">&quot;, proposed election epoch=0x&quot;</span> + Long.toHexString(n.electionEpoch));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将收到的投票信心放入到投票的集合recvset中, 用来做最终的&quot;过半原则&quot; 判断</span></span><br><span class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (termPredicate(recvset, <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch))) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 进入这个判断, 说明选票进入到了leader 选举的要求</span></span><br><span class="line">                            <span class="comment">// 在更新状态之前, 服务器会等待finalizeWait 毫秒时间来接受新的选票,以防止漏下来关键的选票</span></span><br><span class="line">                            <span class="comment">// 如果收到可能改变leader 的选票, 则重新进行计票</span></span><br><span class="line">                            <span class="comment">// Verify if there is any change in the proposed leader</span></span><br><span class="line">                            <span class="keyword">while</span> ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                                    recvqueue.put(n);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * This predicate is true once we don&#x27;t read any new</span></span><br><span class="line"><span class="comment">                             * relevant message from the reception queue</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="comment">// 如果Notification为空,说明leader 节点是已经确定好了</span></span><br><span class="line">                            <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 设置当前节点的状态(判断leader 节点不是我自己, 如果是, 直接更新当前节点的 state 为LEADING)</span></span><br><span class="line">                                <span class="comment">// 否则,根据当前节点的特性进行判断,决定是FOLLOWING 还是OBSERVING</span></span><br><span class="line">                                self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : learningState());</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 组装生成这次leader 选举最终投票的结果.</span></span><br><span class="line">                                Vote endVote = <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);</span><br><span class="line">                                <span class="comment">// 清空 recvqueue</span></span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                <span class="comment">// 返回最终的票据</span></span><br><span class="line">                                <span class="keyword">return</span> endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                        <span class="comment">// OBSERVING 不参与Leader 的选举</span></span><br><span class="line">                        LOG.debug(<span class="string">&quot;Notification from observer: &quot;</span> + n.sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                    <span class="keyword">case</span> LEADING:</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Consider all notifications from the same epoch</span></span><br><span class="line"><span class="comment">                         * together.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (n.electionEpoch == logicalclock.get()) &#123;</span><br><span class="line">                            recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (ooePredicate(recvset, outofelection, n)) &#123;</span><br><span class="line">                                self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : learningState());</span><br><span class="line"></span><br><span class="line">                                Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                <span class="keyword">return</span> endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Before joining an established ensemble, verify</span></span><br><span class="line"><span class="comment">                         * a majority is following the same leader.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (ooePredicate(outofelection, outofelection, n)) &#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                                logicalclock.set(n.electionEpoch);</span><br><span class="line">                                self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : learningState());</span><br><span class="line">                            &#125;</span><br><span class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Notification state unrecognized: &#123;&#125; (n.state), &#123;&#125; (n.sid)&quot;</span>, n.state, n.sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;&quot;</span>, n.leader, n.sid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;&quot;</span>, n.leader, n.sid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self.jmxLeaderElectionBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Failed to unregister with JMX&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Number of connection processing threads: &#123;&#125;&quot;</span>, manager.getConnectionThreadCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if a given sid is represented in either the current or</span></span><br><span class="line"><span class="comment"> * the next voting view</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid Server identifier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validVoter</span><span class="params">(<span class="keyword">long</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.getVotingView().containsKey(sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="投票处理的流程图"><a href="#投票处理的流程图" class="headerlink" title="投票处理的流程图"></a>投票处理的流程图</h3><p><img src="http://files.luyanan.com//img/20191114135751.png"></p><h3 id="termPredicate"><a href="#termPredicate" class="headerlink" title="termPredicate"></a>termPredicate</h3><p>这个方法是使用过半原则来判断选举是否结束的, 如果返回true, 说明能够选出leader 服务器. </p><p> votes  表示收到的外部选票的集合</p><p> vote  表示当前服务器的选票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">termPredicate</span><span class="params">(HashMap&lt;Long, Vote&gt; votes, Vote vote)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * First make the views consistent. Sometimes peers will have</span></span><br><span class="line"><span class="comment">       * different zxids for a server depending on timing.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 遍历接受到的所有票据数据</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Long, Vote&gt; entry : votes.entrySet()) &#123;</span><br><span class="line">          <span class="comment">// 对选票进行归纳, 就是把所有选票数据中和当前节点的票据相同的票据进行统计.</span></span><br><span class="line">          <span class="keyword">if</span> (vote.equals(entry.getValue())) &#123;</span><br><span class="line">              set.add(entry.getKey());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对票据进行判断</span></span><br><span class="line">      <span class="keyword">return</span> self.getQuorumVerifier().containsQuorum(set);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="QuorumMaj-containsQuorum"><a href="#QuorumMaj-containsQuorum" class="headerlink" title="QuorumMaj.containsQuorum"></a>QuorumMaj.containsQuorum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsQuorum</span><span class="params">(Set&lt;Long&gt; set)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (set.size() &gt; half);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个half 的值是多少呢? 可以在 QuorumPeerConfig. parseProperties   这个方法中, 找到如下源码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LOG.info(<span class="string">&quot;Defaulting to majority quorums&quot;</span>);</span><br><span class="line">quorumVerifier = <span class="keyword">new</span> QuorumMaj(servers.size());</span><br></pre></td></tr></table></figure><p>也就是说, 在构建QuorumMaj的时候,传递了当前集群节点的数量, 这里是3. 那么half = 3/2= 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuorumMaj</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.half = n/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 set.size()&gt;1 ,意味着至少有两个节点的票据是选择你当leader , 否则, 还得继续投. </p><h2 id="投票的网络通信过程"><a href="#投票的网络通信过程" class="headerlink" title="投票的网络通信过程"></a>投票的网络通信过程</h2><h3 id="通信流程图"><a href="#通信流程图" class="headerlink" title="通信流程图"></a>通信流程图</h3><p><img src="http://files.luyanan.com//img/20191114140808.png"></p><p><img src="http://files.luyanan.com//img/20191114140956.png"></p><h3 id="接受数据-Notification-和发送数据-ToSend"><a href="#接受数据-Notification-和发送数据-ToSend" class="headerlink" title="接受数据  Notification  和发送数据  ToSend"></a>接受数据  Notification  和发送数据  ToSend</h3><table><thead><tr><th>字段</th><th>Notification</th><th>ToSend</th></tr></thead><tbody><tr><td>leader</td><td>被推荐的服务器sid</td><td>被推荐的服务器sid</td></tr><tr><td>zxid</td><td>被推荐的服务器当前最新的事务id</td><td>被推荐的服务器当前的事务id</td></tr><tr><td>peerEpoch</td><td>被推荐的服务器当前所处的epoch</td><td>被推荐的服务器当前所处的epoch</td></tr><tr><td>electionepoch</td><td>当前服务器所处的epoch</td><td>当前服务器所处的epoch</td></tr><tr><td>state</td><td>当前服务器状态</td><td>选举服务器当前服务器状态</td></tr><tr><td>sid</td><td>接受消息的服务器sid(myid)</td><td>选举服务器的sid</td></tr></tbody></table><h3 id="通信过程源码分析"><a href="#通信过程源码分析" class="headerlink" title="通信过程源码分析"></a>通信过程源码分析</h3><h4 id="每个zk-服务启动后创建socket-监听"><a href="#每个zk-服务启动后创建socket-监听" class="headerlink" title="每个zk 服务启动后创建socket 监听"></a>每个zk 服务启动后创建socket 监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span> </span>&#123;</span><br><span class="line">       Election le = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">       <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">               le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               qcm = createCnxnManager();</span><br><span class="line">               QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">               <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 启动监听,listener 实现了线程,所以在run方法, 可以看到构建serverSocket 的请求</span></span><br><span class="line">                   <span class="comment">// 这里专门用来接受其他zkServer 的投票请求</span></span><br><span class="line">                   listener.start();</span><br><span class="line">                   <span class="comment">// 初始化 FastLeaderElection</span></span><br><span class="line">                   le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   LOG.error(<span class="string">&quot;Null listener when initializing cnx manager&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> le;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sleeps on accept().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numRetries = <span class="number">0</span>;</span><br><span class="line">    InetSocketAddress addr;</span><br><span class="line">    <span class="keyword">while</span>((!shutdown) &amp;&amp; (numRetries &lt; <span class="number">3</span>))&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            ss.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (listenOnAllIPs) &#123;</span><br><span class="line">                <span class="keyword">int</span> port = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</span><br><span class="line">                    .electionAddr.getPort();</span><br><span class="line">                addr = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addr = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</span><br><span class="line">                    .electionAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            LOG.info(<span class="string">&quot;My election bind port: &quot;</span> + addr.toString());</span><br><span class="line">            setName(view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</span><br><span class="line">                    .electionAddr.toString());</span><br><span class="line">            ss.bind(addr);</span><br><span class="line">            <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">                Socket client = ss.accept();</span><br><span class="line">                setSockOpts(client);</span><br><span class="line">                LOG.info(<span class="string">&quot;Received connection request &quot;</span></span><br><span class="line">                        + client.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Receive and handle the connection request</span></span><br><span class="line">                <span class="comment">// asynchronously if the quorum sasl authentication is</span></span><br><span class="line">                <span class="comment">// enabled. This is required because sasl server</span></span><br><span class="line">                <span class="comment">// authentication process may take few seconds to finish,</span></span><br><span class="line">                <span class="comment">// this may delay next peer connection requests.</span></span><br><span class="line">                <span class="keyword">if</span> (quorumSaslAuthEnabled) &#123;</span><br><span class="line">                    receiveConnectionAsync(client);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    receiveConnection(client);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                numRetries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Exception while listening&quot;</span>, e);</span><br><span class="line">            numRetries++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;Error closing server socket&quot;</span>, ie);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;Interrupted while sleeping. &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;Ignoring exception&quot;</span>, ie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">&quot;Leaving listener&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!shutdown) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;As I&#x27;m leaving the listener thread, &quot;</span></span><br><span class="line">                + <span class="string">&quot;I won&#x27;t be able to participate in leader &quot;</span></span><br><span class="line">                + <span class="string">&quot;election any longer: &quot;</span></span><br><span class="line">                + view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid).electionAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FastLeaderElection-lookForLeader-1"><a href="#FastLeaderElection-lookForLeader-1" class="headerlink" title="FastLeaderElection.lookForLeader"></a>FastLeaderElection.lookForLeader</h3><p>这个方法前面分析过, 里面会调用 sendNotifications  来发送投票请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           self.jmxLeaderElectionBean = <span class="keyword">new</span> LeaderElectionBean();</span><br><span class="line">           MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">           self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (self.start_fle == <span class="number">0</span>) &#123;</span><br><span class="line">           self.start_fle = Time.currentElapsedTime();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">           HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> notTimeout = finalizeWait;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// 更新逻辑时钟, 用来判断是否在同一轮选举周期</span></span><br><span class="line">               logicalclock.incrementAndGet();</span><br><span class="line">               <span class="comment">// 初始化选票数据, 这里其实就是把当前节点的myid,zxid,epoch 更新到本地的成员属性</span></span><br><span class="line">               updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           LOG.info(<span class="string">&quot;New election. My id =  &quot;</span> + self.getId() + <span class="string">&quot;, proposed zxid=0x&quot;</span> + Long.toHexString(proposedZxid));</span><br><span class="line">           <span class="comment">// 异步发送选举消息</span></span><br><span class="line">           sendNotifications();</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="FastLeaderElection-sendqueue"><a href="#FastLeaderElection-sendqueue" class="headerlink" title="FastLeaderElection.sendqueue"></a>FastLeaderElection.sendqueue</h3><p>sendqueue 这个队列的数据, 是通过 WorkerSender  来进行获取并发送的, 而这个 WorkerSender  线程, 在构建  fastLeaderElection 的时候会启动.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerSender</span> <span class="keyword">extends</span> <span class="title">ZooKeeperThread</span> </span>&#123;</span><br><span class="line">           <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">           QuorumCnxManager manager;</span><br><span class="line"></span><br><span class="line">           WorkerSender(QuorumCnxManager manager) &#123;</span><br><span class="line">               <span class="keyword">super</span>(<span class="string">&quot;WorkerSender&quot;</span>);</span><br><span class="line">               <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">this</span>.manager = manager;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// 从队列中获取ToSend 对象. </span></span><br><span class="line">                       ToSend m = sendqueue.poll(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                       <span class="keyword">if</span> (m == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                       process(m);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               LOG.info(<span class="string">&quot;WorkerSender is down&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Called by run() once there is a new message to send.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> m message to send</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ToSend m)</span> </span>&#123;</span><br><span class="line">               ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), m.leader, m.zxid, m.electionEpoch, m.peerEpoch);</span><br><span class="line">               <span class="comment">// 这里就是调用 QuorumCnxManager 进行消息发送. </span></span><br><span class="line">                manager.toSend(m.sid, requestBuffer);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="QuorumCnxManager-toSend"><a href="#QuorumCnxManager-toSend" class="headerlink" title="QuorumCnxManager.toSend"></a>QuorumCnxManager.toSend</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toSend</span><span class="params">(Long sid, ByteBuffer b)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If sending message to myself, then simply enqueue it (loopback).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//  如果接收者是自己, 直接放置到接受队列</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.mySid == sid) &#123;</span><br><span class="line">           b.position(<span class="number">0</span>);</span><br><span class="line">           addToRecvQueue(<span class="keyword">new</span> Message(b.duplicate(), sid));</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Otherwise send to the corresponding thread to send.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Start a new connection if doesn&#x27;t have one already.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 否则发送到对应的发送队列上</span></span><br><span class="line">           ArrayBlockingQueue&lt;ByteBuffer&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY);</span><br><span class="line">           <span class="comment">// 判断当前的sid 是否已经存在与发送队列, 如果是, 则直接把已经存在的数据发送出去.</span></span><br><span class="line">           ArrayBlockingQueue&lt;ByteBuffer&gt; bqExisting = queueSendMap.putIfAbsent(sid, bq);</span><br><span class="line">           <span class="keyword">if</span> (bqExisting != <span class="keyword">null</span>) &#123;</span><br><span class="line">               addToSendQueue(bqExisting, b);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               addToSendQueue(bq, b);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 连接申请 调用链 connectOne-&gt;initiateConnection-&gt; startConnection</span></span><br><span class="line">           <span class="comment">// startConnection 就是发送方启动入口</span></span><br><span class="line">           connectOne(sid);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="startConnection"><a href="#startConnection" class="headerlink" title="startConnection"></a>startConnection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startConnection</span><span class="params">(Socket sock, Long sid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      DataOutputStream dout = <span class="keyword">null</span>;</span><br><span class="line">      DataInputStream din = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// Sending id and challenge</span></span><br><span class="line">          dout = <span class="keyword">new</span> DataOutputStream(sock.getOutputStream());</span><br><span class="line">          dout.writeLong(<span class="keyword">this</span>.mySid);</span><br><span class="line">          dout.flush();</span><br><span class="line"></span><br><span class="line">          din = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(sock.getInputStream()));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Ignoring exception reading or writing challenge: &quot;</span>, e);</span><br><span class="line">          closeSocket(sock);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// authenticate learner</span></span><br><span class="line">      authLearner.authenticate(sock, view.get(sid).hostname);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If lost the challenge, then drop the new connection</span></span><br><span class="line">      <span class="keyword">if</span> (sid &gt; <span class="keyword">this</span>.mySid) &#123;</span><br><span class="line">          <span class="comment">// 为了防止重复建立连接, 只需要sid 大的主动连接sid 小的.</span></span><br><span class="line">          LOG.info(<span class="string">&quot;Have smaller server identifier, so dropping the &quot;</span> + <span class="string">&quot;connection: (&quot;</span> + sid + <span class="string">&quot;, &quot;</span> + <span class="keyword">this</span>.mySid + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          closeSocket(sock);</span><br><span class="line">          <span class="comment">// Otherwise proceed with the connection</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 构建一个发送线程和接受线程, 负责针对当前连接的数据传输, </span></span><br><span class="line">          SendWorker sw = <span class="keyword">new</span> SendWorker(sock, sid);</span><br><span class="line">          RecvWorker rw = <span class="keyword">new</span> RecvWorker(sock, din, sid, sw);</span><br><span class="line">          sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">          SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (vsw != <span class="keyword">null</span>) vsw.finish();</span><br><span class="line"></span><br><span class="line">          senderWorkerMap.put(sid, sw);</span><br><span class="line">          queueSendMap.putIfAbsent(sid, <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY));</span><br><span class="line"></span><br><span class="line">          sw.start();</span><br><span class="line">          rw.start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="SendWorker"><a href="#SendWorker" class="headerlink" title="SendWorker"></a>SendWorker</h4><p> SendWorker 会监听对应sid 的阻塞队列, 启动的时候, 如果队列为空时会重新发送一次消息最前最后的消息, 以防止上一次处理是服务器异常退出, 造成上一条消息未处理成功; 然后就是不停监听队列, 发现有消息时调用send 方法.</p><h4 id="RecvWorker"><a href="#RecvWorker" class="headerlink" title="RecvWorker"></a>RecvWorker</h4><p> RecvWorker  不停监听socket 的inputstream ,读取消息放到消息接收队列中, 消息放入队列中, qcm的流程就完毕了. </p><h3 id="QuorumCnxManager-Listener"><a href="#QuorumCnxManager-Listener" class="headerlink" title="QuorumCnxManager.Listener"></a>QuorumCnxManager.Listener</h3><p>listener 监听到客户端请求后, 开始处理消息. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> numRetries = <span class="number">0</span>;</span><br><span class="line">         InetSocketAddress addr;</span><br><span class="line">         <span class="keyword">while</span> ((!shutdown) &amp;&amp; (numRetries &lt; <span class="number">3</span>)) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 ss = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">                 ss.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">                 <span class="keyword">if</span> (listenOnAllIPs) &#123;</span><br><span class="line">                     <span class="keyword">int</span> port = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid).electionAddr.getPort();</span><br><span class="line">                     addr = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     addr = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid).electionAddr;</span><br><span class="line">                 &#125;</span><br><span class="line">                 LOG.info(<span class="string">&quot;My election bind port: &quot;</span> + addr.toString());</span><br><span class="line">                 setName(view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid).electionAddr.toString());</span><br><span class="line">                 ss.bind(addr);</span><br><span class="line">                 <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">                     Socket client = ss.accept();</span><br><span class="line">                     setSockOpts(client);</span><br><span class="line">                     LOG.info(<span class="string">&quot;Received connection request &quot;</span> + client.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// Receive and handle the connection request</span></span><br><span class="line">                     <span class="comment">// asynchronously if the quorum sasl authentication is</span></span><br><span class="line">                     <span class="comment">// enabled. This is required because sasl server</span></span><br><span class="line">                     <span class="comment">// authentication process may take few seconds to finish,</span></span><br><span class="line">                     <span class="comment">// this may delay next peer connection requests.</span></span><br><span class="line">                     <span class="keyword">if</span> (quorumSaslAuthEnabled) &#123;</span><br><span class="line">                         receiveConnectionAsync(client);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="comment">// 接受客户端请求</span></span><br><span class="line">                         receiveConnection(client);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     numRetries = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                 LOG.error(<span class="string">&quot;Exception while listening&quot;</span>, e);</span><br><span class="line">                 numRetries++;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     ss.close();</span><br><span class="line">                     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">                     LOG.error(<span class="string">&quot;Error closing server socket&quot;</span>, ie);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                     LOG.error(<span class="string">&quot;Interrupted while sleeping. &quot;</span> + <span class="string">&quot;Ignoring exception&quot;</span>, ie);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         LOG.info(<span class="string">&quot;Leaving listener&quot;</span>);</span><br><span class="line">         <span class="keyword">if</span> (!shutdown) &#123;</span><br><span class="line">             LOG.error(<span class="string">&quot;As I&#x27;m leaving the listener thread, &quot;</span> + <span class="string">&quot;I won&#x27;t be able to participate in leader &quot;</span> + <span class="string">&quot;election any longer: &quot;</span> + view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid).electionAddr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="QuorumCnxManager-receiveConnection"><a href="#QuorumCnxManager-receiveConnection" class="headerlink" title="QuorumCnxManager.receiveConnection"></a>QuorumCnxManager.receiveConnection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConnection</span><span class="params">(<span class="keyword">final</span> Socket sock)</span> </span>&#123;</span><br><span class="line">       DataInputStream din = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取客户端的数据包</span></span><br><span class="line">           din = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(sock.getInputStream()));</span><br><span class="line"></span><br><span class="line">           handleConnection(sock, din);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           LOG.error(<span class="string">&quot;Exception handling connection, addr: &#123;&#125;, closing server connection&quot;</span>, sock.getRemoteSocketAddress());</span><br><span class="line">           closeSocket(sock);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="QuorumCnxManager-handleConnection"><a href="#QuorumCnxManager-handleConnection" class="headerlink" title="QuorumCnxManager.handleConnection"></a>QuorumCnxManager.handleConnection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleConnection</span><span class="params">(Socket sock, DataInputStream din)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Long sid = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Read server id</span></span><br><span class="line">         sid = din.readLong();</span><br><span class="line">         <span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123; <span class="comment">// this is not a server id but a protocol version (see ZOOKEEPER-1633)</span></span><br><span class="line">             <span class="comment">// 获取客户端的sid,也就是myid</span></span><br><span class="line">             sid = din.readLong();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// next comes the #bytes in the remainder of the message</span></span><br><span class="line">             <span class="comment">// note that 0 bytes is fine (old servers)</span></span><br><span class="line">             <span class="keyword">int</span> num_remaining_bytes = din.readInt();</span><br><span class="line">             <span class="keyword">if</span> (num_remaining_bytes &lt; <span class="number">0</span> || num_remaining_bytes &gt; maxBuffer) &#123;</span><br><span class="line">                 LOG.error(<span class="string">&quot;Unreasonable buffer length: &#123;&#125;&quot;</span>, num_remaining_bytes);</span><br><span class="line">                 closeSocket(sock);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[num_remaining_bytes];</span><br><span class="line"></span><br><span class="line">             <span class="comment">// remove the remainder of the message from din</span></span><br><span class="line">             <span class="keyword">int</span> num_read = din.read(b);</span><br><span class="line">             <span class="keyword">if</span> (num_read != num_remaining_bytes) &#123;</span><br><span class="line">                 LOG.error(<span class="string">&quot;Read only &quot;</span> + num_read + <span class="string">&quot; bytes out of &quot;</span> + num_remaining_bytes + <span class="string">&quot; sent by server &quot;</span> + sid);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (sid == QuorumPeer.OBSERVER_ID) &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * Choose identifier at random. We need a value to identify</span></span><br><span class="line"><span class="comment">              * the connection.</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             sid = observerCounter.getAndDecrement();</span><br><span class="line">             LOG.info(<span class="string">&quot;Setting arbitrary identifier to observer: &quot;</span> + sid);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         closeSocket(sock);</span><br><span class="line">         LOG.warn(<span class="string">&quot;Exception reading or writing challenge: &quot;</span> + e.toString());</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// do authenticating learner</span></span><br><span class="line">     LOG.debug(<span class="string">&quot;Authenticating learner server.id: &#123;&#125;&quot;</span>, sid);</span><br><span class="line">     authServer.authenticate(sock, din);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//If wins the challenge, then close the new connection.</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 为了防止重复建立连接, 只允许sid 大的主动连接sid 小的</span></span><br><span class="line">     <span class="keyword">if</span> (sid &lt; <span class="keyword">this</span>.mySid) &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * This replica might still believe that the connection to sid is</span></span><br><span class="line"><span class="comment">          * up, so we have to shut down the workers before trying to open a</span></span><br><span class="line"><span class="comment">          * new connection.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         SendWorker sw = senderWorkerMap.get(sid);</span><br><span class="line">         <span class="keyword">if</span> (sw != <span class="keyword">null</span>) &#123;</span><br><span class="line">             sw.finish();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Now we start a new connection</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         LOG.debug(<span class="string">&quot;Create new connection to server: &quot;</span> + sid);</span><br><span class="line">         <span class="comment">// 关闭连接</span></span><br><span class="line">         closeSocket(sock);</span><br><span class="line">         <span class="comment">// 向sid 发起连接</span></span><br><span class="line">         connectOne(sid);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Otherwise start worker threads to receive data.</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 同样, 构建一个SendWorker 和RecvWorker 进行发送数据和接受数据</span></span><br><span class="line">         SendWorker sw = <span class="keyword">new</span> SendWorker(sock, sid);</span><br><span class="line">         RecvWorker rw = <span class="keyword">new</span> RecvWorker(sock, din, sid, sw);</span><br><span class="line">         sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">         SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (vsw != <span class="keyword">null</span>) vsw.finish();</span><br><span class="line"></span><br><span class="line">         senderWorkerMap.put(sid, sw);</span><br><span class="line">         queueSendMap.putIfAbsent(sid, <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY));</span><br><span class="line"></span><br><span class="line">         sw.start();</span><br><span class="line">         rw.start();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Leader-选举完成之后的处理逻辑"><a href="#Leader-选举完成之后的处理逻辑" class="headerlink" title="Leader 选举完成之后的处理逻辑"></a>Leader 选举完成之后的处理逻辑</h2><p>通过 lookForLeader  方法选举完成后, 会设置当前节点的 PeerState， , 要么为Leading, 要么就是 FOLLOWER，或者Observer, 到这里, 只是表示当前的leader 选举出来了, 但是 QuorumPeer.run  方法还没有执行完, 我们再回过头来看看后续的处理过程. </p><h3 id="QuorumPeer-run-1"><a href="#QuorumPeer-run-1" class="headerlink" title="QuorumPeer.run"></a>QuorumPeer.run</h3><p>分别来看看 case 为Follower 和Leading  会做什么事情呢? </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       setName(<span class="string">&quot;QuorumPeer&quot;</span> + <span class="string">&quot;[myid=&quot;</span> + getId() + <span class="string">&quot;]&quot;</span> +</span><br><span class="line">               cnxnFactory.getLocalAddress());</span><br><span class="line"></span><br><span class="line">       LOG.debug(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           jmxQuorumBean = <span class="keyword">new</span> QuorumBean(<span class="keyword">this</span>);</span><br><span class="line">           MBeanRegistry.getInstance().register(jmxQuorumBean, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">for</span> (QuorumServer s : getView().values()) &#123;</span><br><span class="line">               ZKMBeanInfo p;</span><br><span class="line">               <span class="keyword">if</span> (getId() == s.id) &#123;</span><br><span class="line">                   p = jmxLocalPeerBean = <span class="keyword">new</span> LocalPeerBean(<span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">                       jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   p = <span class="keyword">new</span> RemotePeerBean(s);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Failed to register with JMX&quot;</span>, e);</span><br><span class="line">           jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Main loop</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 根据选举状态, 选择不同的处理方式</span></span><br><span class="line">           <span class="keyword">while</span> (running) &#123;</span><br><span class="line">               <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">                   <span class="keyword">case</span> LOOKING:</span><br><span class="line">                       LOG.info(<span class="string">&quot;LOOKING&quot;</span>);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 判断是否为只读模式, 通过readonlymode.enabled 开启</span></span><br><span class="line">                       <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;readonlymode.enabled&quot;</span>)) &#123;</span><br><span class="line">                           LOG.info(<span class="string">&quot;Attempting to start ReadOnlyZooKeeperServer&quot;</span>);</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 只读模式的启动流程</span></span><br><span class="line">                           <span class="comment">// Create read-only server but don&#x27;t start it immediately</span></span><br><span class="line">                           <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk = <span class="keyword">new</span> ReadOnlyZooKeeperServer(</span><br><span class="line">                                   logFactory, <span class="keyword">this</span>,</span><br><span class="line">                                   <span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(),</span><br><span class="line">                                   <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                           <span class="comment">// period before we decide we&#x27;re partitioned.</span></span><br><span class="line">                           <span class="comment">//</span></span><br><span class="line">                           <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                           <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                           <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                           Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                   <span class="keyword">try</span> &#123;</span><br><span class="line">                                       <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                       sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                       <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                           roZk.startup();</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                       LOG.info(<span class="string">&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;</span>);</span><br><span class="line">                                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                       LOG.error(<span class="string">&quot;FAILED to start ReadOnlyZooKeeperServer&quot;</span>, e);</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               roZkMgr.start();</span><br><span class="line">                               setBCVote(<span class="keyword">null</span>);</span><br><span class="line">                               <span class="comment">// 设置当前的投票, 通过策略模式来决定当前用哪个选举算法来进行领导选举</span></span><br><span class="line">                               setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                               LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                               setPeerState(ServerState.LOOKING);</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                               <span class="comment">// to come out of waiting.</span></span><br><span class="line">                               roZkMgr.interrupt();</span><br><span class="line">                               roZk.shutdown();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               setBCVote(<span class="keyword">null</span>);</span><br><span class="line">                               setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                               LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                               setPeerState(ServerState.LOOKING);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                       ...</span><br><span class="line">                           </span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><h3 id="makeFollower"><a href="#makeFollower" class="headerlink" title="makeFollower"></a>makeFollower</h3><p>初始化一个 Follower  对象, 构建一个 FollowerZookeeperServer ,表示follower 节点的请求处理服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Follower <span class="title">makeFollower</span><span class="params">(FileTxnSnapLog logFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Follower(<span class="keyword">this</span>, <span class="keyword">new</span> FollowerZooKeeperServer(logFactory,</span><br><span class="line">            <span class="keyword">this</span>, <span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(), <span class="keyword">this</span>.zkDb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="follower-followLeader"><a href="#follower-followLeader" class="headerlink" title="follower.followLeader();"></a>follower.followLeader();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       self.end_fle = Time.currentElapsedTime();</span><br><span class="line">       <span class="keyword">long</span> electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">       self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">       LOG.info(<span class="string">&quot;FOLLOWING - LEADER ELECTION TOOK - &#123;&#125;&quot;</span>, electionTimeTaken);</span><br><span class="line">       self.start_fle = <span class="number">0</span>;</span><br><span class="line">       self.end_fle = <span class="number">0</span>;</span><br><span class="line">       fzk.registerJMX(<span class="keyword">new</span> FollowerBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 根据sid 找到对应的leader, 拿到lead 连接信息</span></span><br><span class="line">           QuorumServer leaderServer = findLeader();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 连接到leader</span></span><br><span class="line">               connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">               <span class="comment">// 将Follower 的zxid和myid 等信息封装好发送到leader, 同步epoch</span></span><br><span class="line">               <span class="comment">// 也就是意味着接下来 follower节点 只同步新的epoch 的数据信息</span></span><br><span class="line">               <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//check to see if the leader zxid is lower than ours</span></span><br><span class="line">               <span class="comment">//this should never happen but is just a safety check</span></span><br><span class="line">               <span class="comment">// 如果 leader 的epoch 比当前follower 节点的epoch 还小, 抛异常</span></span><br><span class="line">               <span class="keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);</span><br><span class="line">               <span class="keyword">if</span> (newEpoch &lt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">                   LOG.error(<span class="string">&quot;Proposed leader epoch &quot;</span> + ZxidUtils.zxidToString(newEpochZxid) + <span class="string">&quot; is less than our accepted epoch &quot;</span> + ZxidUtils.zxidToString(self.getAcceptedEpoch()));</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Error: Epoch of leader is lower&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 和leader 进行数据同步</span></span><br><span class="line">               syncWithLeader(newEpochZxid);</span><br><span class="line">               QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">               <span class="comment">// 接受 leader 消息, 执行并反馈给leader, 线程在此自旋</span></span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">this</span>.isRunning()) &#123;</span><br><span class="line">                   <span class="comment">// 从 leader 读取数据包</span></span><br><span class="line">                   readPacket(qp);</span><br><span class="line">                   <span class="comment">// 处理packet</span></span><br><span class="line">                   processPacket(qp);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               LOG.warn(<span class="string">&quot;Exception when following the leader&quot;</span>, e);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   sock.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// clear pending revalidations</span></span><br><span class="line">               pendingRevalidations.clear();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           zk.unregisterJMX((Learner) <span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="makeLeader"><a href="#makeLeader" class="headerlink" title="makeLeader"></a>makeLeader</h3><p>初始化一个Leader 对象, 构建一个 LeaderZookeeperServer , 用于标识leader 节点的请求处理服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Leader <span class="title">makeLeader</span><span class="params">(FileTxnSnapLog logFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Leader(<span class="keyword">this</span>, <span class="keyword">new</span> LeaderZooKeeperServer(logFactory,</span><br><span class="line">               <span class="keyword">this</span>, <span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(), <span class="keyword">this</span>.zkDb));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="leader-lead"><a href="#leader-lead" class="headerlink" title="leader.lead();"></a>leader.lead();</h3><p>在Leader 端, 则通过lead() 来处理与follower 的交互.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Zookeeper原理之Leader选举源码分析&quot;&gt;&lt;a href=&quot;#Zookeeper原理之Leader选举源码分析&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper原理之Leader选举源码分析&quot;&gt;&lt;/a&gt;Zookeeper原理之Leader选举源码分析&lt;/h1&gt;&lt;h2 id=&quot;Zookeeper-的一致性&quot;&gt;&lt;a href=&quot;#Zookeeper-的一致性&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper 的一致性&quot;&gt;&lt;/a&gt;Zookeeper 的一致性&lt;/h2&gt;&lt;h3 id=&quot;Zookeeper-的来源&quot;&gt;&lt;a href=&quot;#Zookeeper-的来源&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper 的来源&quot;&gt;&lt;/a&gt;Zookeeper 的来源&lt;/h3&gt;&lt;p&gt;对于zookeeper的一致性问题, 我们再从来源问题梳理一遍一致性的问题. &lt;/p&gt;
&lt;p&gt;我们知道zookeeper的来源, 是来自于Google chubby, 为了分布式环境下, 如何从多个server 中选举出master server. 那么这么多个server 就需要涉及到一致性问题, 这个一致性体现的是多个server 就master 这个投票在分布式环境下达成一致性. 简单来说, 就是最终听谁的. 但是在网络环境中由于网络环境的不可靠性, 会存在消息丢失或者被篡改等问题. 所以如何在这样一个环境中快速并且正确的在多个server 中对某一个数据达成一致性并且保证无论发生任何异常, 都不会破坏整个系统一致性呢? &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/Zookeeper%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://luyanan.com/Zookeeper%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2021-03-01T09:46:52.935Z</published>
    <updated>2020-12-24T09:34:50.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper单机和集群的安装"><a href="#Zookeeper单机和集群的安装" class="headerlink" title="Zookeeper单机和集群的安装"></a>Zookeeper单机和集群的安装</h1><h2 id="1-安装-zookeeper"><a href="#1-安装-zookeeper" class="headerlink" title="1. 安装 zookeeper"></a>1. 安装 zookeeper</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><p>通过下面地址可以下载zookeeper</p><p><a href="http://apache.fayea.com/zookeeper/">http://apache.fayea.com/zookeeper/</a></p><p>我们先建一个zk 目录, 使用</p><blockquote><p> wget <a href="http://apache.fayea.com/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5-bin.tar.gz">http://apache.fayea.com/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5-bin.tar.gz</a></p><p>下载zookeepe</p></blockquote><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><blockquote><p>tar -zxvf apache-zookeeper-3.5.6.tar.gz</p></blockquote><p>解压进目录后就看到</p><p><img src="http://files.luyanan.com//img/20191106142259.png"></p><h3 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3. 常见命令"></a>3. 常见命令</h3><h4 id="1-启动ZK服务"><a href="#1-启动ZK服务" class="headerlink" title="1. 启动ZK服务"></a>1. 启动ZK服务</h4><blockquote><p> bin/zkServer.sh start </p></blockquote><h4 id="2-查看ZK-服务状态"><a href="#2-查看ZK-服务状态" class="headerlink" title="2. 查看ZK 服务状态"></a>2. 查看ZK 服务状态</h4><blockquote><p> bin/zkServer.sh status </p></blockquote><h4 id="3-停止ZK-服务"><a href="#3-停止ZK-服务" class="headerlink" title="3. 停止ZK 服务"></a>3. 停止ZK 服务</h4><blockquote><p> bin/zkServer.sh stop  </p></blockquote><h4 id="4-重启ZK-服务"><a href="#4-重启ZK-服务" class="headerlink" title="4. 重启ZK 服务"></a>4. 重启ZK 服务</h4><blockquote><p> bin/zkServer.sh restart </p></blockquote><h4 id="5-连接服务器"><a href="#5-连接服务器" class="headerlink" title="5. 连接服务器"></a>5. 连接服务器</h4><blockquote><p> zkCli.sh -timeout 0 -r -server ip:port </p></blockquote><h2 id="单机版安装"><a href="#单机版安装" class="headerlink" title="单机版安装"></a>单机版安装</h2><p>一般情况下,在开发测试环境中, 没有那么多资源的情况下, 而且也不需要特别好的稳定性的前提下, 我们可以使用单机部署.</p><p>初次使用zookeeper,需要将conf 目录下的 <code>zoo_sample.cfg</code> 文件copy 一份重命名为zoo.cfg,修改 datasDir 目录, dataDir 表示日志文件存放的路径</p><blockquote><p>进入conf 目录</p><p>cp zoo_sample.cfg  zoo.cfg</p></blockquote><p>进入bin 目录下, 执行上面的命令   </p><blockquote><p>sh zkServer.sh  start   启动</p></blockquote><h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><h3 id="单ip-部署集群"><a href="#单ip-部署集群" class="headerlink" title="单ip 部署集群"></a>单ip 部署集群</h3><h4 id="修改配置文件-拷贝多份zookeeper程序-例如设置三个server-分别为-apache-zookeeper-3-5-5-bin-apache-zookeeper-3-5-5-bin-2-apache-zookeeper-3-5-5-bin-3-每个目录下存放一份zookeeper-并-修改各自配置文件如下"><a href="#修改配置文件-拷贝多份zookeeper程序-例如设置三个server-分别为-apache-zookeeper-3-5-5-bin-apache-zookeeper-3-5-5-bin-2-apache-zookeeper-3-5-5-bin-3-每个目录下存放一份zookeeper-并-修改各自配置文件如下" class="headerlink" title="修改配置文件, 拷贝多份zookeeper程序, 例如设置三个server, 分别为 apache-zookeeper-3.5.5-bin,apache-zookeeper-3.5.5-bin_2,apache-zookeeper-3.5.5-bin_3   ,每个目录下存放一份zookeeper, 并 修改各自配置文件如下:"></a>修改配置文件, 拷贝多份zookeeper程序, 例如设置三个server, 分别为 apache-zookeeper-3.5.5-bin,apache-zookeeper-3.5.5-bin_2,apache-zookeeper-3.5.5-bin_3   ,每个目录下存放一份zookeeper, 并 修改各自配置文件如下:</h4><p>apache-zookeeper-3.5.5-bin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> The number of milliseconds of each tick</span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/web/zk/apache-zookeeper-<span class="number">3.5</span><span class="number">.5</span>-bin</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line">server<span class="number">.1</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.2</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2889</span>:<span class="number">3889</span></span><br><span class="line">server<span class="number">.3</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2890</span>:<span class="number">3890</span></span><br></pre></td></tr></table></figure><p>apache-zookeeper-3.5.5-bin_2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> The number of milliseconds of each tick</span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/web/zk/apache-zookeeper-<span class="number">3.5</span><span class="number">.5</span>-bin_2</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2182</span></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line">server<span class="number">.1</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.2</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2889</span>:<span class="number">3889</span></span><br><span class="line">server<span class="number">.3</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2890</span>:<span class="number">3890</span></span><br></pre></td></tr></table></figure><p>apache-zookeeper-3.5.5-bin_3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> The number of milliseconds of each tick</span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/web/zk/apache-zookeeper-<span class="number">3.5</span><span class="number">.5</span>-bin_3</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2183</span></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line">server<span class="number">.1</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.2</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2889</span>:<span class="number">3889</span></span><br><span class="line">server<span class="number">.3</span>=<span class="number">192.168</span><span class="number">.91</span><span class="number">.128</span>:<span class="number">2890</span>:<span class="number">3890</span></span><br></pre></td></tr></table></figure><p>注意:</p><blockquote><p>同一ip上搭建多个节点的集群的时候, 必须注意端口号的问题，端口必须不一致才行. </p><p>创建多个节点集群时, 在dataDir 目录下必须创建myid文件, myid 文件用于zookeeper 验证server序列等. myid 只有一行, 并且为当前server 的序号. 例如 server.1 的myid 就是1, server.2 的myid 就是2. </p></blockquote><h3 id="多ip-集群"><a href="#多ip-集群" class="headerlink" title="多ip 集群"></a>多ip 集群</h3><p>我们这里准备三台服务器准备集群的安装</p><blockquote><p>192.168.91.128</p><p>192.168.91.129</p><p>192.168.91.130</p></blockquote><p>在zookeeper 集群中, 各个节点总共有三个角色,分别是leader，follower,observer.集群模式我们采用模拟3台机器来搭建zookeeper 集群. 分别复制安装包到三台机器上并解压, 同时copy 一份 zoo.cfg.</p><ol><li><p>修改配置文件</p><p>  修改端口</p><p>server.1=IP1:2888:3888</p><p>server.2=IP1:2888:3888</p><p>server.3=IP1:2888:3888</p><blockquote><p>2888:访问zookeeper的端口; 3888 : 重新选举leader 的端口</p><p>server.A= B :C :D 其中:</p><p>​          A 是一个数字, 表示这个是第几号服务器</p><p>​          B 是这个服务器的ip 地址</p><p>​         C 表示是这个服务器与集群中的Leader 服务器交换信息的端口</p><p>​           D  表示的是万一集群中的Leader 服务器挂了, 需要一个端口来重新进行选举, 选出一个新的Leader. </p><p>​         而这个端口就是用来执行选举时服务器相互通信的端口, 如果是伪集群的配置方式, 由于B 都是一样的. </p><p>所以不同的Zookeeper 实例通信端口号不能一样, 所以要给他们分配不同的端口号. </p><p>在集群模式下, 集群中每台机器都需要感知到整个集群中是由哪几台机器组成, 在配置文件中, 按照格式server.id = host:port:port, 每一行代表一个机器配置, id: 指的是server ID，用来标识该机器在集群中的机器序号. </p></blockquote></li><li><p>新建datadir 目录, 设置 myid</p><blockquote><p>在每台zookeeper 机器上, 我们都需要在数据目录(dataDir)下创建一个myid, 该文件只有一行内容, 对应每台机器的server ID  数字. 比如server.1的myid 文件内容就是1. [必须确保每个服务器的myid 文件中的数字是不同的, 并且和自己所在机器的zoo.cfg 中 server.id 的id 值是一致的, id 的范围是 1到255]</p></blockquote></li><li><p>启动zookeeper</p></li></ol><p>启动自个服务器目录下的zookeeper就行了. </p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>可以使用以下命令连接一个zk集群</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;zkCli.sh -server 192.168.229.160:2181,192.168.229.161:2181,192.168.229.162:2181</span><br></pre></td></tr></table></figure></blockquote><p><img src="http://files.luyanan.com//img/20191106151031.png"></p><p>如图则显示连接成功</p><p>从日志输入上来看, 客户端连接的进程是随机分配的. </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Zookeeper单机和集群的安装&quot;&gt;&lt;a href=&quot;#Zookeeper单机和集群的安装&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper单机和集群的安装&quot;&gt;&lt;/a&gt;Zookeeper单机和集群的安装&lt;/h1&gt;&lt;h2 id=&quot;1-安装-zookeeper&quot;&gt;&lt;a href=&quot;#1-安装-zookeeper&quot; class=&quot;headerlink&quot; title=&quot;1. 安装 zookeeper&quot;&gt;&lt;/a&gt;1. 安装 zookeeper&lt;/h2&gt;&lt;h3 id=&quot;1-下载&quot;&gt;&lt;a href=&quot;#1-下载&quot; class=&quot;headerlink&quot; title=&quot;1. 下载&quot;&gt;&lt;/a&gt;1. 下载&lt;/h3&gt;&lt;p&gt;通过下面地址可以下载zookeeper&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://apache.fayea.com/zookeeper/&quot;&gt;http://apache.fayea.com/zookeeper/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="zookeeper" scheme="http://luyanan.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/zookeeper%E4%B9%8Bwatcher%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://luyanan.com/zookeeper%E4%B9%8Bwatcher%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-03-01T09:46:52.926Z</published>
    <updated>2020-12-24T09:34:50.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper原理之watcher源码分析"><a href="#zookeeper原理之watcher源码分析" class="headerlink" title="zookeeper原理之watcher源码分析"></a>zookeeper原理之watcher源码分析</h1><h2 id="watcher-的基本流程"><a href="#watcher-的基本流程" class="headerlink" title="watcher 的基本流程"></a>watcher 的基本流程</h2><p>zookeeper 的watcher 机制, 总的来说分为三个过程: 客户端注册watcher、服务端处理watcher和客户端回调watcher . </p><h2 id="基于zk客户端发起一个数据操作"><a href="#基于zk客户端发起一个数据操作" class="headerlink" title="基于zk客户端发起一个数据操作"></a>基于zk客户端发起一个数据操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</span><br><span class="line">       ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.9.22:2181&quot;</span>,</span><br><span class="line">               <span class="number">4000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">               System.out.println(<span class="string">&quot;event.type:&quot;</span> + watchedEvent.getType());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       String path = <span class="string">&quot;/watcher&quot;</span>;</span><br><span class="line">       <span class="comment">//  创建节点</span></span><br><span class="line">       zooKeeper.create(path, <span class="string">&quot;0&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">       <span class="comment">//  注册监听</span></span><br><span class="line">       zooKeeper.exists(path, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 修改节点的值触发监听</span></span><br><span class="line">       zooKeeper.setData(path, <span class="string">&quot;1&quot;</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">       System.in.read();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在创建一个zookeeper 客户端对象实例的时候. 我们通过<code>new Watcher</code> 向构造方法中传入一个默认的watcher, 这个watcher 将作为整个整个zookeeper 会话期间默认的watcher,会一直被保存在客户端 ZKWatchManager  的 defaultWatcher 中, 代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly, HostProvider aHostProvider, ZKClientConfig clientConfig)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       LOG.info(<span class="string">&quot;Initiating client connection, connectString=&quot;</span> + connectString + <span class="string">&quot; sessionTimeout=&quot;</span> + sessionTimeout + <span class="string">&quot; watcher=&quot;</span> + watcher);</span><br><span class="line">       <span class="keyword">if</span> (clientConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">           clientConfig = <span class="keyword">new</span> ZKClientConfig();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.clientConfig = clientConfig;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">this</span>.watchManager = <span class="keyword">this</span>.defaultWatchManager();</span><br><span class="line">    <span class="comment">// 这里将watcher 设置到ZKWatchManager  </span></span><br><span class="line">    <span class="keyword">this</span>.watchManager.defaultWatcher = watcher;</span><br><span class="line">       ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(connectString);</span><br><span class="line">       <span class="keyword">this</span>.hostProvider = aHostProvider;</span><br><span class="line">       <span class="keyword">this</span>.cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(), <span class="keyword">this</span>.hostProvider, sessionTimeout, <span class="keyword">this</span>, <span class="keyword">this</span>.watchManager, <span class="keyword">this</span>.getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line">       <span class="keyword">this</span>.cnxn.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> ClientCnxn : 是zookeeper 客户端和zookeeper 服务端进行通信和事件通知处理的主要类, 它主要包含两个类: </p><ul><li> SendThread : 负责客户端和服务端的数据通信, 也包括事件信息的传输</li><li> EventThread : 主要在客户端回调注册的watcher 进行通知处理. </li></ul><h2 id="ClientCnxn-初始化"><a href="#ClientCnxn-初始化" class="headerlink" title="ClientCnxn  初始化"></a>ClientCnxn  初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClientCnxn</span><span class="params">(String chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.authInfo = <span class="keyword">new</span> CopyOnWriteArraySet();</span><br><span class="line">    <span class="keyword">this</span>.pendingQueue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">this</span>.outgoingQueue = <span class="keyword">new</span> LinkedBlockingDeque();</span><br><span class="line">    <span class="keyword">this</span>.sessionPasswd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">this</span>.closing = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.seenRwServerBefore = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.eventOfDeath = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">this</span>.xid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = States.NOT_CONNECTED;</span><br><span class="line">    <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">    <span class="keyword">this</span>.watcher = watcher;</span><br><span class="line">    <span class="keyword">this</span>.sessionId = sessionId;</span><br><span class="line">    <span class="keyword">this</span>.sessionPasswd = sessionPasswd;</span><br><span class="line">    <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">    <span class="keyword">this</span>.hostProvider = hostProvider;</span><br><span class="line">    <span class="keyword">this</span>.chrootPath = chrootPath;</span><br><span class="line">    <span class="keyword">this</span>.connectTimeout = sessionTimeout / hostProvider.size();</span><br><span class="line">    <span class="keyword">this</span>.readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">this</span>.readOnly = canBeReadOnly;</span><br><span class="line">    <span class="comment">//初始化sendThread</span></span><br><span class="line">    <span class="keyword">this</span>.sendThread = <span class="keyword">new</span> ClientCnxn.SendThread(clientCnxnSocket);</span><br><span class="line">    <span class="comment">// 初始化eventThread</span></span><br><span class="line">    <span class="keyword">this</span>.eventThread = <span class="keyword">new</span> ClientCnxn.EventThread();</span><br><span class="line">    <span class="keyword">this</span>.clientConfig = zooKeeper.getClientConfig();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动两个线程</span></span><br><span class="line">    <span class="keyword">this</span>.sendThread.start();</span><br><span class="line">    <span class="keyword">this</span>.eventThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端接收请求处理流程"><a href="#服务端接收请求处理流程" class="headerlink" title="服务端接收请求处理流程"></a>服务端接收请求处理流程</h2><p>服务端有一个 NIOServerCnxn  类, 有来处理客户端发送过来的请求 </p><h3 id="NIOServerCnxn"><a href="#NIOServerCnxn" class="headerlink" title="NIOServerCnxn"></a>NIOServerCnxn</h3><h4 id="ZookeeperServer-processPacket-this-bb"><a href="#ZookeeperServer-processPacket-this-bb" class="headerlink" title="ZookeeperServer.processPacket(this, bb);"></a>ZookeeperServer.processPacket(this, bb);</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processPacket</span><span class="params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// We have the request, now process and setup for next</span></span><br><span class="line">       InputStream bais = <span class="keyword">new</span> ByteBufferInputStream(incomingBuffer);</span><br><span class="line">       BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);</span><br><span class="line">       RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">       h.deserialize(bia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">       <span class="comment">// Through the magic of byte buffers, txn will not be</span></span><br><span class="line">       <span class="comment">// pointing</span></span><br><span class="line">       <span class="comment">// to the start of the txn</span></span><br><span class="line">       incomingBuffer = incomingBuffer.slice();</span><br><span class="line">       <span class="comment">// 判断当前操作类型, 如果是auth操作, 就直接以下代码</span></span><br><span class="line">       <span class="keyword">if</span> (h.getType() == OpCode.auth) &#123;</span><br><span class="line">           LOG.info(<span class="string">&quot;got auth packet &quot;</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">           AuthPacket authPacket = <span class="keyword">new</span> AuthPacket();</span><br><span class="line">           ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);</span><br><span class="line">           String scheme = authPacket.getScheme();</span><br><span class="line">           AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);</span><br><span class="line">           Code authReturn = KeeperException.Code.AUTHFAILED;</span><br><span class="line">           <span class="keyword">if</span>(ap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   authReturn = ap.handleAuthentication(cnxn, authPacket.getAuth());</span><br><span class="line">               &#125; <span class="keyword">catch</span>(RuntimeException e) &#123;</span><br><span class="line">                   LOG.warn(<span class="string">&quot;Caught runtime exception from AuthenticationProvider: &quot;</span> + scheme + <span class="string">&quot; due to &quot;</span> + e);</span><br><span class="line">                   authReturn = KeeperException.Code.AUTHFAILED;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (authReturn!= KeeperException.Code.OK) &#123;</span><br><span class="line">               <span class="keyword">if</span> (ap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   LOG.warn(<span class="string">&quot;No authentication provider for scheme: &quot;</span></span><br><span class="line">                           + scheme + <span class="string">&quot; has &quot;</span></span><br><span class="line">                           + ProviderRegistry.listProviders());</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   LOG.warn(<span class="string">&quot;Authentication failed for scheme: &quot;</span> + scheme);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// send a response...</span></span><br><span class="line">               ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>,</span><br><span class="line">                       KeeperException.Code.AUTHFAILED.intValue());</span><br><span class="line">               cnxn.sendResponse(rh, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="comment">// ... and close connection</span></span><br><span class="line">               cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span><br><span class="line">               cnxn.disableRecv();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Authentication succeeded for scheme: &quot;</span></span><br><span class="line">                             + scheme);</span><br><span class="line">               &#125;</span><br><span class="line">               LOG.info(<span class="string">&quot;auth success &quot;</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">               ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>,</span><br><span class="line">                       KeeperException.Code.OK.intValue());</span><br><span class="line">               cnxn.sendResponse(rh, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (h.getType() == OpCode.sasl) &#123;</span><br><span class="line">               Record rsp = processSasl(incomingBuffer,cnxn);</span><br><span class="line">               ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>, KeeperException.Code.OK.intValue());</span><br><span class="line">               cnxn.sendResponse(rh,rsp, <span class="string">&quot;response&quot;</span>); <span class="comment">// not sure about 3rd arg..what is it?</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//  最终进入这个代码块进行处理</span></span><br><span class="line">               <span class="comment">// 封装请求对象</span></span><br><span class="line">               Request si = <span class="keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">                 h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">               si.setOwner(ServerCnxn.me);</span><br><span class="line">               submitRequest(si);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       cnxn.incrOutstandingRequests(h);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="submitRequest"><a href="#submitRequest" class="headerlink" title="submitRequest"></a>submitRequest</h4><p>负责在服务端提交当前请求. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// Since all requests are passed to the request</span></span><br><span class="line">                  <span class="comment">// processor it should wait for setting up the request</span></span><br><span class="line">                  <span class="comment">// processor chain. The state will be updated to RUNNING</span></span><br><span class="line">                  <span class="comment">// after the setup.</span></span><br><span class="line">                  <span class="keyword">while</span> (state == State.INITIAL) &#123;</span><br><span class="line">                      wait(<span class="number">1000</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  LOG.warn(<span class="string">&quot;Unexpected interruption&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span> || state != State.RUNNING) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not started&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          touch(si.cnxn);</span><br><span class="line">          <span class="comment">// 判断是否合法</span></span><br><span class="line">          <span class="keyword">boolean</span> validpacket = Request.isValid(si.type);</span><br><span class="line">          <span class="keyword">if</span> (validpacket) &#123;</span><br><span class="line">              <span class="comment">// 调用firstProcessor 发起请求, firstProcessor 是一个接口, 有多个实现类, </span></span><br><span class="line">              firstProcessor.processRequest(si);</span><br><span class="line">              <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  incInProcess();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              LOG.warn(<span class="string">&quot;Received packet at server of unknown type &quot;</span> + si.type);</span><br><span class="line">              <span class="keyword">new</span> UnimplementedRequestProcessor().processRequest(si);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (MissingSessionException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">              LOG.debug(<span class="string">&quot;Dropping request: &quot;</span> + e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">          LOG.error(<span class="string">&quot;Unable to process request:&quot;</span> + e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="firstProcessor-请求链组成"><a href="#firstProcessor-请求链组成" class="headerlink" title="firstProcessor  请求链组成"></a>firstProcessor  请求链组成</h4><p> firstProcessor  的初始化是在 ZookeeperServer  的 setupRequestProcessor  中完成的, 代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            finalProcessor);</span><br><span class="line">    ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</span><br><span class="line">    ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以看到     firstProcessor  的实例是一个PrepRequestProcessor, 而这个构造方法中又传递到了一个Processor 构成一个调用链. </p><p> RequestProcessor syncProcessor = new SyncRequestProcessor(this,  finalProcessor); </p><p>而syncProcessor  的构造方法传递的又是一个Processor , 对应的是 FinalRequestProcessor . </p><p>所以整个调用链是 PrepRequestProcessor -&gt; SyncRequestProcessor - &gt;FinalRequestProcessor </p><h4 id="PredRequestProcessor-processRequest-si"><a href="#PredRequestProcessor-processRequest-si" class="headerlink" title="PredRequestProcessor.processRequest(si);"></a>PredRequestProcessor.processRequest(si);</h4><p>通过上面了解到调用链关系后, 我们继续往下看  firstProcessor.processRequest(si)； , 会调用到 PrepRequestProcessor . </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// request.addRQRec(&quot;&gt;prep=&quot;+zks.outstandingChanges.size());</span></span><br><span class="line">     submittedRequests.add(request);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> processRequest  只是把request 添加到 submittedRequests  中, 这是一个异步操作,  submittedRequests  是一个阻塞队列. </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue&lt;Request&gt; submittedRequests &#x3D; new LinkedBlockingQueue&lt;Request&gt;();</span><br></pre></td></tr></table></figure></blockquote><p>而 PrepRequestProcessor  这个类又继承了线程类, 因此我们直接找到当前类中的run方法如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               Request request = submittedRequests.take();</span><br><span class="line">               <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">               <span class="keyword">if</span> (request.type == OpCode.ping) &#123;</span><br><span class="line">                   traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                   ZooTrace.logRequest(LOG, traceMask, <span class="string">&#x27;P&#x27;</span>, request, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               pRequest(request);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> XidRolloverException) &#123;</span><br><span class="line">               LOG.info(e.getCause().getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">           handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       LOG.info(<span class="string">&quot;PrepRequestProcessor exited loop!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="pRequest"><a href="#pRequest" class="headerlink" title="pRequest"></a>pRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>&#123;</span><br><span class="line">      <span class="comment">// LOG.info(&quot;Prep&gt;&gt;&gt; cxid = &quot; + request.cxid + &quot; type = &quot; +</span></span><br><span class="line">      <span class="comment">// request.type + &quot; id = 0x&quot; + Long.toHexString(request.sessionId));</span></span><br><span class="line">      request.hdr = <span class="keyword">null</span>;</span><br><span class="line">      request.txn = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">switch</span> (request.type) &#123;</span><br><span class="line">              <span class="keyword">case</span> OpCode.create:</span><br><span class="line">              CreateRequest createRequest = <span class="keyword">new</span> CreateRequest();</span><br><span class="line">              pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OpCode.delete:</span><br><span class="line">              DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest();               </span><br><span class="line">              pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OpCode.setData:</span><br><span class="line">              SetDataRequest setDataRequest = <span class="keyword">new</span> SetDataRequest();                </span><br><span class="line">              pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OpCode.setACL:</span><br><span class="line">              SetACLRequest setAclRequest = <span class="keyword">new</span> SetACLRequest();                </span><br><span class="line">              pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OpCode.check:</span><br><span class="line">              CheckVersionRequest checkRequest = <span class="keyword">new</span> CheckVersionRequest();              </span><br><span class="line">              pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OpCode.multi:</span><br><span class="line">              MultiTransactionRecord multiRequest = <span class="keyword">new</span> MultiTransactionRecord();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);</span><br><span class="line">              &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                  request.hdr =  <span class="keyword">new</span> TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(),</span><br><span class="line">                          Time.currentWallTime(), OpCode.multi);</span><br><span class="line">                  <span class="keyword">throw</span> e;</span><br><span class="line">              &#125;</span><br><span class="line">              List&lt;Txn&gt; txns = <span class="keyword">new</span> ArrayList&lt;Txn&gt;();</span><br><span class="line">              <span class="comment">//Each op in a multi-op must have the same zxid!</span></span><br><span class="line">              <span class="keyword">long</span> zxid = zks.getNextZxid();</span><br><span class="line">              KeeperException ke = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//Store off current pending change records in case we need to rollback</span></span><br><span class="line">              HashMap&lt;String, ChangeRecord&gt; pendingChanges = getPendingChanges(multiRequest);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span>(Op op: multiRequest) &#123;</span><br><span class="line">                  Record subrequest = op.toRequestRecord() ;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* If we&#x27;ve already failed one of the ops, don&#x27;t bother</span></span><br><span class="line"><span class="comment">                   * trying the rest as we know it&#x27;s going to fail and it</span></span><br><span class="line"><span class="comment">                   * would be confusing in the logfiles.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  <span class="keyword">if</span> (ke != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      request.hdr.setType(OpCode.error);</span><br><span class="line">                      request.txn = <span class="keyword">new</span> ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());</span><br><span class="line">                  &#125; </span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">/* Prep the request and convert to a Txn */</span></span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          pRequest2Txn(op.getType(), zxid, request, subrequest, <span class="keyword">false</span>);</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                          ke = e;</span><br><span class="line">                          request.hdr.setType(OpCode.error);</span><br><span class="line">                          request.txn = <span class="keyword">new</span> ErrorTxn(e.code().intValue());</span><br><span class="line">                          LOG.info(<span class="string">&quot;Got user-level KeeperException when processing &quot;</span></span><br><span class="line">                          + request.toString() + <span class="string">&quot; aborting remaining multi ops.&quot;</span></span><br><span class="line">                          + <span class="string">&quot; Error Path:&quot;</span> + e.getPath()</span><br><span class="line">                          + <span class="string">&quot; Error:&quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line">                          request.setException(e);</span><br><span class="line"></span><br><span class="line">                          <span class="comment">/* Rollback change records from failed multi-op */</span></span><br><span class="line">                          rollbackPendingChanges(zxid, pendingChanges);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//<span class="doctag">FIXME:</span> I don&#x27;t want to have to serialize it here and then</span></span><br><span class="line">                  <span class="comment">//       immediately deserialize in next processor. But I&#x27;m </span></span><br><span class="line">                  <span class="comment">//       not sure how else to get the txn stored into our list.</span></span><br><span class="line">                  ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                  BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">                  request.txn.serialize(boa, <span class="string">&quot;request&quot;</span>) ;</span><br><span class="line">                  ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());</span><br><span class="line"></span><br><span class="line">                  txns.add(<span class="keyword">new</span> Txn(request.hdr.getType(), bb.array()));</span><br><span class="line">                  index++;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              request.hdr = <span class="keyword">new</span> TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">                      Time.currentWallTime(), request.type);</span><br><span class="line">              request.txn = <span class="keyword">new</span> MultiTxn(txns);</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//create/close session don&#x27;t require request record</span></span><br><span class="line">          <span class="keyword">case</span> OpCode.createSession:</span><br><span class="line">          <span class="keyword">case</span> OpCode.closeSession:</span><br><span class="line">              pRequest2Txn(request.type, zks.getNextZxid(), request, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//All the rest don&#x27;t need to create a Txn - just verify session</span></span><br><span class="line">          <span class="keyword">case</span> OpCode.sync:</span><br><span class="line">          <span class="keyword">case</span> OpCode.exists:</span><br><span class="line">          <span class="keyword">case</span> OpCode.getData:</span><br><span class="line">          <span class="keyword">case</span> OpCode.getACL:</span><br><span class="line">          <span class="keyword">case</span> OpCode.getChildren:</span><br><span class="line">          <span class="keyword">case</span> OpCode.getChildren2:</span><br><span class="line">          <span class="keyword">case</span> OpCode.ping:</span><br><span class="line">          <span class="keyword">case</span> OpCode.setWatches:</span><br><span class="line">              zks.sessionTracker.checkSession(request.sessionId,</span><br><span class="line">                      request.getOwner());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              LOG.warn(<span class="string">&quot;unknown type &quot;</span> + request.type);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) &#123;</span><br><span class="line">              request.hdr.setType(OpCode.error);</span><br><span class="line">              request.txn = <span class="keyword">new</span> ErrorTxn(e.code().intValue());</span><br><span class="line">          &#125;</span><br><span class="line">          LOG.info(<span class="string">&quot;Got user-level KeeperException when processing &quot;</span></span><br><span class="line">                  + request.toString()</span><br><span class="line">                  + <span class="string">&quot; Error Path:&quot;</span> + e.getPath()</span><br><span class="line">                  + <span class="string">&quot; Error:&quot;</span> + e.getMessage());</span><br><span class="line">          request.setException(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// log at error level as we are returning a marshalling</span></span><br><span class="line">          <span class="comment">// error to the user</span></span><br><span class="line">          LOG.error(<span class="string">&quot;Failed to process &quot;</span> + request, e);</span><br><span class="line"></span><br><span class="line">          StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">          ByteBuffer bb = request.request;</span><br><span class="line">          <span class="keyword">if</span>(bb != <span class="keyword">null</span>)&#123;</span><br><span class="line">              bb.rewind();</span><br><span class="line">              <span class="keyword">while</span> (bb.hasRemaining()) &#123;</span><br><span class="line">                  sb.append(Integer.toHexString(bb.get() &amp; <span class="number">0xff</span>));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sb.append(<span class="string">&quot;request buffer is null&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          LOG.error(<span class="string">&quot;Dumping request buffer: 0x&quot;</span> + sb.toString());</span><br><span class="line">          <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) &#123;</span><br><span class="line">              request.hdr.setType(OpCode.error);</span><br><span class="line">              request.txn = <span class="keyword">new</span> ErrorTxn(Code.MARSHALLINGERROR.intValue());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      request.zxid = zks.getZxid();</span><br><span class="line">      nextProcessor.processRequest(request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>前面的N行代码都是根据当前的OP 类型进行判断和做相应的处理, 这个方法中的最后一行中, 我们会看到</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextProcessor.processRequest(request);</span><br></pre></td></tr></table></figure></blockquote><h4 id="SyncRequestProcessor-processRequest"><a href="#SyncRequestProcessor-processRequest" class="headerlink" title="SyncRequestProcessor. processRequest"></a>SyncRequestProcessor. processRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// request.addRQRec(&quot;&gt;sync&quot;);</span></span><br><span class="line">      queuedRequests.add(request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法的代码也是一样, 基于差异化操作, 把请求添加到queuedRequests中, 我们继续在当前类中找到run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> logCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></span><br><span class="line">           <span class="comment">// in the ensemble take a snapshot at the same time</span></span><br><span class="line">           setRandRoll(r.nextInt(snapCount/<span class="number">2</span>));</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               Request si = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                   si = queuedRequests.take();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   si = queuedRequests.poll();</span><br><span class="line">                   <span class="keyword">if</span> (si == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       flush(toFlush);</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (si == requestOfDeath) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// track the number of records written to the log</span></span><br><span class="line">                   <span class="keyword">if</span> (zks.getZKDatabase().append(si)) &#123;</span><br><span class="line">                       logCount++;</span><br><span class="line">                       <span class="keyword">if</span> (logCount &gt; (snapCount / <span class="number">2</span> + randRoll)) &#123;</span><br><span class="line">                           setRandRoll(r.nextInt(snapCount/<span class="number">2</span>));</span><br><span class="line">                           <span class="comment">// roll the log</span></span><br><span class="line">                           zks.getZKDatabase().rollLog();</span><br><span class="line">                           <span class="comment">// take a snapshot</span></span><br><span class="line">                           <span class="keyword">if</span> (snapInProcess != <span class="keyword">null</span> &amp;&amp; snapInProcess.isAlive()) &#123;</span><br><span class="line">                               LOG.warn(<span class="string">&quot;Too busy to snap, skipping&quot;</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               snapInProcess = <span class="keyword">new</span> ZooKeeperThread(<span class="string">&quot;Snapshot Thread&quot;</span>) &#123;</span><br><span class="line">                                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                           <span class="keyword">try</span> &#123;</span><br><span class="line">                                               zks.takeSnapshot();</span><br><span class="line">                                           &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                                               LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;;</span><br><span class="line">                               snapInProcess.start();</span><br><span class="line">                           &#125;</span><br><span class="line">                           logCount = <span class="number">0</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                       <span class="comment">// optimization for read heavy workloads</span></span><br><span class="line">                       <span class="comment">// iff this is a read, and there are no pending</span></span><br><span class="line">                       <span class="comment">// flushes (writes), then just pass this to the next</span></span><br><span class="line">                       <span class="comment">// processor</span></span><br><span class="line">                       <span class="keyword">if</span> (nextProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           nextProcessor.processRequest(si);</span><br><span class="line">                           <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) &#123;</span><br><span class="line">                               ((Flushable)nextProcessor).flush();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   toFlush.add(si);</span><br><span class="line">                   <span class="keyword">if</span> (toFlush.size() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                       flush(toFlush);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           handleException(<span class="keyword">this</span>.getName(), t);</span><br><span class="line">           running = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       LOG.info(<span class="string">&quot;SyncRequestProcessor exited!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="FinalRequestProcessor-processRequest"><a href="#FinalRequestProcessor-processRequest" class="headerlink" title="FinalRequestProcessor. processRequest"></a>FinalRequestProcessor. processRequest</h4><p> FinalRequestProcessor. processRequest  方法根据request方法中的操作更新内容中session 信息或者znode数据。 </p><p>这块代码又300行, 就不全部贴出来了, 我们直接定位到关键代码，根据客户端的OP 类型找到如下代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OpCode.exists: &#123;</span><br><span class="line">               lastOp = <span class="string">&quot;EXIS&quot;</span>;</span><br><span class="line">               <span class="comment">// TODO we need to figure out the security requirement for this!</span></span><br><span class="line">               <span class="comment">// 反序列化(将byteBuffer反序列化为ExistsRequest, 这个就是我们在客户端请求的时候传过来的request对象)</span></span><br><span class="line">               ExistsRequest existsRequest = <span class="keyword">new</span> ExistsRequest();</span><br><span class="line">               ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                       existsRequest);</span><br><span class="line">               String path = existsRequest.getPath();</span><br><span class="line">               <span class="keyword">if</span> (path.indexOf(<span class="string">&#x27;\0&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadArgumentsException();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 终于找到一个很关键的代码, 判断请求的getwatch 是否存在, 如果存在,则传入 cnxn</span></span><br><span class="line">               <span class="comment">// 对于exits 请求, 需要监听data 变化事件, 添加watch</span></span><br><span class="line">               Stat stat = zks.getZKDatabase().statNode(path, existsRequest</span><br><span class="line">                       .getWatch() ? cnxn : <span class="keyword">null</span>);</span><br><span class="line">               <span class="comment">// 在服务端内存数据库中根据路径得到结果进行封装, 设置为ExistsResponse</span></span><br><span class="line">               rsp = <span class="keyword">new</span> ExistsResponse(stat);</span><br><span class="line">               <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="客户端接收服务端处理完成的响应"><a href="#客户端接收服务端处理完成的响应" class="headerlink" title="客户端接收服务端处理完成的响应"></a>客户端接收服务端处理完成的响应</h2><p> ClientCnxnSocketNIO.doIO </p><p>服务端处理完成后, 会通过 NIOServerCnxn.sendResponse  发送返回的响应信息, 客户端会在 ClientCnxnSocketNIO.doIO  接收服务端的返回. 注意一下  SendThread.readResponse ,接收服务端的信息机进行读取. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIO</span><span class="params">(List&lt;Packet&gt; pendingQueue, LinkedList&lt;Packet&gt; outgoingQueue, ClientCnxn cnxn)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">       SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">       <span class="keyword">if</span> (sock == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Socket is null!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (sockKey.isReadable()) &#123;</span><br><span class="line">           <span class="keyword">int</span> rc = sock.read(incomingBuffer);</span><br><span class="line">           <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</span><br><span class="line">                       <span class="string">&quot;Unable to read additional data from server sessionid 0x&quot;</span></span><br><span class="line">                               + Long.toHexString(sessionId)</span><br><span class="line">                               + <span class="string">&quot;, likely server has closed socket&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">               incomingBuffer.flip();</span><br><span class="line">               <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">                   recvCount++;</span><br><span class="line">                   readLength();</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                   readConnectResult();</span><br><span class="line">                   enableRead();</span><br><span class="line">                   <span class="keyword">if</span> (findSendablePacket(outgoingQueue,</span><br><span class="line">                           cnxn.sendThread.clientTunneledAuthenticationInProgress()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Since SASL authentication has completed (if client is configured to do so),</span></span><br><span class="line">                       <span class="comment">// outgoing packets waiting in the outgoingQueue can now be sent.</span></span><br><span class="line">                       enableWrite();</span><br><span class="line">                   &#125;</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">                   initialized = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   sendThread.readResponse(incomingBuffer);</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (sockKey.isWritable()) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(outgoingQueue) &#123;</span><br><span class="line">               Packet p = findSendablePacket(outgoingQueue,</span><br><span class="line">                       cnxn.sendThread.clientTunneledAuthenticationInProgress());</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   updateLastSend();</span><br><span class="line">                   <span class="comment">// If we already started writing p, p.bb will already exist</span></span><br><span class="line">                   <span class="keyword">if</span> (p.bb == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> ((p.requestHeader != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                               (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</span><br><span class="line">                               (p.requestHeader.getType() != OpCode.auth)) &#123;</span><br><span class="line">                           p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                       &#125;</span><br><span class="line">                       p.createBB();</span><br><span class="line">                   &#125;</span><br><span class="line">                   sock.write(p.bb);</span><br><span class="line">                   <span class="keyword">if</span> (!p.bb.hasRemaining()) &#123;</span><br><span class="line">                       sentCount++;</span><br><span class="line">                       outgoingQueue.removeFirstOccurrence(p);</span><br><span class="line">                       <span class="keyword">if</span> (p.requestHeader != <span class="keyword">null</span></span><br><span class="line">                               &amp;&amp; p.requestHeader.getType() != OpCode.ping</span><br><span class="line">                               &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</span><br><span class="line">                           <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">                               pendingQueue.add(p);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">                   <span class="comment">// No more packets to send: turn off write interest flag.</span></span><br><span class="line">                   <span class="comment">// Will be turned on later by a later call to enableWrite(),</span></span><br><span class="line">                   <span class="comment">// from within ZooKeeperSaslClient (if client is configured</span></span><br><span class="line">                   <span class="comment">// to attempt SASL authentication), or in either doIO() or</span></span><br><span class="line">                   <span class="comment">// in doTransport() if not.</span></span><br><span class="line">                   disableWrite();</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized &amp;&amp; p != <span class="keyword">null</span> &amp;&amp; !p.bb.hasRemaining()) &#123;</span><br><span class="line">                   <span class="comment">// On initial connection, write the complete connect request</span></span><br><span class="line">                   <span class="comment">// packet, but then disable further writes until after</span></span><br><span class="line">                   <span class="comment">// receiving a successful connection response.  If the</span></span><br><span class="line">                   <span class="comment">// session is expired, then the server sends the expiration</span></span><br><span class="line">                   <span class="comment">// response and immediately closes its end of the socket.  If</span></span><br><span class="line">                   <span class="comment">// the client is simultaneously writing on its end, then the</span></span><br><span class="line">                   <span class="comment">// TCP stack may choose to abort with RST, in which case the</span></span><br><span class="line">                   <span class="comment">// client would never receive the session expired event.  See</span></span><br><span class="line">                   <span class="comment">// http://docs.oracle.com/javase/6/docs/technotes/guides/net/articles/connection_release.html</span></span><br><span class="line">                   disableWrite();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// Just in case</span></span><br><span class="line">                   enableWrite();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="SendThread-readResponse"><a href="#SendThread-readResponse" class="headerlink" title="SendThread. readResponse"></a>SendThread. readResponse</h4><p>这个方法里面主要流程如下: </p><ol><li>读取head, 如果其xid ==2, 表明是一个ping 的reponse,return</li><li>如果xid == 4,表明是一个 AuthPacket 的 response return </li><li>如果xid ==1, 表明是一个 notification , 此时要继续读取并构造一个event, 通过 EventThread.queueEvent , 并return.</li></ol><p>其他情况下:</p><p>从 pendingQueue  中拿出一个 Packet，校验后更新 packet 信息. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">                   incomingBuffer);</span><br><span class="line">           BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">           ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 反序列化header</span></span><br><span class="line">           replyHdr.deserialize(bbia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">2</span>) &#123;</span><br><span class="line">               <span class="comment">// -2 is the xid for pings</span></span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got ping response for sessionid: 0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId)</span><br><span class="line">                           + <span class="string">&quot; after &quot;</span></span><br><span class="line">                           + ((System.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>)</span><br><span class="line">                           + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">4</span>) &#123;</span><br><span class="line">               <span class="comment">// -4 is the xid for AuthPacket</span></span><br><span class="line">               <span class="keyword">if</span>(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">                   state = States.AUTH_FAILED;</span><br><span class="line">                   eventThread.queueEvent( <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None,</span><br><span class="line">                           Watcher.Event.KeeperState.AuthFailed, <span class="keyword">null</span>) );</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got auth sessionid:0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 表示当前的消息类型为一个notification(意味着是服务端的一个响应事件)</span></span><br><span class="line">           <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">// -1 means notification</span></span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got notification sessionid:0x&quot;</span></span><br><span class="line">                       + Long.toHexString(sessionId));</span><br><span class="line">               &#125;</span><br><span class="line">               WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</span><br><span class="line">               <span class="comment">// 反序列化响应信息</span></span><br><span class="line">               event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">               <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   String serverPath = event.getPath();</span><br><span class="line">                   <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line">                       event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                       event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                   LOG.warn(<span class="string">&quot;Got server path &quot;</span> + event.getPath()</span><br><span class="line">                   + <span class="string">&quot; which is too short for chroot path &quot;</span></span><br><span class="line">                   + chrootPath);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got &quot;</span> + we + <span class="string">&quot; for sessionid 0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               eventThread.queueEvent( we );</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If SASL authentication is currently in progress, construct and</span></span><br><span class="line">           <span class="comment">// send a response packet immediately, rather than queuing a</span></span><br><span class="line">           <span class="comment">// response as with other packets.</span></span><br><span class="line">           <span class="keyword">if</span> (clientTunneledAuthenticationInProgress()) &#123;</span><br><span class="line">               GetSASLRequest request = <span class="keyword">new</span> GetSASLRequest();</span><br><span class="line">               request.deserialize(bbia,<span class="string">&quot;token&quot;</span>);</span><br><span class="line">               zooKeeperSaslClient.respondToServer(request.getToken(),</span><br><span class="line">                 ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Packet packet;</span><br><span class="line">           <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">               <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Nothing in the queue, but got &quot;</span></span><br><span class="line">                           + replyHdr.getXid());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 因为当前的数据包已经收到了响应,所以将他从pendingQueue 中移除了.</span></span><br><span class="line">               packet = pendingQueue.remove();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">            * to the first request!</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 校验 数据包信息, 校验成功后将数据包信息进行更新(替换为服务端信息)</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">                   packet.replyHeader.setErr(</span><br><span class="line">                           KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Xid out of order. Got Xid &quot;</span></span><br><span class="line">                           + replyHdr.getXid() + <span class="string">&quot; with err &quot;</span> +</span><br><span class="line">                           + replyHdr.getErr() +</span><br><span class="line">                           <span class="string">&quot; expected Xid &quot;</span></span><br><span class="line">                           + packet.requestHeader.getXid()</span><br><span class="line">                           + <span class="string">&quot; for a packet with details: &quot;</span></span><br><span class="line">                           + packet );</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">               packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">               packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">               <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   lastZxid = replyHdr.getZxid();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (packet.response != <span class="keyword">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// 获取服务端的响应, 反序列化之后设置到packet.response 属性中, 所以我们可以在exits方法的最后一行中通过packet.response 拿到该请求的返回结果</span></span><br><span class="line">                   packet.response.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Reading reply sessionid:0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId) + <span class="string">&quot;, packet:: &quot;</span> + packet);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 最后调用finishPacket 方法完成处理</span></span><br><span class="line">               finishPacket(packet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="finishPacket-方法"><a href="#finishPacket-方法" class="headerlink" title="finishPacket 方法"></a>finishPacket 方法</h4><p>主要功能是把从packet 中取出对应的Watcher 注册到  ZKWatchManager  中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 将事件注册到 zkwatchermanage 中</span></span><br><span class="line">           <span class="comment">// watchRegistration, 在组装请求的时候,我们初始化了这个对象, 把 watchRegistration 子类里面的</span></span><br><span class="line">           <span class="comment">// watcher 实例放到了ZKWatcherMananage 的exists watches 中存储起来</span></span><br><span class="line">           p.watchRegistration.register(p.replyHeader.getErr());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// cb 就是AsnycCallback，如果为null, 表明是同步调用地方接口,不需要异步回调, 因为直接notifyAll</span></span><br><span class="line">       <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">               p.finished = <span class="keyword">true</span>;</span><br><span class="line">               p.notifyAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           p.finished = <span class="keyword">true</span>;</span><br><span class="line">           eventThread.queuePacket(p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="watchRegistration-register"><a href="#watchRegistration-register" class="headerlink" title="watchRegistration.register"></a>watchRegistration.register</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</span><br><span class="line">              <span class="comment">// 通过子类的实现取得 ZKWatchManager 中的 existsWatches</span></span><br><span class="line">              Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">              <span class="keyword">synchronized</span>(watches) &#123;</span><br><span class="line">                  Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">                  <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                      watches.put(clientPath, watchers);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 将watcher 对象放到到 ZKWatchManager 中的 existsWatches 里面</span></span><br><span class="line">                  watchers.add(watcher);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>下面这段代码是客户端存储watcher的几个map 集合, 分别对应三种注册监听事件. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title">ClientWatchManager</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说, 当使用zookeeper 构造方法或者使用getData、exits和getChildren 三个接口来向zookeeper 服务器注册watcher 的时候, 首先将此消息传递给服务端, 传递成功后, 服务端会通知客户端, 然后客户端将该路径和watcher 对应关系存储起来备用. </p><h4 id="EventThread-queuePacket"><a href="#EventThread-queuePacket" class="headerlink" title="EventThread.queuePacket()"></a>EventThread.queuePacket()</h4><p> finishPacket  方法最终会调用 EventThread.queuePacket()    , 将当前的数据包添加到等待事件通知的队列中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queuePacket</span><span class="params">(Packet packet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wasKilled) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isRunning) waitingEvents.add(packet);</span><br><span class="line">              <span class="keyword">else</span> processEvent(packet);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           waitingEvents.add(packet);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>通过那么长的说明, 只是为了清晰的说明事件的注册流程, 最终的触发, 还得需要通过事务性操作来完成. </p><p>在我们最开始的案例中,通过如下代码来完成事件的触发: </p><blockquote><p>zooKeeper.setData(path, “1”.getBytes(), -1);</p></blockquote><p>前面的客户端和服务端对戒的流程就不重复讲解了, 交互流程是一样的, 唯一的差别就是在于事件触发了. </p><h4 id="服务端的事件响应-DataTree-setData"><a href="#服务端的事件响应-DataTree-setData" class="headerlink" title="服务端的事件响应  DataTree.setData()"></a>服务端的事件响应  DataTree.setData()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">       Stat s = <span class="keyword">new</span> Stat();</span><br><span class="line">       DataNode n = nodes.get(path);</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">byte</span> lastdata[] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">           lastdata = n.data;</span><br><span class="line">           n.data = data;</span><br><span class="line">           n.stat.setMtime(time);</span><br><span class="line">           n.stat.setMzxid(zxid);</span><br><span class="line">           n.stat.setVersion(version);</span><br><span class="line">           n.copyStat(s);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// now update if the path is in a quota subtree.</span></span><br><span class="line">       String lastPrefix;</span><br><span class="line">       <span class="keyword">if</span>((lastPrefix = getMaxPrefixWithQuota(path)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</span><br><span class="line">             - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 触发对应节点的NodeDataChanged 事件</span></span><br><span class="line">       dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="WatcherManager-triggerWatch"><a href="#WatcherManager-triggerWatch" class="headerlink" title="WatcherManager. triggerWatch"></a>WatcherManager. triggerWatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> triggerWatch(path, type, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 根据事件类型、连接状态、节点路径创建WatchedEvent</span></span><br><span class="line">       WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type,</span><br><span class="line">               KeeperState.SyncConnected, path);</span><br><span class="line">       HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="comment">// 从watcher 中移除path, 并返回其对应的watcher 集合.</span></span><br><span class="line">           watchers = watchTable.remove(path);</span><br><span class="line">           <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                   ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                           ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                           <span class="string">&quot;No watchers for &quot;</span> + path);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 遍历watcher 集合</span></span><br><span class="line">           <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">               <span class="comment">// 根据watcher 从watcher 表中取出路径集合</span></span><br><span class="line">               HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">               <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 移除路径</span></span><br><span class="line">                   paths.remove(path);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//  遍历watcher 集合</span></span><br><span class="line">       <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">           <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           w.process(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> watchers;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="w-process-e"><a href="#w-process-e" class="headerlink" title="w.process(e);"></a>w.process(e);</h4><p>还记得我们在服务端绑定事件的时候，watcher  绑定的是什么吗? 是 ServerCnxn，  所以w.process(e); , 其实就是调用的是 ServerCnxn  的process 方法, 而ServerCnxn 又是一个抽象方法, 分别是 NIOServerCnxn 和  NettyServerCnxn。那接下来我们扒开  NettyServerCnxn这个类的process 方法看看究竟. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">      ReplyHeader h = <span class="keyword">new</span> ReplyHeader(-<span class="number">1</span>, -<span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">          ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                                   <span class="string">&quot;Deliver event &quot;</span> + event + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                                   + Long.toHexString(<span class="keyword">this</span>.sessionId)</span><br><span class="line">                                   + <span class="string">&quot; through &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></span><br><span class="line">      WatcherEvent e = event.getWrapper();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 这个地方发送了一个事件,事件对象为WatchedEvent</span></span><br><span class="line">          sendResponse(h, e, <span class="string">&quot;notification&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">          <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">              LOG.debug(<span class="string">&quot;Problem sending to &quot;</span> + getRemoteSocketAddress(), e1);</span><br><span class="line">          &#125;</span><br><span class="line">          close();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>那接下来, 客户端会受到这个response, 触发SendThread.readResponse  方法</p><h3 id="客户端处理事件响应"><a href="#客户端处理事件响应" class="headerlink" title="客户端处理事件响应"></a>客户端处理事件响应</h3><h4 id="SendThread-readResponse-1"><a href="#SendThread-readResponse-1" class="headerlink" title="SendThread.readResponse"></a>SendThread.readResponse</h4><p>watcher.materializwatcher.materializ这块代码已经贴过了, 我们只挑选当前流程的代码进行讲解, 按照我们前面讲到的,  notifacation  通知消息的xid 为-1, u意味着直接找到-1的判断进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">                   incomingBuffer);</span><br><span class="line">           BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">           ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 反序列化header</span></span><br><span class="line">           replyHdr.deserialize(bbia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">2</span>) &#123;</span><br><span class="line">               <span class="comment">// -2 is the xid for pings</span></span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got ping response for sessionid: 0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId)</span><br><span class="line">                           + <span class="string">&quot; after &quot;</span></span><br><span class="line">                           + ((System.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>)</span><br><span class="line">                           + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">4</span>) &#123;</span><br><span class="line">               <span class="comment">// -4 is the xid for AuthPacket</span></span><br><span class="line">               <span class="keyword">if</span>(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">                   state = States.AUTH_FAILED;</span><br><span class="line">                   eventThread.queueEvent( <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None,</span><br><span class="line">                           Watcher.Event.KeeperState.AuthFailed, <span class="keyword">null</span>) );</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got auth sessionid:0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 表示当前的消息类型为一个notification(意味着是服务端的一个响应事件)</span></span><br><span class="line">           <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">// -1 means notification</span></span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got notification sessionid:0x&quot;</span></span><br><span class="line">                       + Long.toHexString(sessionId));</span><br><span class="line">               &#125;</span><br><span class="line">               WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</span><br><span class="line">               <span class="comment">// 反序列化响应信息</span></span><br><span class="line">               event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">               <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   String serverPath = event.getPath();</span><br><span class="line">                   <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line">                       event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                       event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                   LOG.warn(<span class="string">&quot;Got server path &quot;</span> + event.getPath()</span><br><span class="line">                   + <span class="string">&quot; which is too short for chroot path &quot;</span></span><br><span class="line">                   + chrootPath);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Got &quot;</span> + we + <span class="string">&quot; for sessionid 0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               eventThread.queueEvent( we );</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If SASL authentication is currently in progress, construct and</span></span><br><span class="line">           <span class="comment">// send a response packet immediately, rather than queuing a</span></span><br><span class="line">           <span class="comment">// response as with other packets.</span></span><br><span class="line">           <span class="keyword">if</span> (clientTunneledAuthenticationInProgress()) &#123;</span><br><span class="line">               GetSASLRequest request = <span class="keyword">new</span> GetSASLRequest();</span><br><span class="line">               request.deserialize(bbia,<span class="string">&quot;token&quot;</span>);</span><br><span class="line">               zooKeeperSaslClient.respondToServer(request.getToken(),</span><br><span class="line">                 ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Packet packet;</span><br><span class="line">           <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">               <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Nothing in the queue, but got &quot;</span></span><br><span class="line">                           + replyHdr.getXid());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 因为当前的数据包已经收到了响应,所以将他从pendingQueue 中移除了.</span></span><br><span class="line">               packet = pendingQueue.remove();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">            * to the first request!</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 校验 数据包信息, 校验成功后将数据包信息进行更新(替换为服务端信息)</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">                   packet.replyHeader.setErr(</span><br><span class="line">                           KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Xid out of order. Got Xid &quot;</span></span><br><span class="line">                           + replyHdr.getXid() + <span class="string">&quot; with err &quot;</span> +</span><br><span class="line">                           + replyHdr.getErr() +</span><br><span class="line">                           <span class="string">&quot; expected Xid &quot;</span></span><br><span class="line">                           + packet.requestHeader.getXid()</span><br><span class="line">                           + <span class="string">&quot; for a packet with details: &quot;</span></span><br><span class="line">                           + packet );</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">               packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">               packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">               <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   lastZxid = replyHdr.getZxid();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (packet.response != <span class="keyword">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// 获取服务端的响应, 反序列化之后设置到packet.response 属性中, 所以我们可以在exits方法的最后一行中通过packet.response 拿到该请求的返回结果</span></span><br><span class="line">                   packet.response.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   LOG.debug(<span class="string">&quot;Reading reply sessionid:0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId) + <span class="string">&quot;, packet:: &quot;</span> + packet);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 最后调用finishPacket 方法完成处理</span></span><br><span class="line">               finishPacket(packet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="eventThread-queueEvent"><a href="#eventThread-queueEvent" class="headerlink" title="eventThread.queueEvent"></a>eventThread.queueEvent</h4><p> SendThread  接受到服务端的通知事件, 会通过调用 EventThread  类的queueEvent 方法将事件传给 EventThread 线程, queueEvent 方法根据该通知事件, 从 ZKWatchManager  中取出所有相关的watcher, 如果获取到相应的watcher, 就会让watcher 移除失效. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (event.getType() == EventType.None</span><br><span class="line">                 &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">             <span class="comment">// 判断类型</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         sessionState = event.getState();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// materialize the watchers based on the event</span></span><br><span class="line">         <span class="comment">// 封装 WatcherSetEventPair 对象, 添加到waitingEvents 队列中</span></span><br><span class="line">         WatcherSetEventPair pair = <span class="keyword">new</span> WatcherSetEventPair(</span><br><span class="line">                 watcher.materialize(event.getState(), event.getType(),</span><br><span class="line">                         event.getPath()),</span><br><span class="line">                         event);</span><br><span class="line">         <span class="comment">// queue the pair (watch set &amp; event) for later processing</span></span><br><span class="line">         waitingEvents.add(pair);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="watcher-materializ"><a href="#watcher-materializ" class="headerlink" title="watcher.materializ"></a>watcher.materializ</h4><p>通过  dataWatches 或者 existWatches 或者 childWatches 的 remove 取出对应的watch, 表明客户端watch 也是注册一次就移除. </p><p>同时需要根据 keeperState、eventType 和 path  返回应该被通知的watcher 集合. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">materialize</span><span class="params">(Watcher.Event.KeeperState state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Watcher.Event.EventType type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String clientPath)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           Set&lt;Watcher&gt; result = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> None:</span><br><span class="line">               result.add(defaultWatcher);</span><br><span class="line">               <span class="keyword">boolean</span> clear = ClientCnxn.getDisableAutoResetWatch() &amp;&amp;</span><br><span class="line">                       state != Watcher.Event.KeeperState.SyncConnected;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">synchronized</span>(dataWatches) &#123;</span><br><span class="line">                   <span class="keyword">for</span>(Set&lt;Watcher&gt; ws: dataWatches.values()) &#123;</span><br><span class="line">                       result.addAll(ws);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">                       dataWatches.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">synchronized</span>(existWatches) &#123;</span><br><span class="line">                   <span class="keyword">for</span>(Set&lt;Watcher&gt; ws: existWatches.values()) &#123;</span><br><span class="line">                       result.addAll(ws);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">                       existWatches.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">synchronized</span>(childWatches) &#123;</span><br><span class="line">                   <span class="keyword">for</span>(Set&lt;Watcher&gt; ws: childWatches.values()) &#123;</span><br><span class="line">                       result.addAll(ws);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">                       childWatches.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">           <span class="keyword">case</span> NodeCreated:</span><br><span class="line">               <span class="keyword">synchronized</span> (dataWatches) &#123;</span><br><span class="line">                   addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (existWatches) &#123;</span><br><span class="line">                   addTo(existWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">               <span class="keyword">synchronized</span> (childWatches) &#123;</span><br><span class="line">                   addTo(childWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">               <span class="keyword">synchronized</span> (dataWatches) &#123;</span><br><span class="line">                   addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// XXX This shouldn&#x27;t be needed, but just in case</span></span><br><span class="line">               <span class="keyword">synchronized</span> (existWatches) &#123;</span><br><span class="line">                   Set&lt;Watcher&gt; list = existWatches.remove(clientPath);</span><br><span class="line">                   <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       addTo(list, result);</span><br><span class="line">                       LOG.warn(<span class="string">&quot;We are triggering an exists watch for delete! Shouldn&#x27;t happen!&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (childWatches) &#123;</span><br><span class="line">                   addTo(childWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               String msg = <span class="string">&quot;Unhandled watch event type &quot;</span> + type</span><br><span class="line">                   + <span class="string">&quot; with state &quot;</span> + state + <span class="string">&quot; on path &quot;</span> + clientPath;</span><br><span class="line">               LOG.error(msg);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(msg);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="waitingEvents-add"><a href="#waitingEvents-add" class="headerlink" title="waitingEvents.add"></a>waitingEvents.add</h4><p>最后一步, 接近真相了. </p><p>waitingEvents 是  EventThread  这个线程的祖寺啊队列, 很明显, 又是我们在第一步操作的时候实例化的一个线程. </p><p>从名字可以知道, waitingEvents  是一个待处理的watcher 的队列, EventThread   的run()  方法 会不断的从队列中取数据,交由  processEvent  方法处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            isRunning = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 从待处理的事件队列中取出事件</span></span><br><span class="line">               Object event = waitingEvents.take();</span><br><span class="line">               <span class="keyword">if</span> (event == eventOfDeath) &#123;</span><br><span class="line">                  wasKilled = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行事件处理</span></span><br><span class="line">                  processEvent(event);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (wasKilled)</span><br><span class="line">                  <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (waitingEvents.isEmpty()) &#123;</span><br><span class="line">                        isRunning = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Event thread exiting due to interruption&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">          LOG.info(<span class="string">&quot;EventThread shut down for session: 0x&#123;&#125;&quot;</span>,</span><br><span class="line">                   Long.toHexString(getSessionId()));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="processEvent"><a href="#processEvent" class="headerlink" title="processEvent"></a>processEvent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断事件类型, </span></span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WatcherSetEventPair) &#123;</span><br><span class="line">                <span class="comment">// each watcher will process the event</span></span><br><span class="line">                <span class="comment">// 得到WatcherSetEventPair</span></span><br><span class="line">                WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">                <span class="comment">// 拿到符合触发机制的所有watcher列表， 循环调用. </span></span><br><span class="line">                <span class="keyword">for</span> (Watcher watcher : pair.watchers) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用客户端的回调process</span></span><br><span class="line">                        watcher.process(pair.event);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        LOG.error(<span class="string">&quot;Error while calling watcher &quot;</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Packet p = (Packet) event;</span><br><span class="line">                <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">                String clientPath = p.clientPath;</span><br><span class="line">                <span class="keyword">if</span> (p.replyHeader.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">                    rc = p.replyHeader.getErr();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Somehow a null cb got to EventThread!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> ExistsResponse</span><br><span class="line">                        || p.response <span class="keyword">instanceof</span> SetDataResponse</span><br><span class="line">                        || p.response <span class="keyword">instanceof</span> SetACLResponse) &#123;</span><br><span class="line">                    StatCallback cb = (StatCallback) p.cb;</span><br><span class="line">                    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> ExistsResponse) &#123;</span><br><span class="line">                            cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                    ((ExistsResponse) p.response)</span><br><span class="line">                                            .getStat());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> SetDataResponse) &#123;</span><br><span class="line">                            cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                    ((SetDataResponse) p.response)</span><br><span class="line">                                            .getStat());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> SetACLResponse) &#123;</span><br><span class="line">                            cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                    ((SetACLResponse) p.response)</span><br><span class="line">                                            .getStat());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetDataResponse) &#123;</span><br><span class="line">                    DataCallback cb = (DataCallback) p.cb;</span><br><span class="line">                    GetDataResponse rsp = (GetDataResponse) p.response;</span><br><span class="line">                    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                                .getData(), rsp.getStat());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetACLResponse) &#123;</span><br><span class="line">                    ACLCallback cb = (ACLCallback) p.cb;</span><br><span class="line">                    GetACLResponse rsp = (GetACLResponse) p.response;</span><br><span class="line">                    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                                .getAcl(), rsp.getStat());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetChildrenResponse) &#123;</span><br><span class="line">                    ChildrenCallback cb = (ChildrenCallback) p.cb;</span><br><span class="line">                    GetChildrenResponse rsp = (GetChildrenResponse) p.response;</span><br><span class="line">                    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                                .getChildren());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> GetChildren2Response) &#123;</span><br><span class="line">                    Children2Callback cb = (Children2Callback) p.cb;</span><br><span class="line">                    GetChildren2Response rsp = (GetChildren2Response) p.response;</span><br><span class="line">                    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, rsp</span><br><span class="line">                                .getChildren(), rsp.getStat());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> CreateResponse) &#123;</span><br><span class="line">                    StringCallback cb = (StringCallback) p.cb;</span><br><span class="line">                    CreateResponse rsp = (CreateResponse) p.response;</span><br><span class="line">                    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                (chrootPath == <span class="keyword">null</span></span><br><span class="line">                                        ? rsp.getPath()</span><br><span class="line">                                        : rsp.getPath()</span><br><span class="line">                                  .substring(chrootPath.length())));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> MultiResponse) &#123;</span><br><span class="line">                        MultiCallback cb = (MultiCallback) p.cb;</span><br><span class="line">                        MultiResponse rsp = (MultiResponse) p.response;</span><br><span class="line">                        <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">                                List&lt;OpResult&gt; results = rsp.getResultList();</span><br><span class="line">                                <span class="keyword">int</span> newRc = rc;</span><br><span class="line">                                <span class="keyword">for</span> (OpResult result : results) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ErrorResult</span><br><span class="line">                                            &amp;&amp; KeeperException.Code.OK.intValue()</span><br><span class="line">                                                != (newRc = ((ErrorResult) result).getErr())) &#123;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                cb.processResult(newRc, clientPath, p.ctx, results);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                cb.processResult(rc, clientPath, p.ctx, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (p.cb <span class="keyword">instanceof</span> VoidCallback) &#123;</span><br><span class="line">                    VoidCallback cb = (VoidCallback) p.cb;</span><br><span class="line">                    cb.processResult(rc, clientPath, p.ctx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Caught unexpected throwable&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="服务端接受数据请求"><a href="#服务端接受数据请求" class="headerlink" title="服务端接受数据请求."></a>服务端接受数据请求.</h2><p>服务端收到的数据包应该在哪里呢? zookee 启动的时候, 通过下面的代码中构建了一个</p><blockquote><p> ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();  </p></blockquote><p>ServerCnxnFactory  ,它实现类 Thread, 所以在启动的时候, 会在run 方法中不断循环接受客户端的请求进行分发. </p><h4 id="NIOServerCnxnFactory-run"><a href="#NIOServerCnxnFactory-run" class="headerlink" title="NIOServerCnxnFactory.run"></a>NIOServerCnxnFactory.run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!ss.socket().isClosed()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取client 的连接请求</span></span><br><span class="line">              selector.select(<span class="number">1000</span>);</span><br><span class="line">              Set&lt;SelectionKey&gt; selected;</span><br><span class="line">              <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                  selected = selector.selectedKeys();</span><br><span class="line">              &#125;</span><br><span class="line">              ArrayList&lt;SelectionKey&gt; selectedList = <span class="keyword">new</span> ArrayList&lt;SelectionKey&gt;(</span><br><span class="line">                      selected);</span><br><span class="line">              Collections.shuffle(selectedList);</span><br><span class="line">              <span class="keyword">for</span> (SelectionKey k : selectedList) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) &#123;</span><br><span class="line">                      SocketChannel sc = ((ServerSocketChannel) k</span><br><span class="line">                              .channel()).accept();</span><br><span class="line">                      InetAddress ia = sc.socket().getInetAddress();</span><br><span class="line">                      <span class="keyword">int</span> cnxncount = getClientCnxnCount(ia);</span><br><span class="line">                      <span class="keyword">if</span> (maxClientCnxns &gt; <span class="number">0</span> &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;</span><br><span class="line">                          LOG.warn(<span class="string">&quot;Too many connections from &quot;</span> + ia</span><br><span class="line">                                   + <span class="string">&quot; - max is &quot;</span> + maxClientCnxns );</span><br><span class="line">                          sc.close();</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          LOG.info(<span class="string">&quot;Accepted socket connection from &quot;</span></span><br><span class="line">                                   + sc.socket().getRemoteSocketAddress());</span><br><span class="line">                          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                          SelectionKey sk = sc.register(selector,</span><br><span class="line">                                  SelectionKey.OP_READ);</span><br><span class="line">                          NIOServerCnxn cnxn = createConnection(sc, sk);</span><br><span class="line">                          sk.attach(cnxn);</span><br><span class="line">                          addCnxn(cnxn);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">// 处理客户端的读写请求</span></span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                      NIOServerCnxn c = (NIOServerCnxn) k.attachment();</span><br><span class="line">                     <span class="comment">// 处理IO操作</span></span><br><span class="line">                      c.doIO(k);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                          LOG.debug(<span class="string">&quot;Unexpected ops in select &quot;</span></span><br><span class="line">                                    + k.readyOps());</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              selected.clear();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">              LOG.warn(<span class="string">&quot;Ignoring unexpected runtime exception&quot;</span>, e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              LOG.warn(<span class="string">&quot;Ignoring exception&quot;</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      closeAll();</span><br><span class="line">      LOG.info(<span class="string">&quot;NIOServerCnxn factory exited run method&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="NIOServerCnxn-doIO"><a href="#NIOServerCnxn-doIO" class="headerlink" title="NIOServerCnxn.doIO"></a>NIOServerCnxn.doIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIO</span><span class="params">(SelectionKey k)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (isSocketOpen() == <span class="keyword">false</span>) &#123;</span><br><span class="line">               LOG.warn(<span class="string">&quot;trying to do i/o on a null socket for session:0x&quot;</span></span><br><span class="line">                        + Long.toHexString(sessionId));</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 处理读请求, 表示接受</span></span><br><span class="line">           <span class="keyword">if</span> (k.isReadable()) &#123;</span><br><span class="line">               <span class="keyword">int</span> rc = sock.read(incomingBuffer);</span><br><span class="line">               <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</span><br><span class="line">                           <span class="string">&quot;Unable to read additional data from client sessionid 0x&quot;</span></span><br><span class="line">                           + Long.toHexString(sessionId)</span><br><span class="line">                           + <span class="string">&quot;, likely client has closed socket&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (incomingBuffer.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> isPayload;</span><br><span class="line">                   <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123; <span class="comment">// start of next request</span></span><br><span class="line">                       incomingBuffer.flip();</span><br><span class="line">                       isPayload = readLength(k);</span><br><span class="line">                       incomingBuffer.clear();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// continuation</span></span><br><span class="line">                       isPayload = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (isPayload) &#123; <span class="comment">// not the case for 4letterword</span></span><br><span class="line">                       readPayload();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// four letter words take care</span></span><br><span class="line">                       <span class="comment">// need not do anything else</span></span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (k.isWritable()) &#123;</span><br><span class="line">               <span class="comment">// ZooLog.logTraceMessage(LOG,</span></span><br><span class="line">               <span class="comment">// ZooLog.CLIENT_DATA_PACKET_TRACE_MASK</span></span><br><span class="line">               <span class="comment">// &quot;outgoingBuffers.size() = &quot; +</span></span><br><span class="line">               <span class="comment">// outgoingBuffers.size());</span></span><br><span class="line">               <span class="keyword">if</span> (outgoingBuffers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// ZooLog.logTraceMessage(LOG,</span></span><br><span class="line">                   <span class="comment">// ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,</span></span><br><span class="line">                   <span class="comment">// &quot;sk &quot; + k + &quot; is valid: &quot; +</span></span><br><span class="line">                   <span class="comment">// k.isValid());</span></span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * This is going to reset the buffer position to 0 and the</span></span><br><span class="line"><span class="comment">                    * limit to the size of the buffer, so that we can fill it</span></span><br><span class="line"><span class="comment">                    * with data from the non-direct buffers that we need to</span></span><br><span class="line"><span class="comment">                    * send.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   ByteBuffer directBuffer = factory.directBuffer;</span><br><span class="line">                   directBuffer.clear();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (ByteBuffer b : outgoingBuffers) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (directBuffer.remaining() &lt; b.remaining()) &#123;</span><br><span class="line">                           <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            * When we call put later, if the directBuffer is to</span></span><br><span class="line"><span class="comment">                            * small to hold everything, nothing will be copied,</span></span><br><span class="line"><span class="comment">                            * so we&#x27;ve got to slice the buffer if it&#x27;s too big.</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                           b = (ByteBuffer) b.slice().limit(</span><br><span class="line">                                   directBuffer.remaining());</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * put() is going to modify the positions of both</span></span><br><span class="line"><span class="comment">                        * buffers, put we don&#x27;t want to change the position of</span></span><br><span class="line"><span class="comment">                        * the source buffers (we&#x27;ll do that after the send, if</span></span><br><span class="line"><span class="comment">                        * needed), so we save and reset the position after the</span></span><br><span class="line"><span class="comment">                        * copy</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">int</span> p = b.position();</span><br><span class="line">                       directBuffer.put(b);</span><br><span class="line">                       b.position(p);</span><br><span class="line">                       <span class="keyword">if</span> (directBuffer.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Do the flip: limit becomes position, position gets set to</span></span><br><span class="line"><span class="comment">                    * 0. This sets us up for the write.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   directBuffer.flip();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">int</span> sent = sock.write(directBuffer);</span><br><span class="line">                   ByteBuffer bb;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Remove the buffers that we have sent</span></span><br><span class="line">                   <span class="keyword">while</span> (outgoingBuffers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       bb = outgoingBuffers.peek();</span><br><span class="line">                       <span class="keyword">if</span> (bb == ServerCnxnFactory.closeConn) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> CloseRequestException(<span class="string">&quot;close requested&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">int</span> left = bb.remaining() - sent;</span><br><span class="line">                       <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            * We only partially sent this buffer, so we update</span></span><br><span class="line"><span class="comment">                            * the position and exit the loop.</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                           bb.position(bb.position() + sent);</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       packetSent();</span><br><span class="line">                       <span class="comment">/* We&#x27;ve sent the whole buffer, so drop the buffer */</span></span><br><span class="line">                       sent -= bb.remaining();</span><br><span class="line">                       outgoingBuffers.remove();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// ZooLog.logTraceMessage(LOG,</span></span><br><span class="line">                   <span class="comment">// ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, &quot;after send,</span></span><br><span class="line">                   <span class="comment">// outgoingBuffers.size() = &quot; + outgoingBuffers.size());</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">synchronized</span>(<span class="keyword">this</span>.factory)&#123;</span><br><span class="line">                   <span class="keyword">if</span> (outgoingBuffers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!initialized</span><br><span class="line">                               &amp;&amp; (sk.interestOps() &amp; SelectionKey.OP_READ) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> CloseRequestException(<span class="string">&quot;responded to info probe&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       sk.interestOps(sk.interestOps()</span><br><span class="line">                               &amp; (~SelectionKey.OP_WRITE));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       sk.interestOps(sk.interestOps()</span><br><span class="line">                               | SelectionKey.OP_WRITE);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;CancelledKeyException causing close of session 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(sessionId));</span><br><span class="line">           <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">               LOG.debug(<span class="string">&quot;CancelledKeyException stack trace&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CloseRequestException e) &#123;</span><br><span class="line">           <span class="comment">// expecting close to log session closure</span></span><br><span class="line">           close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (EndOfStreamException e) &#123;</span><br><span class="line">           LOG.warn(e.getMessage());</span><br><span class="line">           <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">               LOG.debug(<span class="string">&quot;EndOfStreamException stack trace&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// expecting close to log session closure</span></span><br><span class="line">           close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           LOG.warn(<span class="string">&quot;Exception causing close of session 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(sessionId) + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">           <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">               LOG.debug(<span class="string">&quot;IOException stack trace&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="NIOServerCnxn-readRequest"><a href="#NIOServerCnxn-readRequest" class="headerlink" title="NIOServerCnxn.readRequest"></a>NIOServerCnxn.readRequest</h4><p>读取客户端的请求, 进行具体的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkServer.processPacket(<span class="keyword">this</span>, incomingBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ZookeeperServer-processPacket"><a href="#ZookeeperServer-processPacket" class="headerlink" title="ZookeeperServer.processPacket"></a>ZookeeperServer.processPacket</h4><p>这个方法根据数据包的类型来处理不同的数据包，对于读写请求, 我们主要关注下面这块代码即可. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  最终进入这个代码块进行处理</span></span><br><span class="line">               <span class="comment">// 封装请求对象</span></span><br><span class="line">               Request si = <span class="keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">                 h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">               si.setOwner(ServerCnxn.me);</span><br><span class="line">               submitRequest(si);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;zookeeper原理之watcher源码分析&quot;&gt;&lt;a href=&quot;#zookeeper原理之watcher源码分析&quot; class=&quot;headerlink&quot; title=&quot;zookeeper原理之watcher源码分析&quot;&gt;&lt;/a&gt;zookeeper原理之watcher源码分析&lt;/h1&gt;&lt;h2 id=&quot;watcher-的基本流程&quot;&gt;&lt;a href=&quot;#watcher-的基本流程&quot; class=&quot;headerlink&quot; title=&quot;watcher 的基本流程&quot;&gt;&lt;/a&gt;watcher 的基本流程&lt;/h2&gt;&lt;p&gt;zookeeper 的watcher 机制, 总的来说分为三个过程: 客户端注册watcher、服务端处理watcher和客户端回调watcher . &lt;/p&gt;
&lt;h2 id=&quot;基于zk客户端发起一个数据操作&quot;&gt;&lt;a href=&quot;#基于zk客户端发起一个数据操作&quot; class=&quot;headerlink&quot; title=&quot;基于zk客户端发起一个数据操作&quot;&gt;&lt;/a&gt;基于zk客户端发起一个数据操作&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, KeeperException, InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ZooKeeper zooKeeper = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ZooKeeper(&lt;span class=&quot;string&quot;&gt;&amp;quot;192.168.9.22:2181&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;number&quot;&gt;4000&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Watcher() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(WatchedEvent watchedEvent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;event.type:&amp;quot;&lt;/span&gt; + watchedEvent.getType());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       String path = &lt;span class=&quot;string&quot;&gt;&amp;quot;/watcher&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//  创建节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       zooKeeper.create(path, &lt;span class=&quot;string&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//  注册监听&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       zooKeeper.exists(path, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;// 修改节点的值触发监听&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       zooKeeper.setData(path, &lt;span class=&quot;string&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;.getBytes(), -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       System.in.read();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/zookeeper%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>http://luyanan.com/zookeeper%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2021-03-01T09:46:52.899Z</published>
    <updated>2020-12-24T09:34:50.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper-核心原理"><a href="#zookeeper-核心原理" class="headerlink" title="zookeeper 核心原理"></a>zookeeper 核心原理</h1><h2 id="Zookeeper-数据的同步流程"><a href="#Zookeeper-数据的同步流程" class="headerlink" title="Zookeeper 数据的同步流程"></a>Zookeeper 数据的同步流程</h2><p>我们知道, zookeeper 是通过三种不同的集群角色来组成整个高性能集群的, 在zookeeper 中, 客户端会随机连接到 zookeeper 集群中的一个节点, 如果是读请求, 就直接从当前节点中读取数据, 如果是写请求, 那么请求会被转发给leader 提交事务. 然后leader 会传播事务, 只要有超过半数的节点写入成功, 那么写请求就会被提交.(类似于2PC 事务).</p><p><img src="http://files.luyanan.com//img/20191112135730.png"></p><blockquote><p>那么问题来了? </p><ol><li>集群中的leader 节点是如何选举出来的? </li><li>leader  节点崩溃后, 整个集群无法处理写请求, 如何快速的从其他节点中选举出新的leader 呢? </li><li>leader节点和各个follower 节点的数据一致性如何保证. </li></ol></blockquote><h3 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h3><p>ZAB(Zookeeper Atomic Broadcase) 协议是为分布式协调服务Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议. 在Zookeeper中, 主要依赖ZAB 协议来实现分布式数据一致性, 基于该协议, zookee实现了一种主备协议的系统架构来保持集群中各个副本之间的数据一致性. </p><h4 id="ZAB-协议介绍"><a href="#ZAB-协议介绍" class="headerlink" title="ZAB 协议介绍"></a>ZAB 协议介绍</h4><p>ZAB 协议包含两种基本模式: 包括:</p><ol><li>崩溃恢复</li><li>原子广播</li></ol><p>当整个集群在启动时,或者当leader节点出现网络中断、崩溃等情况时, ZAB协议会进入恢复模式并选举产生新的Leader, 当leader 服务器选举出来后, 并且集群中由过半的机器和该leader 节点完成数据同步后(同步指的是数据同步, 用来保证集群中过半的机器能够和leader服务器的数据状态保持一致),ZAB 协议就会退出恢复模式. 当集群中已经有过半的Follower 节点完成了和leader 节点状态同步以后, 那么整个集群模式就进去了消息广播模式. 这个时候, 在leader 节点正常工作时, 启动一台新的服务器加入到集群, 那这个服务器会直接进入数据恢复模式,和leader节点进行数据同步. 同步完成后即可正常对外提供非事务请求的处理 .</p><blockquote><p> 需要注意的是: leader 节点可以处理事务请求和非事务请求, follower 节点只能处理非事务请求, 如果follower节点接收到事务请求, 就会把这个请求转发到  leader 节点 .</p></blockquote><h4 id="消息广播的实现原理"><a href="#消息广播的实现原理" class="headerlink" title="消息广播的实现原理"></a>消息广播的实现原理</h4><p>消息广播其实就是一个简化版本的二节点提交过程。 </p><ol><li>leader 接收到消息请求后, 将消息赋予一个全局唯一的64位自增id, 叫zxid, 通过zxid 的大小比较可以实现因果有序这个特征. </li><li>leader 为每个follower准备了一个FIFO 队列(通过TCP协议来实现, 以实现了全局有序这个特点)将带有zxid 的消息作为一个提案(proposal) 分发给所有的follower</li><li>当follower 接受到 proposal , 先把 proposal  写到磁盘, 写入成功以后再想leader 回复一个ack</li><li>当leader 接收到合法数量(超过半数节点)的ACK后, leader 就会向这些follower发送 commit  命令, 同时也会在本地执行该消息. </li><li>当follower 收到消息的commit 命令后, 会提交该消息. </li></ol><p><img src="http://files.luyanan.com//img/20191112153026.png"></p><blockquote><p>和完整的2pc事务不一样的地方在于, zab 协议不能终止事务, follower节点要么ACK 给leader, 要么抛弃leader, 只需要保证过半的节点响应了这个消息并提交了即可.虽然在某一个时刻 follower节点和leader 节点的状态会不一致, 但是这个特性提升了集群的整体性能. 当然这种数据不一致的问题, zab协议提供了一种恢复模式来进行数据恢复. </p></blockquote><p>这里需要注意的: </p><p>leader 的投票过程,不需要Observer 的ack,也就是Observer 不需要参与投票过程, 但是Observer 必须要同步Leader 的数据从而在处理请求的时候保证数据的一致性. </p><h4 id="崩溃恢复的实现原理"><a href="#崩溃恢复的实现原理" class="headerlink" title="崩溃恢复的实现原理"></a>崩溃恢复的实现原理</h4><p>我们知道 ZAB 协议是基于原子广播协议的消息广播过程, 在正常情况下是没有任何问题的, 但是一旦leader 节点崩溃或者由于网络问题导致Leader 服务器事务了过半的follower 的节点的联系()leader 失去与过半的follower节点联系, 可能是leader 节点和follower节点之间产生了网络分区, 那么此时的leader 已经不再是合法的leader了),那么就会进入到崩溃恢复模式. 崩溃恢复模式下ZAB协议需要做两件事情:</p><ol><li>选举出新的leader</li><li>数据同步. </li></ol><p>我们知道, ZAB 协议的消息广播机制是简化版本的2PC协议, 这种协议只需要集群中过半的节点响应提交即可. 但是它无法处理Leader 服务器崩溃带来的数据不一致问题, 因此在ZAB 协议中添加了一个”崩溃恢复模式” 来解决这个问题. </p><p>那么ZAB协议中的崩溃恢复需要保证, 如果一个事务Proposal 在一台机器上被处理成功, 哪怕是出现故障, 为了达到这个目的, 我们先来设想一下, 在zookeeper 中会有哪些场景导致数据不一致性, 以及针对这个场景, zab协议中的崩溃恢复应该怎么处理. </p><h5 id="已经被处理的消息不能丢"><a href="#已经被处理的消息不能丢" class="headerlink" title="已经被处理的消息不能丢"></a>已经被处理的消息不能丢</h5><p>当leader 收到合法数量follower的ACK 后, 就向各个follower 广播 commit 命令, 同时也会在本地执行 commit 并向连接的客户端返回[成功]. 但是如果在各个 follower 在收到commit 命令前leader 就挂了, 导致剩下的服务器并没有执行这条消息. </p><p><img src="http://files.luyanan.com//img/20191112161319.png"></p><blockquote><p>图中是C2就是一个典型的例子, 在集群正常运行过程的某一个时刻, server1 是leader 服务器, 先后广播了消息P1、P2、C1、P3 和C2。 其中当leader 服务器把消息C2(commit 事务proposal2) 发出后就立即崩溃退出了, 那么针对这种情况, ZAB协议就需要确保事务Proposal2 最终能够在所有的服务器上都能被提交成功, 否则将会出现不一致. </p></blockquote><h5 id="被丢弃的下次不能再次出现"><a href="#被丢弃的下次不能再次出现" class="headerlink" title="被丢弃的下次不能再次出现"></a>被丢弃的下次不能再次出现</h5><p>当leader 接收到消息请求生成proposal 后就挂了, 其他follower 并没有收到此proposa,因此经过恢复模式重新选了leader 后, 这条消息是被跳过的. 之前挂了的leader 重新启动并注册成了follower, 它保留了被跳过消息的proposal状态, 与整个系统的状态是不一致的. 需要将其删除. </p><p>ZAB协议需要满足上面两种情况, 就必须设计一个leader 选举算法，能够确保已经被leader 提交的事务proposal 能够提交, 同时丢弃已经被跳过的事务Proposal.</p><p>针对这个要求:</p><ol><li>如果leader 选举算法能够保证新选举出来的leader 服务器拥有集群中所有寄去最高编号(zxid最大) 事务Proposal, 那么就可以保证这个新选举出来的leader 一定具有已经提交的提案. 因为所有提案被commit 之前必须有超过半数的follower  ACK,即必须有超过半数的节点的服务器的事务日志上有该提案的proposal. 因此, 只要有合法数量的节点正常工作, 就必然有一个节点保存了所有被Commit 消息的proposal 状态.</li><li> 另外一个, zxid 是64位, 高32位是epoch编号, 每经过一次leader 选举产生一个新的leader, 新的leader 会将epoch 号 +1, 低32位是 消息计数器, 每接收到一条消息这个值+1,新的leader 选举后这个值重置为0, 这样设计的好处在于老的leader 挂了以后重启, 它不会被选举为leader, 因此此时它的zxid 肯定小于当前新的leader.当老的leader 作为follower 接入新的leader 后, 新的leader 会让他将所有的拥有旧的epoch 号的未被 commit 的proposal 清除. </li></ol><h3 id="关于zxid"><a href="#关于zxid" class="headerlink" title="关于zxid"></a>关于zxid</h3><p>前面一直提到zxid, 也就是事物id, 那么这个id 具体起什么作用呢? 以及这个id 是如何生成的呢? 简单给大家解释一下, 为了保证事务的顺序一致性, zookeeper 采用了递增的事务id 号(zxid)来标识事务, 所有的提议(proposal)都在被提出的时候加上了zxid. 实现中zxid 是一个64位的数字, 它高32位是epoch(ZAB协议通过epoch 编号来区分leader 周期变化的策略)用来标识leader 关系是否改变, 每次一个leader 被选出来后, 它都会有一个新的epoch=（原来的epoch +1）,标识当前属于哪个leader 的统治时期. 低32 用于递增计数. </p><blockquote><p>epoch: 可以理解为当前集群所处的年代或者周期, 每个leader 就像皇帝, 都有自己的年号,所以每次改朝换代,leader 变更之后, 都会在前一个年代的基础上加上1. 这样就算旧的leader 崩溃恢复后, 也没人听她的了. 因为follower 只听从当前年代的leader 的命令. </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;zookeeper-核心原理&quot;&gt;&lt;a href=&quot;#zookeeper-核心原理&quot; class=&quot;headerlink&quot; title=&quot;zookeeper 核心原理&quot;&gt;&lt;/a&gt;zookeeper 核心原理&lt;/h1&gt;&lt;h2 id=&quot;Zookeeper-数据的同步流程&quot;&gt;&lt;a href=&quot;#Zookeeper-数据的同步流程&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper 数据的同步流程&quot;&gt;&lt;/a&gt;Zookeeper 数据的同步流程&lt;/h2&gt;&lt;p&gt;我们知道, zookeeper 是通过三种不同的集群角色来组成整个高性能集群的, 在zookeeper 中, 客户端会随机连接到 zookeeper 集群中的一个节点, 如果是读请求, 就直接从当前节点中读取数据, 如果是写请求, 那么请求会被转发给leader 提交事务. 然后leader 会传播事务, 只要有超过半数的节点写入成功, 那么写请求就会被提交.(类似于2PC 事务).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20191112135730.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么问题来了? &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集群中的leader 节点是如何选举出来的? &lt;/li&gt;
&lt;li&gt;leader  节点崩溃后, 整个集群无法处理写请求, 如何快速的从其他节点中选举出新的leader 呢? &lt;/li&gt;
&lt;li&gt;leader节点和各个follower 节点的数据一致性如何保证. &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/Sentinel%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://luyanan.com/Sentinel%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-03-01T09:46:52.890Z</published>
    <updated>2020-12-24T09:34:50.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sentinel的基本应用以及原理分析"><a href="#Sentinel的基本应用以及原理分析" class="headerlink" title="Sentinel的基本应用以及原理分析"></a>Sentinel的基本应用以及原理分析</h1><h2 id="限流的基本认识"><a href="#限流的基本认识" class="headerlink" title="限流的基本认识"></a>限流的基本认识</h2><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>一个互联网产品, 打算搞一次大促来增加销量以及曝光. 公司的架构师基于往期的流量情况做了一个活动流量的预估. 然后整个公司的各个技术团队开始按照这个目标进行设计和优化, 最终在大家的不懈努力下,达到了链路压测的目标流量峰值. 到了活动开始那天, 大家都盯着监控面板, 看着流量像洪水一样涌进来, 由于前期的宣传工作做得非常好, 使得这个流程远远超过预期的峰值, 后端服务开始不稳定, CPU、内存各种爆表. 部分服务开始出现无响应的情况. 最后, 整个系统开始崩溃, 用户无法正常访问服务, 最后导致公司巨大的损失. </p><h3 id="引入限流"><a href="#引入限流" class="headerlink" title="引入限流"></a>引入限流</h3><p>在10.1黄金周, 各大旅游景点都是人满为患, 所以有些景点为了避免出现踩踏事故, 会采取限流措施. </p><p>那在架构场景中, 是不是也能这样做呢? 针对这个场景, 能不能设置一个最大的流量限制, 如果超过这个流量, 我们就拒绝提供服务, 从而使得我们的服务不会挂掉. </p><p>当前, 限流虽然能够保证系统不被压垮, 但是对于被限流的用户来说, 就会很不开心. 所以限流其实是一种有损的解决方案, 但是相对于全部不可用, 有损服务是最好的一种解决方法. </p><h3 id="限流的作用"><a href="#限流的作用" class="headerlink" title="限流的作用"></a>限流的作用</h3><p>除了前面说的限流使用场景之外，限流的设置还能防止恶意请求流量、恶意攻击. </p><p>所以, 限流的基本原理是通过对并发访问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统, 一旦达到限制速率则可以拒绝服务(定向到错误页面或者告知资源没有了)、排队或等待(秒杀、下单)、降级(返回兜底数据或者默认数据,如商品详情库存默认有货). </p><p>一般互联网企业常见的限流有: 限制总并发数(如数据库连接池、线程池)、限制瞬间并发数(nginx的limit_conn模块、用来限制瞬间并发连接数)、限制时间窗口内的平均速率(如Guava 的RateLimiter、nginx的limit_req模块、限制每秒的平均速率);其他的还有限制远程接口调用速率、限制MQ的消费速率、另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流. </p><p>有了限流, 就意味着在处理高并发的时候多了一种保护机制, 不用担心瞬间流量导致系统挂掉或者雪崩, 最后做到有损服务而不是不服务, 但是限流需要做好评估, 不能乱用, 否则一些正常流量出现一些奇怪的问题而导致用户体验很差造成用户损失. </p><h2 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h2><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>发送和接收方都会维护一个数据帧的序列, 这个序列被称为窗口。发送方的窗口大小由接收方确定,目的在于控制发送速度, 以免接收方的缓存不够大, 而导致溢出. 同时控制流量也可以避免网络拥塞. 下面图中的4，5，6号数据帧已经被发送出去, 但是未收到关联的ACK， 7，8，9 帧则是等待发送. 可以看出发送端的窗口大小为6, 这时由接收端告知的. 此时如果发送端收到4号ACK， 则窗口的左边缘向右收缩, 窗口的右边缘则向右扩展, 此时窗口就向前滑动了, 则数据帧10 也可以被发送. </p><p><img src="http://files.luyanan.com//img/20191212160950.png"></p><h3 id="漏桶-控制传输速率Leaky-bucket"><a href="#漏桶-控制传输速率Leaky-bucket" class="headerlink" title="漏桶(控制传输速率Leaky bucket)"></a>漏桶(控制传输速率Leaky bucket)</h3><p>漏桶算法思路是: 不断的往桶里面注水, 无论注水的速度是大还是小, 水都是按照固定的速率往外漏水, 如果桶满了, 水会溢出. </p><p>桶本身具有一个恒定的速率往下漏水, 而上方时快时慢的会由水进入桶中,当桶还未满时, 上方的水可以加入. 一旦水满, 上方的水就无法加入. 桶满正是算法中的一个关键的触发条件(即流量异常判断成立的条件).而此条件下如何处理上方流下的水, 有两种方式: </p><p>在桶满水之后, 常见的两种处理方式:</p><ol><li>暂时拦截住上方水的向下流动, 等待桶中的一部分水漏走后, 再放行上方水. </li><li>溢出的上方水直接抛弃.</li></ol><p>特点： </p><ol><li>漏水的速率是固定的. </li><li>即使存在突然注水量变大的情况, 漏水的速率也是固定的. </li></ol><p><img src="http://files.luyanan.com//img/20191212161823.png"></p><h3 id="令牌桶-能够解决突发流量"><a href="#令牌桶-能够解决突发流量" class="headerlink" title="令牌桶(能够解决突发流量)"></a>令牌桶(能够解决突发流量)</h3><p>令牌桶算法是网络流量整形(Traffic Shaping) 和速率限制(Rate Limiting) 中最常用的一种算法. 典型情况下, 令牌桶算法用来控制发送到网络上的数据数目, 并允许突发数据的发送. </p><p>令牌桶是一个存放固定容量令牌(token)的桶, 按照固定速率往桶里添加令牌, 令牌桶算法实际上由三部分组成, 两个流和一个桶, 分别是令牌桶、数据流和令牌桶. </p><h4 id="令牌流和令牌桶"><a href="#令牌流和令牌桶" class="headerlink" title="令牌流和令牌桶"></a>令牌流和令牌桶</h4><p>系统会以一定的速度生成令牌, 并将其防止到令牌桶中, 可以将令牌桶想象成一个缓存区(可以用队列这种数据结构来实现), 当缓冲区填满的时候, 新生成的令牌会被扔掉, 这里有两个变量很重要. </p><p>第一个是生成令牌的速度, 一般成为 <code>rate</code>,  比如我们设定rate=2, 即每秒生成2个令牌，也就是每 1/2 秒生成一个令牌. </p><p>第二个是令牌桶的大小, 一般称为burst, 比如我们设定burst = 10, 即令牌桶最大只能容纳10个令牌. </p><p><img src="http://files.luyanan.com//img/20191212163617.png"></p><p>有三种情况可能发生: </p><ol><li><em>数据流的速率等于令牌流的速率</em>, 这种情况下每个到来的数据包或者请求都能对应一个令牌, 然后无延迟的通过队列. </li><li><strong>数据流的速率小于令牌桶的速率</strong>, 通过队列的数据包或者请求只消耗了一部分令牌, 剩下的令牌会在令牌桶中积累下来, 直到桶被装满, 剩下的令牌可以在突发请求的时候消耗掉. </li><li><strong>数据流的速率大于令牌流的速率</strong> , 这意味着桶里的令牌很快就被耗尽, 导致服务中断一段时间, 如果数据包或者请求持久到来, 将发生丢包或者拒绝响应. </li></ol><h2 id="使用Sentinel-实现限流"><a href="#使用Sentinel-实现限流" class="headerlink" title="使用Sentinel 实现限流"></a>使用Sentinel 实现限流</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>sentinel 是Alibaba 开源的一个面向分布式服务架构的轻量级流量控制组件,主要以流量为切入点, 从限流、流量整型、熔断降级、系统负载保存等多个维度来保证微服务的稳定性. </p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>我们先再pom.xml 中添加sentinel 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/13</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String resource = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;初始化限流规则&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowRules</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        FlowRule flowRule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">        <span class="comment">// 资源(方法名称/接口)</span></span><br><span class="line">        flowRule.setResource(resource);</span><br><span class="line">        <span class="comment">// 限流的阈值类型  qps和线程数</span></span><br><span class="line">        flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        <span class="comment">// 设置数量</span></span><br><span class="line">        flowRule.setCount(<span class="number">1000</span>);</span><br><span class="line">        rules.add(flowRule);</span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化规则</span></span><br><span class="line">        initFlowRules();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Entry entry = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                entry = SphU.entry(resource);</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">                <span class="comment">// 如果被限流, 则会抛出异常</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 释放</span></span><br><span class="line">                    entry.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的代码, 我们就基本完成了一个单机版的限流</p><h3 id="接入控制台"><a href="#接入控制台" class="headerlink" title="接入控制台"></a>接入控制台</h3><h4 id="获取sentinel-控制台"><a href="#获取sentinel-控制台" class="headerlink" title="获取sentinel 控制台"></a>获取sentinel 控制台</h4><p>从release页面获取最新版本的控制台jar包</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>使用如下命令启动控制台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>-Dserver.port=8080</code> 用于指定 Sentinel 控制台端口为 <code>8080</code>。</p><p>从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的<strong>登录</strong>功能，默认用户名和密码都是 <code>sentinel</code></p><h4 id="客户端接入控制台"><a href="#客户端接入控制台" class="headerlink" title="客户端接入控制台"></a>客户端接入控制台</h4><p>控制台启动后, 客户端需要按照以下步骤接入到控制台</p><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-配置启动参数"><a href="#2-配置启动参数" class="headerlink" title="2. 配置启动参数"></a>2. 配置启动参数</h4><p>启动时加入 JVM 参数 <code>-Dcsp.sentinel.dashboard.server=consoleIp:port</code> 指定控制台地址和端口。若启动多个应用，则需要通过 <code>-Dcsp.sentinel.api.port=xxxx</code> 指定客户端监控 API 的端口（默认是 8719）</p><h4 id="3-然后就可以访问-localhost-8080-查看访问控制台了"><a href="#3-然后就可以访问-localhost-8080-查看访问控制台了" class="headerlink" title="3. 然后就可以访问 localhost:8080 查看访问控制台了"></a>3. 然后就可以访问 <code>localhost:8080</code> 查看访问控制台了</h4><h3 id="使用注解实现限流"><a href="#使用注解实现限流" class="headerlink" title="使用注解实现限流"></a>使用注解实现限流</h3><p>Sentinel 支持通过 <code>@SentinelResource</code> 注解定义资源并配置 <code>blockHandler</code> 和 <code>fallback</code> 函数来进行限流之后的处理。示例：</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写配置类和加载规则"><a href="#编写配置类和加载规则" class="headerlink" title="编写配置类和加载规则"></a>编写配置类和加载规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SentinelResourceAspect <span class="title">sentinelResourceAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initFlowRules();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SentinelResourceAspect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;初始化规则&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFlowRules</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;FlowRule&gt; ruleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        FlowRule flowRule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">        <span class="comment">// 资源的地址</span></span><br><span class="line">        flowRule.setResource(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 限流的类型</span></span><br><span class="line">        flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        flowRule.setCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        ruleList.add(flowRule);</span><br><span class="line">        FlowRuleManager.loadRules(ruleList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="编写测试的方法"><a href="#编写测试的方法" class="headerlink" title="编写测试的方法"></a>编写测试的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;hello&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="规则的种类"><a href="#规则的种类" class="headerlink" title="规则的种类"></a>规则的种类</h2><p>Sentinel 的所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。同时 Sentinel 也提供相关 API，供您来定制自己的规则策略。</p><p>Sentinel 支持以下几种规则：<strong>流量控制规则</strong>、<strong>熔断降级规则</strong>、<strong>系统保护规则</strong>、<strong>来源访问控制规则</strong> 和 <strong>热点参数规则</strong>。</p><h3 id="流量控制规则-FlowRule"><a href="#流量控制规则-FlowRule" class="headerlink" title="流量控制规则 (FlowRule)"></a>流量控制规则 (FlowRule)</h3><h4 id="流量规则的定义"><a href="#流量规则的定义" class="headerlink" title="流量规则的定义"></a>流量规则的定义</h4><p>重要属性：</p><table><thead><tr><th>Field</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，资源名是限流规则的作用对象</td><td></td></tr><tr><td>count</td><td>限流阈值</td><td></td></tr><tr><td>grade</td><td>限流阈值类型，QPS 模式（1）或并发线程数模式（0）</td><td>QPS 模式</td></tr><tr><td>limitApp</td><td>流控针对的调用来源</td><td><code>default</code>，代表不区分调用来源</td></tr><tr><td>strategy</td><td>调用关系限流策略：直接、链路、关联</td><td>根据资源本身（直接）</td></tr><tr><td>controlBehavior</td><td>流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流</td><td>直接拒绝</td></tr></tbody></table><p>同一个资源可以同时有多个限流规则，检查规则时会依次检查。</p><h4 id="通过代码定义流量控制规则"><a href="#通过代码定义流量控制规则" class="headerlink" title="通过代码定义流量控制规则"></a>通过代码定义流量控制规则</h4><p>理解上面规则的定义之后，我们可以通过调用 <code>FlowRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFlowQpsRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    FlowRule rule = <span class="keyword">new</span> FlowRule(resourceName);</span><br><span class="line">    <span class="comment">// set limit qps to 20</span></span><br><span class="line">    rule.setCount(<span class="number">20</span>);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule.setLimitApp(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry= SphU.entry(resource); </span><br></pre></td></tr></table></figure><p>进入到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title">entry</span><span class="params">(String name)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Env.sph.entry(name, EntryType.OUT, <span class="number">1</span>, OBJECTS0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Env-sph"><a href="#Env-sph" class="headerlink" title="Env.sph"></a>Env.sph</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Env</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sph sph = <span class="keyword">new</span> CtSph();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// If init fails, the process will exit.</span></span><br><span class="line">        InitExecutor.doInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们发现有一个静态块</p><h3 id="InitExecutor-doInit"><a href="#InitExecutor-doInit" class="headerlink" title="InitExecutor.doInit();"></a>InitExecutor.doInit();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!initialized.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ServiceLoader&lt;InitFunc&gt; loader = ServiceLoader.load(InitFunc.class);</span><br><span class="line">           List&lt;OrderWrapper&gt; initList = <span class="keyword">new</span> ArrayList&lt;OrderWrapper&gt;();</span><br><span class="line">           <span class="keyword">for</span> (InitFunc initFunc : loader) &#123;</span><br><span class="line">               RecordLog.info(<span class="string">&quot;[InitExecutor] Found init func: &quot;</span> + initFunc.getClass().getCanonicalName());</span><br><span class="line">               insertSorted(initList, initFunc);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (OrderWrapper w : initList) &#123;</span><br><span class="line">               w.func.init();</span><br><span class="line">               RecordLog.info(String.format(<span class="string">&quot;[InitExecutor] Executing %s with order %d&quot;</span>,</span><br><span class="line">                   w.func.getClass().getCanonicalName(), w.order));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">           RecordLog.warn(<span class="string">&quot;[InitExecutor] WARN: Initialization failed&quot;</span>, ex);</span><br><span class="line">           ex.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Error error) &#123;</span><br><span class="line">           RecordLog.warn(<span class="string">&quot;[InitExecutor] ERROR: Initialization failed with fatal error&quot;</span>, error);</span><br><span class="line">           error.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们发现, 这里通过SPI 机制加载<code>InitFunc</code> 的实现类, 然后分别调用他们的 <code>init</code> 方法. </p><h3 id="Env-sph-entry"><a href="#Env-sph-entry" class="headerlink" title="Env.sph.entry"></a>Env.sph.entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(String name, EntryType type, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">      StringResourceWrapper resource = <span class="keyword">new</span> StringResourceWrapper(name, type);</span><br><span class="line">      <span class="keyword">return</span> entry(resource, count, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里通过name 和type  包装一个<code>StringResourceWrapper</code>, 即抽象的资源. </p><h3 id="CtSph-entry"><a href="#CtSph-entry" class="headerlink" title="CtSph.entry"></a>CtSph.entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> entryWithPriority(resourceWrapper, count, <span class="keyword">false</span>, args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="entryWithPriority"><a href="#entryWithPriority" class="headerlink" title="entryWithPriority"></a>entryWithPriority</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">entryWithPriority</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">        Context context = ContextUtil.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">            <span class="comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span></span><br><span class="line">            <span class="comment">// so here init the entry only. No rule checking will be done.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Using default context.</span></span><br><span class="line">            context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Global switch is close, no rule checking will do.</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.ON) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span></span><br><span class="line"><span class="comment">         * so no rule checking will be done.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry e = <span class="keyword">new</span> CtEntry(resourceWrapper, chain, context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.entry(context, resourceWrapper, <span class="keyword">null</span>, count, prioritized, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">            e.exit(count, args);</span><br><span class="line">            <span class="keyword">throw</span> e1;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">            <span class="comment">// This should not happen, unless there are errors existing in Sentinel internal.</span></span><br><span class="line">            RecordLog.info(<span class="string">&quot;Sentinel unexpected exception&quot;</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="InternalContextUtil-internalEnter"><a href="#InternalContextUtil-internalEnter" class="headerlink" title="InternalContextUtil.internalEnter"></a>InternalContextUtil.internalEnter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalContextUtil</span> <span class="keyword">extends</span> <span class="title">ContextUtil</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> Context <span class="title">internalEnter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> trueEnter(name, <span class="string">&quot;&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> Context <span class="title">internalEnter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> trueEnter(name, origin);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="trueEnter"><a href="#trueEnter" class="headerlink" title="trueEnter"></a>trueEnter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Context <span class="title">trueEnter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">        Context context = contextHolder.get();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Map&lt;String, DefaultNode&gt; localCacheNameMap = contextNameNodeMap;</span><br><span class="line">            DefaultNode node = localCacheNameMap.get(name);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localCacheNameMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;</span><br><span class="line">                    setNullContext();</span><br><span class="line">                    <span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.lock();</span><br><span class="line">                        node = contextNameNodeMap.get(name);</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (contextNameNodeMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;</span><br><span class="line">                                setNullContext();</span><br><span class="line">                                <span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                node = <span class="keyword">new</span> EntranceNode(<span class="keyword">new</span> StringResourceWrapper(name, EntryType.IN), <span class="keyword">null</span>);</span><br><span class="line">                                <span class="comment">// Add entrance node.</span></span><br><span class="line">                                Constants.ROOT.addChild(node);</span><br><span class="line"></span><br><span class="line">                                Map&lt;String, DefaultNode&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(contextNameNodeMap.size() + <span class="number">1</span>);</span><br><span class="line">                                newMap.putAll(contextNameNodeMap);</span><br><span class="line">                                newMap.put(name, node);</span><br><span class="line">                                contextNameNodeMap = newMap;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        LOCK.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            context = <span class="keyword">new</span> Context(node, name);</span><br><span class="line">            context.setOrigin(origin);</span><br><span class="line">            contextHolder.set(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="lookProcessChain"><a href="#lookProcessChain" class="headerlink" title="lookProcessChain"></a>lookProcessChain</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessorSlot&lt;Object&gt; <span class="title">lookProcessChain</span><span class="params">(ResourceWrapper resourceWrapper)</span> </span>&#123;</span><br><span class="line">        ProcessorSlotChain chain = chainMap.get(resourceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                chain = chainMap.get(resourceWrapper);</span><br><span class="line">                <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Entry size limit.</span></span><br><span class="line">                    <span class="keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    chain = SlotChainProvider.newSlotChain();</span><br><span class="line">                    Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="keyword">new</span> HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(</span><br><span class="line">                        chainMap.size() + <span class="number">1</span>);</span><br><span class="line">                    newMap.putAll(chainMap);</span><br><span class="line">                    newMap.put(resourceWrapper, chain);</span><br><span class="line">                    chainMap = newMap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="chain-SlotChainProvider-newSlotChain-构建一个Chanin"><a href="#chain-SlotChainProvider-newSlotChain-构建一个Chanin" class="headerlink" title="chain = SlotChainProvider.newSlotChain(); 构建一个Chanin"></a>chain = SlotChainProvider.newSlotChain(); 构建一个Chanin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessorSlotChain <span class="title">newSlotChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resolveSlotChainBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RecordLog.warn(<span class="string">&quot;[SlotChainProvider] Wrong state when resolving slot chain builder, using default&quot;</span>);</span><br><span class="line">            builder = <span class="keyword">new</span> DefaultSlotChainBuilder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="new-DefaultSlotChainBuilder"><a href="#new-DefaultSlotChainBuilder" class="headerlink" title="new DefaultSlotChainBuilder()"></a>new DefaultSlotChainBuilder()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSlotChainBuilder</span> <span class="keyword">implements</span> <span class="title">SlotChainBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSlotChainBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line">        <span class="keyword">return</span> chain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即最后的调用顺序如下： NodeSelectorSlot =&gt; ClusterBuilderSlot =&gt; LogSlot =&gt; StatisticSlot =&gt; AuthoritySlot =&gt; SystemSlot =&gt; FlowSlot =&gt; DegradeSlot<br> 如果想改变他们的调用顺序，可通过SPI机制实现</p><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><p>构造调用链，具体参考 <a href="https://links.jianshu.com/go?to=https://github.com/all4you/sentinel-tutorial/blob/master/sentinel-principle/sentinel-slot-chain/sentinel-slot-chain.md">NodeSelectorSlot</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">public <span class="keyword">void</span> entry(Context context, ResourceWrapper resourceWrapper, <span class="built_in">Object</span> obj, <span class="built_in">int</span> count, boolean prioritized, <span class="built_in">Object</span>... args)</span><br><span class="line">    throws Throwable &#123;</span><br><span class="line">    <span class="comment">// 每个资源对应一个 ProcessorSlotChain</span></span><br><span class="line">    <span class="comment">// 一个资源可以对应多个Context</span></span><br><span class="line">    <span class="comment">// 一个ContextName 对应一个 DefaultNode , 即 一个资源可能对应多个 DefaultNode, 但 一个资源只有一个 ClusterNode</span></span><br><span class="line">    <span class="comment">// 针对同一段代码，不同线程对应的Context实例是不一样的，但是对应的Context Name是一样的，所以这时认为是同一个Context，Context我们用Name区分</span></span><br><span class="line">    DefaultNode node = map.<span class="keyword">get</span>(context.getName());</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            node = map.<span class="keyword">get</span>(context.getName());</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = <span class="keyword">new</span> DefaultNode(resourceWrapper, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// key 为 ontextName , vaue 为 DefaultNode</span></span><br><span class="line">                HashMap&lt;<span class="built_in">String</span>, DefaultNode&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, DefaultNode&gt;(map.size());</span><br><span class="line">                cacheMap.putAll(map);</span><br><span class="line">                cacheMap.put(context.getName(), node);</span><br><span class="line">                map = cacheMap;</span><br><span class="line">                <span class="comment">// Build invocation tree</span></span><br><span class="line">                ((DefaultNode) context.getLastNode()).addChild(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    context.setCurNode(node);</span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><p>具体参考 <a href="https://links.jianshu.com/go?to=https://github.com/all4you/sentinel-tutorial/blob/master/sentinel-principle/sentinel-slot-chain/sentinel-slot-chain.md">ClusterBuilderSlot</a></p><p>每个资源对应一个ClusterNode，并且DefaultNode引用了ClusterNode</p><h3 id="LogSlot"><a href="#LogSlot" class="headerlink" title="LogSlot"></a>LogSlot</h3><p>记录日志用的，先执行下面的 Solt， 如果报错了或者被Block了，记录到日志中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fireEntry(context, resourceWrapper, obj, count, prioritized, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        EagleEyeLogUtil.log(resourceWrapper.getName(), e.getClass().getSimpleName(), e.getRuleLimitApp(),</span><br><span class="line">            context.getOrigin(), count);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        RecordLog.warn(<span class="string">&quot;Unexpected entry exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><p>核心实现，各种计数的实现逻辑，基于时间窗口实现。 基于触发请求通过 和 请求Block 的回调逻辑，回调逻辑在 MetricCallbackInit 中初始化了， 最终还是靠 StatisticSlotCallbackRegistry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了一些代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行下来的Solt ，判断是否通过</span></span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Request passed, add thread count and pass count.</span></span><br><span class="line">        node.increaseThreadNum();</span><br><span class="line">        node.addPassRequest(count);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        <span class="comment">// Blocked, set block exception to current entry.</span></span><br><span class="line">        context.getCurEntry().setError(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add block count.</span></span><br><span class="line">        node.increaseBlockQps(count);</span><br><span class="line">        <span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            context.getCurEntry().getOriginNode().increaseBlockQps(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultNode 继承自 StatisticNode , 在 StatisticNode 中有两个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数表示 窗口的个数；第二个参数表示 窗口对多长时间进行统计  比如 QPS xx/秒   那就是 1000 毫秒， 所以窗口的长度为  1000/个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口长度为1000 60个 刚好一分钟</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>ArrayMetric 持有 LeapArray ， LeapArray 主要有两个实现类 OccupiableBucketLeapArray 、 BucketLeapArray ， 但根据当前时间获取窗口的核心实现在 LeapArray 抽象类中</p><p>滑动窗口简单理解就是： 根据任何时间，都可以获取一个对应的窗口，在该窗口内，保存着在窗口长度时间内通过的请求数、被block的请求数、异常数、RT。基于这些数据，我们就可以得到对应的资源的QPS、RT等指标信息。</p><p>核心方法在 LeapArray#currentWindow ， 整体思路如下</p><ol><li>根据当前时间获取时间窗口的下标  (time/windowLength) % array.length()</li><li>计算当前时间对应时间窗口的开始时间  time - time % windowLength</li><li>根据下标获取时间窗口，这里分三种情况：<br> (1) 根据下标没有获取到窗口，此时创建一个窗口。此时代表窗口没有创建 或者 窗口还没有开始滑动， 所以对应的下标位置为null<br> (2) 根据下标获取到窗口，并且该窗口的开始时间和上面计算的开始时间一样，此时直接返回该窗口<br> (3) 根据下标获取到窗口，但是该窗口的开始时间大于上面计算的开始时间，这时需要用计算的开始时间重置该窗口的开始时间，这就类似于窗口在滑动</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span>(<span class="params"><span class="built_in">long</span> timeMillis</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算窗口数组下标</span></span><br><span class="line">    <span class="built_in">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">    <span class="comment">// 计算开始时间</span></span><br><span class="line">    <span class="built_in">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        WindowWrap&lt;T&gt; old = array.<span class="keyword">get</span>(idx);</span><br><span class="line">        <span class="keyword">if</span> (old == <span class="literal">null</span>) &#123;</span><br><span class="line">            WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">            <span class="keyword">if</span> (array.compareAndSet(idx, <span class="literal">null</span>, window)) &#123;</span><br><span class="line">                <span class="comment">// Successfully updated, return the created bucket.</span></span><br><span class="line">                <span class="keyword">return</span> window;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//  循环重试 Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Successfully get the update lock, now we reset the bucket.</span></span><br><span class="line">                    <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// Should not go through here, as the provided time is already behind.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>todo OccupiableBucketLeapArray 还不太理解</p><h3 id="AuthoritySlot"><a href="#AuthoritySlot" class="headerlink" title="AuthoritySlot"></a>AuthoritySlot</h3><p>黑白名单规则校验，非常简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    checkBlackWhiteAuthority(resourceWrapper, context);</span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加载所有的黑白名单规则</li><li>遍历所有黑白名单规则，调用 AuthorityRuleChecker#passCheck 方法，如果不通过则抛出 AuthorityException</li><li>校验逻辑：从 Context 中拿到 originName, 然后判断 originName 是否在 规则的 limitApp 中, 然后判断是 黑名单 还是白名单，然后校验返回结果</li></ol><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>仅对入口流量有效，校验顺序 QPS -&gt; 线程数 -&gt; RT -&gt; BBR -&gt; CPU</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    SystemRuleManager.checkSystem(resourceWrapper);</span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>限流处理</p><p>三种拒绝策略：直接拒绝、WarnUP、匀速排队</p><p>三种限流模式：直接、关联、链路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class="line"></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlowRuleChecker#checkFlow</p><ol><li>获取所有限流规则</li><li>遍历规则，执行 FlowRuleChecker#canPassCheck =&gt; FlowRuleChecker#passLocalCheck =&gt; rule.getRater().canPass(selectedNode, acquireCount, prioritized)</li><li>rule.getRater() 返回一个 TrafficShapingController 对象， 它有3种实现(代码中有4中，但官方文档只介绍了3种)，即对应上面的三种流控模式，每个规则对用的 TrafficShapingController 是在加载规则的时候就确定了</li></ol><p>// FlowRuleUtil#generateRater</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TrafficShapingController <span class="title">generateRater</span><span class="params">(<span class="comment">/*@Valid*/</span> FlowRule rule)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rule.getGrade() == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rule.getControlBehavior()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_WARM_UP:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WarmUpController(rule.getCount(), rule.getWarmUpPeriodSec(),</span><br><span class="line">                    ColdFactorProperty.coldFactor);</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RateLimiterController(rule.getMaxQueueingTimeMs(), rule.getCount());</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WarmUpRateLimiterController(rule.getCount(), rule.getWarmUpPeriodSec(),</span><br><span class="line">                    rule.getMaxQueueingTimeMs(), ColdFactorProperty.coldFactor);</span><br><span class="line">            <span class="keyword">case</span> RuleConstant.CONTROL_BEHAVIOR_DEFAULT:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Default mode or unknown mode: default traffic shaping controller (fast-reject).</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultController(rule.getCount(), rule.getGrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DefaultController"><a href="#DefaultController" class="headerlink" title="DefaultController"></a>DefaultController</h5><p>比较简单，判断逻辑 (当前的Count + 本次调用) 是否大于 规则中设置的 阈值</p><h5 id="WarmUpController"><a href="#WarmUpController" class="headerlink" title="WarmUpController"></a>WarmUpController</h5><p>让QPS在指定的时间内增加到 阈值， 目前每太看懂</p><h5 id="RateLimiterController"><a href="#RateLimiterController" class="headerlink" title="RateLimiterController"></a>RateLimiterController</h5><p>也比较简单，先按规则中配置的QPS计算每个请求的平均响应时间，然后判断当前请求是否能够等那么久(规则中的时间窗口)</p><h5 id="三种限流模式在哪里体现？"><a href="#三种限流模式在哪里体现？" class="headerlink" title="三种限流模式在哪里体现？"></a>三种限流模式在哪里体现？</h5><p>其实这个主要就是判断 你的指标数据应该要从哪个 Node 中获取，这部分逻辑在 FlowRuleChecker#selectNodeByRequesterAndStrategy 方法中</p><ol><li>直接： 根据你的 originName 和 limitApp 来判断是取 ClusterNode 还是 OriginNode</li><li>关联： 根据关联的资源名取对应的 ClusterNode</li><li>链路： 判断关联的资源 和 当前的 contextName 是否一致，是则返回 当前的 DefaultNode</li></ol><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>降级处理</p><p>目前有三种降级模式：基于RT、基于异常比例、基于一分钟异常数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基于RT"><a href="#基于RT" class="headerlink" title="基于RT"></a>基于RT</h5><p>从时间窗口获取RT和规则中配置的阈值进行比较， 通过则 重置计数，然后直接返回； 不通过则 计数加1，如果 计数 &gt;= 5，则进行降级处理</p><h5 id="基于异常比例"><a href="#基于异常比例" class="headerlink" title="基于异常比例"></a>基于异常比例</h5><p>前提条件 QPS &gt; =5 , 然后用 1s异常数/1s总请求数 , 和规则中配置的阈值进行比较</p><h5 id="基于1分钟异常数"><a href="#基于1分钟异常数" class="headerlink" title="基于1分钟异常数"></a>基于1分钟异常数</h5><p>直接用1分钟内的异常数和规则的阈值做比较</p><h5 id="如何按时间窗口降级"><a href="#如何按时间窗口降级" class="headerlink" title="如何按时间窗口降级"></a>如何按时间窗口降级</h5><p>定时任务 + flag<br> 如果降级了， 设置 flag = true , 在 时间窗口秒后， 重置 flag = false ，然后再 passCheck 方法的入口处， 如果 flag = true 就直接降级</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Sentinel的基本应用以及原理分析&quot;&gt;&lt;a href=&quot;#Sentinel的基本应用以及原理分析&quot; class=&quot;headerlink&quot; title=&quot;Sentinel的基本应用以及原理分析&quot;&gt;&lt;/a&gt;Sentinel的基本应用以及原理分析&lt;/h1&gt;&lt;h2 id=&quot;限流的基本认识&quot;&gt;&lt;a href=&quot;#限流的基本认识&quot; class=&quot;headerlink&quot; title=&quot;限流的基本认识&quot;&gt;&lt;/a&gt;限流的基本认识&lt;/h2&gt;&lt;h3 id=&quot;场景分析&quot;&gt;&lt;a href=&quot;#场景分析&quot; class=&quot;headerlink&quot; title=&quot;场景分析&quot;&gt;&lt;/a&gt;场景分析&lt;/h3&gt;&lt;p&gt;一个互联网产品, 打算搞一次大促来增加销量以及曝光. 公司的架构师基于往期的流量情况做了一个活动流量的预估. 然后整个公司的各个技术团队开始按照这个目标进行设计和优化, 最终在大家的不懈努力下,达到了链路压测的目标流量峰值. 到了活动开始那天, 大家都盯着监控面板, 看着流量像洪水一样涌进来, 由于前期的宣传工作做得非常好, 使得这个流程远远超过预期的峰值, 后端服务开始不稳定, CPU、内存各种爆表. 部分服务开始出现无响应的情况. 最后, 整个系统开始崩溃, 用户无法正常访问服务, 最后导致公司巨大的损失. &lt;/p&gt;
&lt;h3 id=&quot;引入限流&quot;&gt;&lt;a href=&quot;#引入限流&quot; class=&quot;headerlink&quot; title=&quot;引入限流&quot;&gt;&lt;/a&gt;引入限流&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/Sentinel%20%E6%95%B4%E5%90%88Dubbo%E9%99%90%E6%B5%81%E5%AE%9E%E6%88%98/"/>
    <id>http://luyanan.com/Sentinel%20%E6%95%B4%E5%90%88Dubbo%E9%99%90%E6%B5%81%E5%AE%9E%E6%88%98/</id>
    <published>2021-03-01T09:46:52.879Z</published>
    <updated>2020-12-24T09:34:50.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sentinel-整合Dubbo限流实战"><a href="#Sentinel-整合Dubbo限流实战" class="headerlink" title="Sentinel 整合Dubbo限流实战"></a>Sentinel 整合Dubbo限流实战</h1><h2 id="创建生产者项目"><a href="#创建生产者项目" class="headerlink" title="创建生产者项目"></a>创建生产者项目</h2><p>这里需要提供一个对外的api项目和一个Dubbo服务</p><p><img src="http://files.luyanan.com//img/20191216215503.png"></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sentinel<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-dubbo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     </span><br></pre></td></tr></table></figure><h3 id="api服务"><a href="#api服务" class="headerlink" title="api服务"></a>api服务</h3><p>在api项目中创建接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SentinelService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生产者服务"><a href="#生产者服务" class="headerlink" title="生产者服务"></a>生产者服务</h3><p>接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelServiceImpl</span>  <span class="keyword">implements</span>  <span class="title">SentinelService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello :&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dubbo 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan(&quot;com.sentinel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationConfig config = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        config.setName(<span class="string">&quot;sentinel-provider&quot;</span>);</span><br><span class="line">        config.setOwner(<span class="string">&quot;luyanan&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig config = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        config.setAddress(<span class="string">&quot;zookeeper:192.168.9.106:2181&quot;</span>);</span><br><span class="line">        config.setCheck(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolConfig config = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        config.setPort(<span class="number">20880</span>);</span><br><span class="line">        config.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelDubboProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfig.class);</span><br><span class="line">        ((AnnotationConfigApplicationContext) applicationContext).start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消费者项目"><a href="#消费者项目" class="headerlink" title="消费者项目"></a>消费者项目</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sentinel<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-dubbo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyaHelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> SentinelService sentinelService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;say&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = sentinelService.sayello(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加配置信息"><a href="#添加配置信息" class="headerlink" title="添加配置信息"></a>添加配置信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dubbo.scan.base-packages=com.sentinel</span><br><span class="line">dubbo.application.name=sentinel-constumer</span><br><span class="line">dubbo.registry.address=zookeeper:<span class="comment">//192.168.9.106:2181</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置限流的基准"><a href="#设置限流的基准" class="headerlink" title="设置限流的基准"></a>设置限流的基准</h3><p><code>sentinel-provider</code>  用于向外界提供服务, 处理各个消费者的调用请求, 为了保护 <code>provider</code> 不被激增的流量拖垮影响稳定性, 可以向 <code>provider</code> 配置 QPS 模式的限流. 这样当每秒的请求量超过设置的阈值时会超过自动拒绝多的请求. 限流粒度可以是服务接口和服务方法两个粒度 . 若希望整个服务接口的QPS 不超过一定数值, 则可以为对应服务接口资源(resourceName 为接口全限定名) 配置QPS 阈值, 若希望服务的某个方法的QPS 不超过一定数值, 则可以为对应服务方法资源(resourceName 为接口全限定名:方法签名) 配置QPS 阈值. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelDubboProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfig.class);</span><br><span class="line">        ((AnnotationConfigApplicationContext) applicationContext).start();</span><br><span class="line">        initFlowerRule();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowerRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;FlowRule&gt; ruleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        FlowRule flowRule = <span class="keyword">new</span> FlowRule();</span><br><span class="line"></span><br><span class="line">        flowRule.setResource(<span class="string">&quot;com.sentinel.SentinelService:sayello(java.lang.String)&quot;</span>);</span><br><span class="line">        flowRule.setCount(<span class="number">10</span>); <span class="comment">// 限定阈值</span></span><br><span class="line">        flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);<span class="comment">//  限定阈值类型(QPS/并发线程数)</span></span><br><span class="line">        flowRule.setLimitApp(<span class="string">&quot;default&quot;</span>);<span class="comment">// 流针对的调用来源, 若为default则不区分来源</span></span><br><span class="line">        <span class="comment">//流量控制手段（直接拒绝、Warm Up、匀速排队）</span></span><br><span class="line">        flowRule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);</span><br><span class="line"></span><br><span class="line">        ruleList.add(flowRule);</span><br><span class="line">        FlowRuleManager.loadRules(ruleList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动时加入 JVM 参数 -Dcsp.sentinel.dashboard.server=localhost:8080 指定控制台地址和端口</p><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><h3 id="LimitApp"><a href="#LimitApp" class="headerlink" title="LimitApp"></a>LimitApp</h3><p>很多场景下, 根据调用方来限流也是非常重要的,比如有两个服务A 和B   都向 <code>service provider</code> 发起调用请求, 我们希望只对于来着服务 B 的请求进行限流, 则可以设置限流规则的 <code>limitpp</code> 为服务B 的名称. <code>Sentinel Dubbo Adapter</code> 会自动解析 Dubbo消费者(调用方) 的 <code>application name</code> 作为调用方名称(origin), 在进行资源保护的时候都会带上调用方的名称. 若限流规则未配置调用方(default),  则该限流规则对所有调用方生效。 若限流规则配置了调用方,则限流规则仅对指定调用方生效. </p><blockquote><p>注：Dubbo 默认通信不携带对端<code>application name</code> 信息, 因此需要开发者在调用端手动的将 <code>application anme</code> 置入 <code>attachement</code> 中, provider 再进行响应的解析. <code>sentinel Dubbo Adapter</code> 实现了一个Filter Adapter,  如果根据调用端限流, 可以在调用端手动将 <code>application name</code> 置入到 <code>attachement</code> 中, key为 dubboApplication`. </p></blockquote><p>​            </p><h4 id="演示流程"><a href="#演示流程" class="headerlink" title="演示流程"></a>演示流程</h4><ol><li><p>修改 <code>provider</code> 中限流规则:  <code>flowRule.setLimitApp(&quot;springboot-study&quot;);</code></p></li><li><p>在 consumer 工程中, 做如下处理, 其中一个通过 <code>attachment</code> 传递了一个消费者的<code>application name</code>,另外一个没有传, 通过 jemeter 工具进行测试. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/say&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">RpcContext.getContext().setAttachment(<span class="string">&quot;dubboApplication&quot;</span>,<span class="string">&quot;springbootstudy&quot;</span>);</span><br><span class="line">String result=sentinelService.sayHello(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/say2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say2Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">String result=sentinelService.sayHello(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="ControlBehavior"><a href="#ControlBehavior" class="headerlink" title="ControlBehavior"></a>ControlBehavior</h3><p>当QPS 超过某个阈值后, 则采取措施进行流量控制. 流量控制的手段包括以下几种: 直接拒绝、Warm up、匀速排队. 对应FlowRule 中的<code>controlBehavior</code> 字段</p><h4 id="直接拒绝（RuleConstant-CONTROL-BEHAVIOR-DEFAULT）"><a href="#直接拒绝（RuleConstant-CONTROL-BEHAVIOR-DEFAULT）" class="headerlink" title="直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）"></a>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）</h4><p>直接拒绝方式是默认的流量控制方式, 当QPS 超过任意规则的阈值后, 新的请求会被立即拒绝. 拒绝方式为抛出<code>FlowException</code>. 这种方式适用于对系统处理能力确切已知的情况下, 比如通过压测确定了系统的准确水位时. </p><h4 id="Warm-Up（RuleConstant-CONTROL-BEHAVIOR-WARM-UP）"><a href="#Warm-Up（RuleConstant-CONTROL-BEHAVIOR-WARM-UP）" class="headerlink" title="Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）"></a>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）</h4><p>Warm Up方式,即预热/冷启动方式, 当系统长期处于低并发的情况下, 流量突然增加到QPS的最高峰值, 可能会造成系统的瞬间流量过大把系统压垮. 所以<code>Warm Up</code> ,相当于处理请求的数量是缓慢增加的, 经过一段时间后,到达系统处理请求个数的最大值. </p><h4 id="匀速排队（RuleConstant-CONTROL-BEHAVIOR-RATE-LIMITER）"><a href="#匀速排队（RuleConstant-CONTROL-BEHAVIOR-RATE-LIMITER）" class="headerlink" title="匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）"></a>匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）</h4><p>匀速排队方式会严格控制请求通过的间隔时间, 也即是让请求以均匀的速度通过, 对应的是漏桶算法. </p><p>它的原理是: 以固定的时间间隔让请求通过, 当请求过来的时候, 如果当前请求距离上个通过的请求通过的时间间隔不小于预设值, 则让当前请求通过. 否则, 计算当前请求的预期通过时间, 如果该i请求的预期通过时间小于规则预设的 <code>timeout</code> 时间 ， 则该请求会等待直到预设时间来通过. 反之, 则马上抛出阻塞异常. </p><p>可以设置一个最长排队等待时间:  flowRule.setMaxQueueingTimeMs(5 * 1000); // 最长排队等待时 间：5s</p><p>这种方式主要用于处理间隔性突发的流量, 假如消息队列, 想象一下这样的场景, 在某一秒有大量的请求到来, 而接下来的几秒则处于空闲状态, 我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒就直接拒绝多余的请求. </p><h2 id="如何实现分布式限流"><a href="#如何实现分布式限流" class="headerlink" title="如何实现分布式限流"></a>如何实现分布式限流</h2><p>在前面的案例中,我们只是基于<code>sentinel</code>的基本使用和单机限流的使用, 假设有这样一个场景, 我们现在把<code>provider</code> 部署了10个集群, 希望调用这个服务器的api 的总的QPS 是100, 意味着每一台集群的QPS 是10, 理想情况下总的QPS 就是100, 但是实际上由于负载均衡的流量分发并不是非常均匀, 就会导致总的QPS 不足100时就会被限了. 在这个场景中, 仅仅依靠单机来实现总的流量的控制是有问题的, 所以最好的能实现集群限流. </p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>要想使用集群流控功能, 我们需要在应用端配置动态规则源, 并通过 <code>sentinel</code>控制台进行推送, 如下图所示:</p><p><img src="http://files.luyanan.com//img/20191220135530.png"></p><h3 id="搭建token-server"><a href="#搭建token-server" class="headerlink" title="搭建token-server"></a>搭建token-server</h3><p><img src="http://files.luyanan.com//img/20191220151145.png"></p><h4 id="添加jar依赖"><a href="#添加jar依赖" class="headerlink" title="添加jar依赖"></a>添加jar依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-cluster-server-default<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="编写启动类TokenClusterServer"><a href="#编写启动类TokenClusterServer" class="headerlink" title="编写启动类TokenClusterServer"></a>编写启动类TokenClusterServer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenClusterServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClusterTokenServer tokenServer = <span class="keyword">new</span> SentinelDefaultTokenServer();</span><br><span class="line">        ClusterServerConfigManager.loadGlobalTransportConfig(<span class="keyword">new</span> ServerTransportConfig()</span><br><span class="line">                .setIdleSeconds(<span class="number">600</span>)</span><br><span class="line">                .setPort(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line">        ClusterServerConfigManager.loadServerNamespaceSet(Collections.singleton(<span class="string">&quot;App&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tokenServer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DataSourceInitFunc"><a href="#DataSourceInitFunc" class="headerlink" title="DataSourceInitFunc"></a>DataSourceInitFunc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceInitFunc</span> <span class="keyword">implements</span> <span class="title">InitFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;nacos 的远程服务host&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String remoteAddr = <span class="string">&quot;192.168.86.128&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;nacos groupId&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String groupId = <span class="string">&quot;SENTINEL_GROUP&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;namespace 不同, 限流规则不同&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLOW_POSTFIX = <span class="string">&quot;-flow-rules&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClusterFlowRuleManager.setPropertySupplier(namespace -&gt; &#123;</span><br><span class="line">            ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; dataSource =</span><br><span class="line">                    <span class="keyword">new</span> NacosDataSource&lt;List&lt;FlowRule&gt;&gt;(remoteAddr, groupId, namespace + FLOW_POSTFIX,</span><br><span class="line">                            s -&gt; JSON.parseObject(s, <span class="keyword">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                            &#125;));</span><br><span class="line">            <span class="keyword">return</span> dataSource.getProperty();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resources-目录添加扩展点"><a href="#resources-目录添加扩展点" class="headerlink" title="resources 目录添加扩展点"></a>resources 目录添加扩展点</h4><p>/META-INF/services/com.alibaba.csp.sentinel.init.InitFunc = 自定义扩展点</p><blockquote><p> com.sentinel.token.DataSourceInitFunc</p></blockquote><h4 id="启动Sentinel-dashboard"><a href="#启动Sentinel-dashboard" class="headerlink" title="启动Sentinel dashboard"></a>启动Sentinel dashboard</h4><blockquote><p>java -Dserver.port=8081 -Dcsp.sentinel.dashboard.server=localhost:8080 - Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.6.3.jar</p></blockquote><h4 id="启动nacos-并增加配置"><a href="#启动nacos-并增加配置" class="headerlink" title="启动nacos 并增加配置"></a>启动nacos 并增加配置</h4><ol><li><p>启动nacos 服务 </p><blockquote><p>nohup sh startup.sh -m standalone &amp;</p></blockquote></li><li><p>增加限流配置</p><p> <img src="http://files.luyanan.com//img/20191220152626.png"></p></li></ol><h4 id="配置JVM参数"><a href="#配置JVM参数" class="headerlink" title="配置JVM参数"></a>配置JVM参数</h4><p>配置如下JVM参数, 连接到 <code>sentinel dashboard</code>, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Dproject.name=App -Dcsp.sentinel.dashboard.server=192.168.86.128:8081 -</span><br><span class="line">Dcsp.sentinel.log.use.pid=<span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>服务启动后, 在 <code>$user.home$/logs/csp/</code>  可以找到<code>sentinel-record.log.pid*.date</code> 文件, 如果看到日志文件中获取了远程服务的信息, 说明 <code>token-server</code> 启动成功了. </p></blockquote><h3 id="Dubbo-接入分布式限流"><a href="#Dubbo-接入分布式限流" class="headerlink" title="Dubbo 接入分布式限流"></a>Dubbo 接入分布式限流</h3><h4 id="jar依赖"><a href="#jar依赖" class="headerlink" title="jar依赖"></a>jar依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-dubbo-adapter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-cluster-client-default<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sentinel<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-dubbo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="增加扩展点"><a href="#增加扩展点" class="headerlink" title="增加扩展点"></a>增加扩展点</h4><p>扩展点需要在resources/META-INF/services/增加扩展的配置</p><blockquote><p>com.alibaba.csp.sentinel.init.InitFunc = 自定义扩展点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sentinel2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.cluster.client.ClientConstants;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.cluster.client.config.ClusterClientAssignConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.cluster.client.config.ClusterClientConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.cluster.client.config.ClusterClientConfigManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.ReadableDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.nacos.NacosDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.init.InitFunc;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.weaver.ast.Or;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceInitFunc</span> <span class="keyword">implements</span> <span class="title">InitFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;token server 的ip&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String CLUSTER_SERVER_HOST = <span class="string">&quot;192.168.86.128&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;token-server 的端口&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLUSTER_SERVER_PORT = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;请求超时时间&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_TIME_OUT = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String APP_NAME = <span class="string">&quot;APP&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;nacos 服务的ip&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String REOMOTE_ADDR = <span class="string">&quot;192.168.86.128&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;group id&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GROUP_ID = <span class="string">&quot;SENTINEL_GROUP&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;限流规则后缀&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/12/20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLOW_POSTFIX = <span class="string">&quot;-flow-rules&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        loadClusterClientConfig();</span><br><span class="line">        registerClusterFlowRuleProperty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册动态规则 Property,</span></span><br><span class="line"><span class="comment">     * 当Client与Server连接中断, 退化为本地限流时需要用到的规则</span></span><br><span class="line"><span class="comment">     * 该配置为必选项,客户端会从nacos 上加载限流规则, 请求tokenserver 的时候, 会带上要check 的规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClusterFlowRuleProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Nacos 数据源作为配置中心, 需要在REMOTE_ADDRSS 上启动一个Nacos 的服务</span></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ds = <span class="keyword">new</span></span><br><span class="line">                NacosDataSource&lt;List&lt;FlowRule&gt;&gt;(REOMOTE_ADDR, GROUP_ID, APP_NAME + FLOW_POSTFIX,</span><br><span class="line">                source -&gt; JSON.parseObject(source, <span class="keyword">new</span></span><br><span class="line">                        TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  为集群客户端注册动态规则源</span></span><br><span class="line">        FlowRuleManager.register2Property(ds.getProperty());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过硬编码的方式,配置连接到token-server 服务的地址，(这种在实际使用过程中不建议使用, 后续可以基于动态配置源改造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClusterClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClusterClientAssignConfig assignConfig = <span class="keyword">new</span> ClusterClientAssignConfig();</span><br><span class="line">        assignConfig.setServerHost(CLUSTER_SERVER_HOST);</span><br><span class="line">        assignConfig.setServerPort(CLUSTER_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">        ClusterClientConfigManager.applyNewAssignConfig(assignConfig);</span><br><span class="line">        ClusterClientConfig clientConfig = <span class="keyword">new</span> ClusterClientConfig();</span><br><span class="line">        clientConfig.setRequestTimeout(REQUEST_TIME_OUT); <span class="comment">//  token-client  请求token-server 获取令牌的时间</span></span><br><span class="line">        ClusterClientConfigManager.applyNewConfig(clientConfig);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置JVM参数-1"><a href="#配置JVM参数-1" class="headerlink" title="配置JVM参数"></a>配置JVM参数</h4><p>这里的project_name  要包含在 token-server 中配置的 namesapce</p><p>token-server 会根据客户端对应的namespace(默认为 project.name定义的应用名)下的连接数来计算总的阈值</p><blockquote><p>-Dproject.name=App -Dcsp.sentinel.dashboard.server=192.168.86.128:8081 - Dcsp.sentinel.log.use.pid=true</p></blockquote><blockquote><p>服务启动后, 在 <code>$user.home$/logs/csp/</code> 可以找到<code>sentinel-record.log.pid*.date</code> 文件, 如果看到日志文件中获取到了 token-server 的信息, 说明连接成功了 </p></blockquote><h4 id="演示集群限流"><a href="#演示集群限流" class="headerlink" title="演示集群限流"></a>演示集群限流</h4><p>所谓集群限流, 就是多个服务节点使用同一个限流规则, 从而对多个节点的总流量进行限制, 添加一个 sentinel-server , 同时运行两个程序. </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Sentinel-整合Dubbo限流实战&quot;&gt;&lt;a href=&quot;#Sentinel-整合Dubbo限流实战&quot; class=&quot;headerlink&quot; title=&quot;Sentinel 整合Dubbo限流实战&quot;&gt;&lt;/a&gt;Sentinel 整合Dubbo限流实战&lt;/h1&gt;&lt;h2 id=&quot;创建生产者项目&quot;&gt;&lt;a href=&quot;#创建生产者项目&quot; class=&quot;headerlink&quot; title=&quot;创建生产者项目&quot;&gt;&lt;/a&gt;创建生产者项目&lt;/h2&gt;&lt;p&gt;这里需要提供一个对外的api项目和一个Dubbo服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20191216215503.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; title=&quot;添加依赖&quot;&gt;&lt;/a&gt;添加依赖&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/RocketMQ%E9%97%AE%E9%A2%98/"/>
    <id>http://luyanan.com/RocketMQ%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-01T09:46:52.866Z</published>
    <updated>2020-12-24T09:34:50.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-问题"><a href="#RocketMQ-问题" class="headerlink" title="RocketMQ 问题"></a>RocketMQ 问题</h1><h2 id="rocketmq-连接异常-sendDefaultImpl-call-timeout"><a href="#rocketmq-连接异常-sendDefaultImpl-call-timeout" class="headerlink" title="rocketmq 连接异常 sendDefaultImpl call timeout"></a>rocketmq 连接异常 sendDefaultImpl call timeout</h2><p>需要将broker 的ip 换成本地的ip<br>在<code>conf/broker.conf</code> 里面加上 <code>brokerIP1=[本机ip]</code></p><p>然后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf autoCreateTopicEnable=<span class="literal">true</span> &amp;</span><br></pre></td></tr></table></figure><p>再运行程序, 就不在报错. </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RocketMQ-问题&quot;&gt;&lt;a href=&quot;#RocketMQ-问题&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ 问题&quot;&gt;&lt;/a&gt;RocketMQ 问题&lt;/h1&gt;&lt;h2 id=&quot;rocketmq-连接异常-sendDefaultImpl-call-timeout&quot;&gt;&lt;a href=&quot;#rocketmq-连接异常-sendDefaultImpl-call-timeout&quot; class=&quot;headerlink&quot; title=&quot;rocketmq 连接异常 sendDefaultImpl call timeout&quot;&gt;&lt;/a&gt;rocketmq 连接异常 sendDefaultImpl call timeout&lt;/h2&gt;&lt;p&gt;需要将broker 的ip 换成本地的ip&lt;br&gt;在&lt;code&gt;conf/broker.conf&lt;/code&gt; 里面加上 &lt;code&gt;brokerIP1=[本机ip]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后重启&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf autoCreateTopicEnable=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/RocketMQ%E4%BA%8B%E5%8A%A1%E6%80%A7%E6%B6%88%E6%81%AF/"/>
    <id>http://luyanan.com/RocketMQ%E4%BA%8B%E5%8A%A1%E6%80%A7%E6%B6%88%E6%81%AF/</id>
    <published>2021-03-01T09:46:52.859Z</published>
    <updated>2020-12-24T09:34:50.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ事务性消息"><a href="#RocketMQ事务性消息" class="headerlink" title="RocketMQ事务性消息"></a>RocketMQ事务性消息</h1><p>​    在现在的很多分布式集群环境中, 经常会遇到本地事务无法解决的问题, 所以会引进分布式事务. 所谓的分布式事务是指分布式架构中多个服务的节点的数据一致性. </p><h2 id="1-经典的X-OpenDTP事务模型"><a href="#1-经典的X-OpenDTP事务模型" class="headerlink" title="1. 经典的X/OpenDTP事务模型"></a>1. 经典的X/OpenDTP事务模型</h2><p>​    X/Open DTP(X/Open <code>Distributed Transaction Processing Reference Model</code>) 是X/Open 这个组织定义的一套分布式事务的标准， 也就是定义了规范和API接口,由各个厂商进行具体的实现. </p><p>​    这个标准提出了使用二阶段提交(2PC-<code> Two-Phase-Commit</code>) 来保证分布式事务的完整性.后来J2EE 也遵循了X/Open DTP 规范, 设计并使用了Java 的分布式事务编程接口规范-JTA</p><h3 id="1-1-X-Open-DTP-角色"><a href="#1-1-X-Open-DTP-角色" class="headerlink" title="1.1 X/Open DTP 角色"></a>1.1 <code>X/Open DTP</code> 角色</h3><p>在<code>X/Open DTP</code>事务模型中,定义了三个角色: </p><p><strong>AP:</strong> <code>application</code>,应用程序,也就是业务层,哪些操作属于同一个事务,就是<code>AP</code>定义的. </p><p><strong>RM</strong>: <code>Resource Manager</code>,资源管理器, 一般是数据库, 也可以是其他资源管理器, 比如消息队列. </p><p><strong>TM</strong>:<code>Transaction Manage</code>: 事务管理器、事务协调者,负责接收来自用户程序(<code>AP</code>)发起的XA事务指令,并调度和协调参与事务的所有<code>RM(S数据库)</code> , 确保事务正确完成. </p><p>​    在分布式系统中, 每一个机器节点虽然都能够明确知道自己在进行事务操作过程中的结果是成功还是失败, 但却无法直接获取到其他分布式节点的操作结果.因此, 当一个事务操作需要跨越多个分布式节点的时候, 为了保证事务处理的<code>ACID</code>特性, 就需要引入一个”协调者”(<code>TM</code>)来统一调度所有分布式节点的执行逻辑 , 这些被调度的分布式节点被称为<code>AP</code>.<code>TM</code>负责调度<code>AP</code>的行为, 并最终决定这些<code>AP</code> 是否要事务真正的进行提交到<code>RM</code>.</p><p>​    <code>XA</code>是<code>X/Open DTP</code> 定义的资源管理器和事务管理器之间的接口规范,<code>TM</code> 用它来通知和协调相关RM事务的开始、结束、提交和回滚.目前Oracle、Mysql、DR2 都提交了对<code>XA</code>的支持; <code>XA</code>接口是双向的系统接口, 在事务管理器(TM) 以及多个资源管理器之间形成通信的桥梁(XA不能自动提交).</p><p><img src="http://files.luyanan.com//img/20200115140700.png"></p><p><img src="http://files.luyanan.com//img/20200115140722.png"></p><h3 id="1-2-2PC"><a href="#1-2-2PC" class="headerlink" title="1.2    2PC"></a>1.2    2PC</h3><h4 id="1-2-1-第一阶段"><a href="#1-2-1-第一阶段" class="headerlink" title="1.2.1 第一阶段"></a>1.2.1 第一阶段</h4><p><img src="http://files.luyanan.com//img/20200115140836.png"></p><p>RM 在第一阶段会做两件事情: </p><ol><li>记录事务日志: reduo、undo</li><li>返回给TM 信息 : ok、error</li></ol><p>存在问题:如果第一阶段完成后TM宕机或者网络出现故障了,此时RM 就会一直阻塞,发生了死锁,因为没有 timeout机制,3PC就针对此问题进行了改造,加入了 timeout机制. </p><h4 id="1-2-2-第二阶段"><a href="#1-2-2-第二阶段" class="headerlink" title="1.2.2 第二阶段"></a>1.2.2 第二阶段</h4><p><img src="http://files.luyanan.com//img/20200115141134.png"></p><p>根据第一个阶段的返回结果进行提交或者回滚. </p><h3 id="1-3-CAP理论"><a href="#1-3-CAP理论" class="headerlink" title="1.3 CAP理论"></a>1.3 CAP理论</h3><p>CAP的含义是: </p><ul><li>C: <code>Consistency</code>一致性,同一个数据的多个副本是否实时相同. </li><li>A：<code>Availability</code>可用性, 可用性: 一定时间内 &amp; 系统返回一个明确的结果,则称之为该系统可用. </li><li>P：<code>Partition tolerance</code> 分区容错性,将同一服务分布在多个系统中, 从而保证某一个系统宕机, 让然有其他系统提供相同的服务. </li></ul><p>CAP 理论告诉我们, 在分布式系统中, C、A、P 三个条件中我们最多只能选择两个,那么问题来了,究竟选择哪两个条件较为合适呢? </p><p>​    对于一个业务系统来说, 可用性和分区容错性是必须满足的两个条件,并且这两个是相辅相成的. 业务系统之所以使用分布式系统, 主要原因有两个: </p><ul><li>提升系统性能, 当业务量猛增, 单个服务器已经无法满足我们的业务需求的时候, 就需要使用分布式系统,使用多个节点提供相同的功能, 从而整体上提升系统的性能,这就是使用分布式系统的第一个原因. </li><li>实现分区容错性, 单一节点或者多个节点处于相同的是网络环境下, 那么会存在一定的风险, 万一该机房断电、该地区发生自然灾害, 那么业务系统就全面瘫痪了.为了防止这一问题,采用分布式系统,将多个子系统分布在不同的地域、不同的机房, 从而保证了系统高可用. </li></ul><p>这说明分区容错性是分布式系统的根本, 如果分区容错性不能满足, 那使用分布式系统将失去意义. </p><p>​    此外,可用性对业务系统也尤为重要, 在大谈用户体验的今天,如果业务系统常出现”系统异常”、响应时间过程等情况, 这使得用户对系统的好感度大打折扣, 在互联网行业竞争激烈的今天,相同领域竞争者不甚枚举,系统的间歇性不可以会立马导致用户流向竞争对手。因此, 我们只能通用牺牲一致性来换取系统的<strong>可用性</strong>和<strong>分区容错</strong>. </p><h3 id="1-4-Base-理论"><a href="#1-4-Base-理论" class="headerlink" title="1.4 Base 理论"></a>1.4 Base 理论</h3><p>CAP理论告诉我们一个悲惨但不得不接受的事实– 我们只能在C、A、P 中选择两个条件, 而对于业务系统而言,我们往往选择牺牲一致性来换取系统的可用性和分区容错性. 不过要在这里指出的是, 所谓是”牺牲一致性”并不是完全放弃数据一致性, 而是牺牲”强一致性”换取”弱一致性”. </p><ul><li><p><code>BA:Basic Availabl </code> 基本可用</p><p> 整个系统在某些不可抗力的情况下, 让然能够保证”可用性”, 即一定时间内然然能返回一个明确的结果.只不过”基本可用”和”高可用”的区别是:</p><ul><li>“一定时间”可以适当延长,当举行大促时, 响应时间可以适当延长. </li><li>给部分用户返回一个降级页面, 给部分用户直接返回一个降级页面, 从而缓解服务器压力. 但要注意的是: 返回降级页面仍然是返回明确结果. </li></ul></li><li><p><code>S:Soft State</code>: 柔性状态,同一数据的不同副本的状态, 可以不需要实时一致. </p></li><li><p><code>E:Eventual Consisstency</code>: 最终一致性, 同一数据的不同副本状态, 可以不需要实时一致, 但一定要保证经过一段时间后仍然是一致的. </p></li></ul><h2 id="2-分布式事务常见解决方案"><a href="#2-分布式事务常见解决方案" class="headerlink" title="2. 分布式事务常见解决方案"></a>2. 分布式事务常见解决方案</h2><h3 id="2-1-最大努力通知方案"><a href="#2-1-最大努力通知方案" class="headerlink" title="2.1 最大努力通知方案"></a>2.1 最大努力通知方案</h3><p><img src="http://files.luyanan.com//img/20200115155523.png"></p><h3 id="2-2-TCC-两阶段补偿方案"><a href="#2-2-TCC-两阶段补偿方案" class="headerlink" title="2.2 TCC 两阶段补偿方案"></a>2.2 TCC 两阶段补偿方案</h3><p>TCC 是<code>Try-Confirm-Cance</code>, 比如在支付场景中,先冻结一部分资金,再去发起支付. 如果支付成功,则将冻结的资金进行实时扣除, 如果支付失败, 则取消资金冻结. </p><p>​    </p><p><img src="http://files.luyanan.com//img/20200115155726.png"></p><h4 id="2-2-1-Try阶段"><a href="#2-2-1-Try阶段" class="headerlink" title="2.2.1 Try阶段"></a>2.2.1 Try阶段</h4><p>完成所以业务检查(一致性),预留业务资源(准隔离性)</p><h4 id="2-2-2Confirm阶段"><a href="#2-2-2Confirm阶段" class="headerlink" title="2.2.2Confirm阶段"></a>2.2.2Confirm阶段</h4><p>确认执行业务操作, 不做任何业务检查, 只使用try 阶段预留的业务资源. </p><h4 id="2-2-3-Cancel阶段"><a href="#2-2-3-Cancel阶段" class="headerlink" title="2.2.3 Cancel阶段"></a>2.2.3 Cancel阶段</h4><p>取消try 阶段预留的业务资源, Try出现出现阶段时, 取消所有业务资源预留请求. </p><h3 id="2-3-关于状态机"><a href="#2-3-关于状态机" class="headerlink" title="2.3 关于状态机"></a>2.3 关于状态机</h3><p>在使用最终一致性的方案时, 一定要提到的一个概念就是状态机. </p><p>​    什么是状态机? 是一种特殊的组织代码的方式, 用这种方式能够确保你的对象随时都直到自己所处的状态以及能够做的操作。它也是一种用来进行对象行为建模的工具, 用于描述对象在他的生命周期内所经历的状态序列, 以及如何响应来自外界的各种事件. </p><p>​    状态机这个概念大家都不陌生, 比如TCP 协议的状态机. 同时我们在编写相关业务逻辑的时候经常也会需要处理各种事件和状态的切换, 比如swith、if/else . 所以我们其实一致都在跟状态机打交道,只是可能都没有意识到而已. 在处理一些业务逻辑比较复杂的需求的时候, 可以先看看是否适用于一个有限状态机来描述, 如果可以把业务模型抽象成一个有限的状态机, 那么代码就会逻辑非常清晰, 结构特别规整. </p><p>​    比如我们来简单描述一个订单. </p><p>​    我们以支付为例, 一笔订单可能会有等待支付、支付中、已支付状态, 那么我们就可以先去把可能出现的状态以及状态的流程画出来。 </p><p><img src="http://files.luyanan.com//img/20200115163617.png"></p><p>状态机的两个作用: </p><ul><li>实现幂等</li><li>通过状态驱动数据的变化</li><li>业务流程以及逻辑更加清晰, 特别是应对复杂的业务场景. </li></ul><h2 id="3-什么是幂等"><a href="#3-什么是幂等" class="headerlink" title="3. 什么是幂等"></a>3. 什么是幂等</h2><p>   简单来说, 重复调用多次产生的业务结果与调用一次产生的业务结果相同; 在分布式架构中, 我们调用一个远程服务去完成一个操作, 除了成功和我失败以外, 还有未知状态, 那么针对这个未知状态, 我们会采用一些重试的行为. 或者在消息中间件的使用场景中, 消费者可能会重复收到消息. 对于这两种情况, 消费端或者服务端需要采取一定的手段, 也就是考虑到重发的情况下保证数据的安全性.我们一般常用的手段： </p><ol><li>状态机实现幂等</li><li>数据库唯一约束实现幂等</li><li>通过<code>tokenId</code> 的方式去识别每次请求判断是否重复. </li></ol><h2 id="4-开源的分布式事务解决方案"><a href="#4-开源的分布式事务解决方案" class="headerlink" title="4. 开源的分布式事务解决方案"></a>4. 开源的分布式事务解决方案</h2><h3 id="4-1-TransactionProducer（事务消息）"><a href="#4-1-TransactionProducer（事务消息）" class="headerlink" title="4.1 TransactionProducer（事务消息）"></a>4.1 TransactionProducer（事务消息）</h3><p>RocketMQ 和其他消息中间件最大的一个区别就是支持了事务消息, 这也是分布式事务中基于消息的最终一致性方案. </p><h3 id="4-2-RocketMQ-消息的事务架构设计"><a href="#4-2-RocketMQ-消息的事务架构设计" class="headerlink" title="4.2  RocketMQ 消息的事务架构设计"></a>4.2  RocketMQ 消息的事务架构设计</h3><ol><li>生产者执行本地事务, 修改订单支付状态, 并且提交事务</li><li>生产者发送事务消息到broker上, 消息发送到broker 上在没有确认之前, 消息对于<code>consumer</code> 是 不可见的状态. </li><li>生产者确认事务消息, 使得发送到broker上的事务消息对于消费者可见. </li><li>消费者获取到消息进行消费,消费完之后执行ack 进行确认. </li><li>这里可能会存在一个问题 , 生产者本地事务成功后,发送事务确认消息到broker 上失败了怎么办? 这个时候意味着消费者无法正常消费到这个消息, 所以RocketMQ 提供了消息回查机制, 如果事务消息一直处于中间状态,broker 会发起重试去查询broker 上这个事务的处理状态。一旦发送事务处理成功, 则把这条消息设置为可见. </li></ol><p><img src="http://files.luyanan.com//img/20200116094256.png"></p><h3 id="4-3-事务消息的实践"><a href="#4-3-事务消息的实践" class="headerlink" title="4.3 事务消息的实践"></a>4.3 事务消息的实践</h3><p>通过一个下单以后扣减库存的数据一致性场景来演示RocketMQ的分布式事务特性. </p><p>TransactionProducer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;事务生产者&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, UnsupportedEncodingException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;tx_producer_group&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.86.128:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//  自定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListenerLocal());</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            String orderId = UUID.randomUUID().toString();</span><br><span class="line">            String body = <span class="string">&quot;&#123;&#x27;operation&#x27;:&#x27;doOrder&#x27;,&#x27;orderId&#x27;:&#x27;&quot;</span> + orderId + <span class="string">&quot;&#x27;&#125;&quot;</span>;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;ex_topic&quot;</span>, <span class="string">&quot;TagA&quot;</span>, orderId, body.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            producer.sendMessageInTransaction(message, orderId + <span class="string">&quot;&amp;&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TransactionListenerLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.LocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerLocal</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Boolean&gt; results = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;执行本地事务&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> LocalTransactionState&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2020/1/16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行本地事务:&quot;</span> + o.toString());</span><br><span class="line">        String orderId = o.toString();</span><br><span class="line">        <span class="comment">//模拟插入数据库操作</span></span><br><span class="line">        <span class="keyword">boolean</span> rs = saveOrder(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个返回状态表示broker 这个事务消息是否被确认,允许给到consumer 进行消费</span></span><br><span class="line">        <span class="comment">// LocalTransactionState.ROLLBACK_MESSAGE 回滚</span></span><br><span class="line">        <span class="comment">// LocalTransactionState.UNKNOW 未知</span></span><br><span class="line">        <span class="keyword">return</span> rs ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">saveOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果订单取模等于0, 表示成功, 否则失败</span></span><br><span class="line">        <span class="keyword">boolean</span> success = Math.abs(orderId.hashCode()) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        results.put(orderId, success);</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        String orderId = messageExt.getKeys();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行事务执行状态的回查:orderId:&quot;</span> + orderId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> rs = Boolean.TRUE.equals(results.get(orderId));</span><br><span class="line">        System.out.println(<span class="string">&quot;回调：&quot;</span> + rs);</span><br><span class="line">        <span class="keyword">return</span> rs ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者</p><p>TransactionConsumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/16</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;事务 消费者&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;tx_consumer_group&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.86.128:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;ex_topic&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                list.stream().forEach(messageExt -&gt; &#123;</span><br><span class="line">                    String orderId = messageExt.getKeys();</span><br><span class="line">                    String body = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        body = <span class="keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到消息:&quot;</span> + body + <span class="string">&quot;-&gt;开始扣钱库存:&quot;</span> + orderId);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4-RocketMQ-事务消息的三种状态"><a href="#4-4-RocketMQ-事务消息的三种状态" class="headerlink" title="4.4  RocketMQ 事务消息的三种状态"></a>4.4  RocketMQ 事务消息的三种状态</h3><ol><li><code>ROLLBACK_MESSAGE</code>:  回滚事务</li><li><code>COMMIT_MESSAGE</code>: 提交事务</li><li><code>UNKNOW</code>: broker 会定时的回查producer 消息状态,知道彻底成功或者失败. </li></ol><p>当 <code>com.mq.TransactionListenerLocal#executeLocalTransaction</code> 方法返回<code>ROLLBACK_MESSAGE</code>的时候, 表示直接回滚事务, 当返回 <code>COMMIT_MESSAGE</code>的时候直接提交事务. </p><p>当返回<code>UNKNOW</code>的时候,broker 会在一段时间之后查<code>com.mq.TransactionListenerLocal#checkLocalTransaction</code>, 根据<code>com.mq.TransactionListenerLocal#checkLocalTransaction</code> 返回状态执行事务的操作(提交或者回滚)</p><p>​    如示例中,当返回<code>ROLLBACK_MESSAGE</code> 时消费者不会收到消息, 且不会调用回查函数, 当返回<code>COMMIT_MESSAGE</code> 时事务提交,消费者收到消息. 当返回<code>UNKNOW</code>的时候, 在一段时间之后调用回查函数, 并根据state 判断返回提交或者回滚状态,返回提交状态的消息将会被消费者消费, 所以此时消费者可以消费部分消息. </p><h2 id="5-消息的存储和发送"><a href="#5-消息的存储和发送" class="headerlink" title="5. 消息的存储和发送"></a>5. 消息的存储和发送</h2><p>​    由于分布式消息队列对于可靠性的要求比较高, 所以需要保证生产者将消息发送到broker 之后, 保证消息是不会丢失的,因此消息队列就少不了对于可靠性存储的要求. </p><h3 id="5-1-MQ消息存储选择"><a href="#5-1-MQ消息存储选择" class="headerlink" title="5.1 MQ消息存储选择"></a>5.1 MQ消息存储选择</h3><p>​    从主流的几种MQ 消息队列采用的存储方式来看, 主要会有几种: </p><ol><li>分布式KV存储, 比如使用ActiviteMQ中采用的LebelDB、Redis, 这种存储方式对于消息读写能力要求不高的情况下可以使用. </li><li>文件系统存储, 常见的比如 kafka、RocketMQ、RabbitMQ 都是采用消息刷盘到所部署的机器上的文件系统来做持久化, 这种方案适用于对于有高吞吐量要求的消息中间件, 因为消息刷盘是一种高效率、高可靠、高性能的持久化方式, 除非磁盘出现故障, 否则一般是不会出现无法持久化问题的. </li><li>关系型数据库,比如ActiviteMQ 可以采用Mysql 作为消息存储,关系型数据库在单表数量达到千万级的情况下IO性能会出现瓶颈, 所以ActiviteMQ 并不适用于高吞吐量的消息队列场景. </li></ol><h3 id="5-2-消息的存储结构"><a href="#5-2-消息的存储结构" class="headerlink" title="5.2 消息的存储结构"></a>5.2 消息的存储结构</h3><p>​    RocketMQ 就是采用文件系统的方式来存储消息, 消息的存储是由<code>ConsumeQueue</code>和<code>CommitLog</code> 配合完成的. <code>CommitLog</code> 是消息真正的物理存储文件。 <code>ConsumeQueue</code> 是消息的逻辑队列, 有点类似于数据库的索引文件, 里面存储的是指向<code>CommitLog</code>  文件中消息存储的地址. </p><p>​    每个Topic 下的每个<code>Message Queue</code>都会对应一个<code>ConsumerQueue</code> 文件,文件的地址是<code>$&#123;store_home&#125;/consumequeue/$&#123;topicNmae&#125;/$&#123;queueId&#125;/$&#123;filename&#125;,</code>, 默认路径是<code>/root/store</code>. 在rocketMQ的文件存储目录下, 可以看到这样一个结构的文件</p><p><img src="http://files.luyanan.com//img/20200116112604.png"></p><p>我们只需要关心<code>Commitlog</code>、<code>Consumerqueue</code>、<code>Index</code></p><h4 id="5-2-1-Commitlog"><a href="#5-2-1-Commitlog" class="headerlink" title="5.2.1 Commitlog"></a>5.2.1 Commitlog</h4><p><code>commitlog</code>是用来存放消息的物理文件, 每个broker 上的<code>commitlog</code>文件是当前机器上的所有<code>consumerqueue</code> 共享, 不做任何区分. </p><p>​    <code>commitlog</code>中的文件默认大小为1G，可以动态配置; 当一个文件写满以后, 会生成一个新的<code>commitlog</code>文件. 所有的topic 数据是顺序写入在<code>commitlog</code> 文件中的. </p><p>文件名的长度为20位, 左边补零, 剩余末起始偏移量,比如00000000000000000000 表示第一个文件， 文件大小为102410241024，当第一个文件写满之后，生 成第二个文件 000000000001073741824 表示第二个文件，起始偏移量为1073741824</p><p>00000000000000000000 表示第一个文件， 文件大小为102410241024，当第一个文件写满之后，生 成第二个文件 000000000001073741824 表示第二个文件，起始偏移量为1073741824</p><h4 id="5-2-2-consumeQueue"><a href="#5-2-2-consumeQueue" class="headerlink" title="5.2.2 consumeQueue"></a>5.2.2 consumeQueue</h4><p><code>consumeQueue</code> 表示消息 消费的逻辑队列, 这里面包含<code>messageQueue</code>在<code>commitlog</code> 中的真实物理地址偏移量ooffst,消息实体内容的大小和<code>Message Tag</code>的hash值。 对于实际物理存储来说, <code>consumerQueue</code> 对应每个topic 和<code>queueid</code>下的文件, 每个<code>consumerqueue</code>类型的文件也是有带大小的,每个文件默认大小为6000W字节,如果文件满了之后也会生成一个新的文件. </p><h4 id="5-2-3-IndexFile"><a href="#5-2-3-IndexFile" class="headerlink" title="5.2.3 IndexFile"></a>5.2.3 IndexFile</h4><p>​    索引文件, 如果一个消息包含key值的话 ,会使用<code>indexFile</code>存储消息索引.Index 索引文件提交了对<code>Commitlog</code> 进行数据检索, 提供了一种通过key 或者时间区间来查找<code>commitlog</code> 中的消息的方法. 在物理存储中, 文件名是以创建的时间戳命名的, 固定的单个<code>indexFile</code> 大小大概为400M,一个<code>indexFile</code> 可以保存2000W个索引. </p><h4 id="5-2-4-abort"><a href="#5-2-4-abort" class="headerlink" title="5.2.4 abort"></a>5.2.4 abort</h4><p>​    broker 就会在启动的时候创建一个名为abort的文件,并在<code>shutdown</code>的时候将其删除,用于标识进程是否正常退出,如果不是正常退出, 会在启动的时候做故障恢复. </p><h3 id="5-3-消息存储的消息结构"><a href="#5-3-消息存储的消息结构" class="headerlink" title="5.3 消息存储的消息结构"></a>5.3 消息存储的消息结构</h3><p> <img src="http://files.luyanan.com//img/20200116134637.png"></p><p>​    RrokerMQ 的消息存储采用的是混合型的存储结构, 也就是broker 单个实例下的所有队列公用一个日志数据文件<code>connitlog</code>. 这个是和kafka 的又一不同之处. </p><p>​    为什么不采用kafka 的设计, 针对不同的<code>partition</code>存储一个独立的物理文件呢? 这是因为在kafka的设计中, 一旦kafka 中Topic的的<code>partition</code>数量过多, 队列文件会过多, 那么会给磁盘的IO读写造成比较大的压力, 也就造成了性能瓶颈. 所以RocketMQ 进行了优化, 消息主题统一存储在<code>commitlog</code>中. </p><p>当然, 这种设计并不是银弹, 也是有他的优缺点: </p><p><strong>优点</strong>: 由于消息主题都是通过<code>commitlog</code> 进行读写, <code>comsumerQueue</code> 中只存储了很少的数据, 所以队列更加的轻量化, 对于磁盘的访问是串行化从而避免了磁盘的竞争. </p><p><strong>缺点</strong>: 消息写入磁盘虽然是基于顺序读写, 但是读的过程是随机的,读取一条消息会先读取<code>consumerQueue</code> , 在读<code>commitlog</code>, 会降低消息读的效率. </p><h3 id="5-4-消息发送到消息接收的整体流程"><a href="#5-4-消息发送到消息接收的整体流程" class="headerlink" title="5.4 消息发送到消息接收的整体流程"></a>5.4 消息发送到消息接收的整体流程</h3><ol><li><p>Producer 将消息发送到Broker 后, Broker 会采用同步或者异步的方式把消息写入到<code>commitlog</code>,RocketMQ 所有的消息都会存放在<code>commitlog</code>中, 为了保证消息存储不发生混乱, 对<code>commitlog</code> 写之前会加锁, 同时也可以使得消息能够被顺序写入到<code>commitlog</code>, 只要消息被持久化到磁盘文件<code>commitlog</code>,那么就可以保证producer 发送的消息不会丢失. </p><p><img src="http://files.luyanan.com//img/20200116135615.png"></p></li><li><p><code>commitlog</code>持久化后, 会把里面的消息<code>Dispatch</code>到对应的<code>consumer queue</code>上, <code>consumer queue</code> 相当于kafka 的<code>partition</code>, 是一个逻辑队列, 存储了这个queue 在<code>commitlog</code> 中的其实offset、log大小和MessageTag的hashCode. </p><p><img src="http://files.luyanan.com//img/20200116140325.png"></p></li><li><p>当消费者进行消息消费时,会先读取<code>consumerQueue</code>,逻辑消费队列<code>consumerQueue</code> 保存了指定topic 下的队列消息在<code>consumerLog</code> 中的起始物理偏移量offset、消息大小、和消息tag HashCode值. </p><p><img src="http://files.luyanan.com//img/20200116140504.png"></p></li><li><p>直接从<code>consumerqueue</code> 中读取消息是没有数据的, 真正的消息主题是在<code>consumerlog</code>中, 所以换需要从<code>consumerlog</code> 中读取消息. </p><p><img src="http://files.luyanan.com//img/20200116140934.png"></p></li></ol><h2 id="6-什么时候清理物理消息文件"><a href="#6-什么时候清理物理消息文件" class="headerlink" title="6. 什么时候清理物理消息文件"></a>6. 什么时候清理物理消息文件</h2><p>那消息文件到底删不删? 什么时候删除呢? </p><p>​    消息存储在<code>commitlog</code>之后, 的确是会被清理的,但是这个清理只会在以下任一条件成立后才会批量删除消息文件(<code>comitlog</code>)</p><ol><li>消息文件过期(默认72个小时),且到达清理时点(默认是凌晨4点),删除过期文件. </li><li>消息文件过期(默认72个小时),且磁盘空间达到了水位线(默认75%), 删除过期文件</li><li>磁盘已经达到了必须释放的上限(85%水位线)的时候, 则开始批量清理文件(无论是否过期), 直到空间充足. </li></ol><blockquote><p>注意： 若磁盘空间达到危险水位线(90%), 处于保护自身的目的, broker 会拒绝写入服务. </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RocketMQ事务性消息&quot;&gt;&lt;a href=&quot;#RocketMQ事务性消息&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ事务性消息&quot;&gt;&lt;/a&gt;RocketMQ事务性消息&lt;/h1&gt;&lt;p&gt;​    在现在的很多分布式集群环境中, 经常会遇到本地事务无法解决的问题, 所以会引进分布式事务. 所谓的分布式事务是指分布式架构中多个服务的节点的数据一致性. &lt;/p&gt;
&lt;h2 id=&quot;1-经典的X-OpenDTP事务模型&quot;&gt;&lt;a href=&quot;#1-经典的X-OpenDTP事务模型&quot; class=&quot;headerlink&quot; title=&quot;1. 经典的X/OpenDTP事务模型&quot;&gt;&lt;/a&gt;1. 经典的X/OpenDTP事务模型&lt;/h2&gt;&lt;p&gt;​    X/Open DTP(X/Open &lt;code&gt;Distributed Transaction Processing Reference Model&lt;/code&gt;) 是X/Open 这个组织定义的一套分布式事务的标准， 也就是定义了规范和API接口,由各个厂商进行具体的实现. &lt;/p&gt;
&lt;p&gt;​    这个标准提出了使用二阶段提交(2PC-&lt;code&gt; Two-Phase-Commit&lt;/code&gt;) 来保证分布式事务的完整性.后来J2EE 也遵循了X/Open DTP 规范, 设计并使用了Java 的分布式事务编程接口规范-JTA&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/RocketMQ%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://luyanan.com/RocketMQ%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-03-01T09:46:52.851Z</published>
    <updated>2020-12-24T09:34:50.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-基本原理分析"><a href="#RocketMQ-基本原理分析" class="headerlink" title="RocketMQ 基本原理分析"></a>RocketMQ 基本原理分析</h1><h2 id="1-思考一下消息中间件的设计"><a href="#1-思考一下消息中间件的设计" class="headerlink" title="1. 思考一下消息中间件的设计"></a>1. 思考一下消息中间件的设计</h2><h3 id="1-1-可以先从基本的需求开始考虑"><a href="#1-1-可以先从基本的需求开始考虑" class="headerlink" title="1.1 可以先从基本的需求开始考虑"></a>1.1 可以先从基本的需求开始考虑</h3><ul><li>最基本的是要能支持消息的发送和接收, 需要涉及网络通信就一定就会涉及到NIO.</li><li>消息中心的消息存储(持久化/非持久化)</li><li>消息的序列化和非序列化</li><li>是否跨语言</li><li>消息的确认机制,如何避免消息重发. </li></ul><h3 id="1-2-高级功能"><a href="#1-2-高级功能" class="headerlink" title="1.2 高级功能"></a>1.2 高级功能</h3><ul><li>消息的有序性</li><li>是否支持事务消息</li><li>消息收发的性能,对高并发大数据量的支持</li><li>是否支持集群</li><li>消息的可靠性存储</li><li>是否支持多协议</li></ul><h2 id="2-MQ消息存储选择"><a href="#2-MQ消息存储选择" class="headerlink" title="2. MQ消息存储选择"></a>2. MQ消息存储选择</h2><p>从主流的几种MQ 消息队列采用的存储方式来看,主要会有三种:</p><ol><li>分布式KV存储, 比如ActiviteMQ 中采用的是lebelDB、Redis 这种存储方式对于消息读写能力要求不高的情况下可以使用. </li><li>文件系统存储,常见的kafka、RocketMQ、RabbitMQ 都是采用消息刷盘到所部署的机器上的文件系统来做持久化, 这种方案适用于对于有高吞吐量的消息中间件,因为消息刷盘是一种高效率、高可靠、高性能的持久化方式, 除非磁盘出现故障,否则一般是不会出现无法持久化的问题. </li><li>关系型数据库,比如ActiviteMQ 可以采用mysql作为消息存储,关系型数据库在单表数据量达到千万级的情况下IO性能会出现瓶颈,所以ActiviteMQ 并不适合高吞吐量的消息队列场景. </li></ol><p>总的来说, 对于存储效率,文件系统要优于分布式LV存储,分布式LV存储要优于关系型数据库. </p><h2 id="3-RocketMQ的发展历史"><a href="#3-RocketMQ的发展历史" class="headerlink" title="3. RocketMQ的发展历史"></a>3. RocketMQ的发展历史</h2><p>RocketMQ 是一个由阿里巴巴开源的消息中间件, 2012年开源, 2017年成为apache 顶级项目. </p><p>​    它的核心设计借鉴了kafka,所以我们在了解RocketMQ 的时候, 会发现很多和kafka 相同的特性。 同时, RocketMQ 在某些功能上和kafka 又有较大的差异,接下来我们就去了解RocketMQ.</p><pre><code>1. 支持集群模式、负载均衡、水平扩展能力.    2. 亿级别消息堆积能力.   3. 采用零拷贝的原理、顺序写盘,随机读   4. 底层通信框架采用Netty NIO   5. NameServer 代替zookeeper,实现服务寻址和服务协调   6. 消息失败重试机制, 消息可查询.    7. 强调集群无节点, 可扩展,任意一点高可用, 水平可扩展 .    8. 经过多次双11的考验. </code></pre><h2 id="4-RocketMQ-的架构"><a href="#4-RocketMQ-的架构" class="headerlink" title="4. RocketMQ 的架构"></a>4. RocketMQ 的架构</h2><p><img src="http://files.luyanan.com//img/20200113111049.png"></p><p>集群本身没有什么特殊之处,和kafka 的整体结构相比,其中zookeeper 替换成了NameServer. </p><blockquote><p>在rocketMQ 的早版本(2.X) 的时候, 是没有namespace 组件的, 用的是zookeeper 做分布式协调和服务发现, 但是后期阿里数据根据实际业务需求进行改进和优化,自己研发了轻量级的namesrv,用于注册Client 服务和Broker 的请求路由,namesrv 上不做任何消息的位置存储,频繁才做zookeeper 的位置存储数据会影响整体集群性能. </p></blockquote><p>RocketMQ 由四部分组成:</p><ol><li><p>Name Server 可集群部署, 节点之间无任何信息同步,提供轻量级的服务发现和路由. </p></li><li><p>Broker(消息中间角色、负责存储消息, 转发消息). 部署相对复杂，Broker 分为Master 和Slave. 一个Master 可以对应多个Slave,但是一个Slave 只能对应一个Master. Master和Slave 的对应关系通过指定相同的BrokerName,不同的BroklerId 来定义,BrokerId0 表示Master,非0表示Slave. </p></li><li><p>Producer: 生产者, 拥有相同的Producer Group 的Producer 组成一个集群, 与Name Server 集群中的其中一个节点(随机选择)建立长连接,定期 从Name Server 取Topic 路由信息, 并向提供Topic 服务的Master 建立长连接,且定时向Master 发送心跳. Producer 完全无状态,可集群部署. </p></li><li><p>Consumer: 消费者,接受消息进行消费的实例,拥有相同Consumer Group 的Consumer 组成一个集群,与Name Server 集群中的其中一个节点(随机选择) 建立长连接,定期从Name Server 取Topic 路由信息,并向提供Topic 服务的Master、Slave 建立长连接,且定时向Master、Slave 发送心跳。Consumer 既可以从Master 订阅消息, 也可以从Slave 订阅消息,订阅规则由Broker 配置决定. </p><p>要使用RockerMQ, 至少需要启动两个进程,Name Server 、Broker , 前者是各种Topic 注册中心, 后者是真正的Broker. </p></li></ol><h2 id="5-单机环境下的RocketMQ-的安装"><a href="#5-单机环境下的RocketMQ-的安装" class="headerlink" title="5.单机环境下的RocketMQ 的安装"></a>5.单机环境下的RocketMQ 的安装</h2><h3 id="5-1-下载并解压安装"><a href="#5-1-下载并解压安装" class="headerlink" title="5.1 下载并解压安装"></a>5.1 下载并解压安装</h3><ol><li><p>下载RocketMQ的安装文件  <a href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a></p></li><li><blockquote><p>unzip  rocketmq-all-4.6.0-bin-release.zip</p></blockquote><p>解压压缩包</p></li></ol><h3 id="5-2-启动Name-Server"><a href="#5-2-启动Name-Server" class="headerlink" title="5.2 启动Name Server"></a>5.2 启动Name Server</h3><ol><li><p>进入bin目录,运行namesrv, 启动NameServer </p><blockquote><p> nohup sh mqnamesrv &amp;</p></blockquote></li><li><p>默认情况下,Name Server 监听的是9876 端口</p></li><li><p>查看启动日志</p><blockquote><p>tail -1000f /root/logs/rocketmqlogs/namesrv.log</p></blockquote></li></ol><h3 id="5-3-启动Broker"><a href="#5-3-启动Broker" class="headerlink" title="5.3  启动Broker"></a>5.3  启动Broker</h3><blockquote><p>nohup sh bin/mqbroker -n ${namesrvIp}:9876 -c /conf/broker.conf &amp; -&gt;[-c可以指定broker.conf配 置文件]。</p></blockquote><p>默认情况下会加载 config/broker/conf</p><ol><li><p>启动Broker,其中-n 表示指定当前broker 对应的命名服务地址: <code>默认情况下,Broker 监听的是10911端口</code></p><blockquote><p>nohup sh mqbroker -n localhost:9876 &amp;</p></blockquote></li><li><p>查看日志</p><blockquote><p>tail -100f  /root/logs/rocketmqlogs/broker.log</p></blockquote></li></ol><h3 id="5-4内存不足的问题"><a href="#5-4内存不足的问题" class="headerlink" title="5.4内存不足的问题"></a>5.4内存不足的问题</h3><p>这是因为bin 目录下启动namesrv 和broker 的 <code>runbroker.sh</code>和<code>runserver.sh</code> 文件中默认分配的内存太大,rocketmq 比较耗内存,所以默认分配的内存比较大,而系统实际内存太小导致启动失败, 通常像虚拟机上安装的Centos 服务器内存可能是没有高的,只能调小. 实际中应该根据服务器内存情况, 配置一个合适的值. </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 8589934592 bytes for committing</span><br><span class="line">reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># /data/program/rocketmq-all-4.6.0-bin-release/bin/hs_err_pid6465.log</span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>修改 runbroker.sh和 runserver,sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms1g -Xmx1g -Xmn512g&quot;</span></span><br><span class="line">Xms 是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时</span><br><span class="line">间变慢。</span><br><span class="line">Xmx 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，</span><br><span class="line">就会抛出OutOfMemory异常。</span><br><span class="line">xmn 年轻代的heap大小，一般设置为Xmx的3、4分之一</span><br></pre></td></tr></table></figure><h3 id="5-5-停止服务"><a href="#5-5-停止服务" class="headerlink" title="5.5 停止服务"></a>5.5 停止服务</h3><p>【sh bin/mqshutdown broker】 //停止 brokersh </p><p>【bin/mqshutdown namesrv】 //停止 nameserver </p><p>停止服务的时候需要注意，要先停止broker，其次停止nameserver。</p><h3 id="5-6-broker-conf-文件"><a href="#5-6-broker-conf-文件" class="headerlink" title="5.6 broker.conf 文件"></a>5.6 broker.conf 文件</h3><p>默认情况下,启动broker 会加载 <code>conf/broker.conf</code> 这个文件,这个文件里面就是一些常规的配置信息</p><p><strong>namesrvAddr</strong>: NameServer 的地址</p><p><strong>brokerClusterName</strong>: Cluster 的名称, 如果集群机器比较多, 可以分为多个cluster,每个cluster 提供给不同的业务场景使用. </p><p><strong>brokerName</strong>: broker 名称, 如果配置主从模式, master和slave 需要配置相同的名称来表明关系. </p><p><strong>brokerId=0</strong>: 在主从模式中,一个master broker 可以有多个slave,0 表示master, 大于0表示不同slave 的id</p><p><strong>brokerRole=SYNC_MASTER/ASYNC_MASTER/SLAVE</strong>: 同步表示slave 和master 消息同步完成后再返回信息给客户端. </p><p><strong>autoCreateTopicEnable=true</strong>: topic 不存在的情况下自动创建</p><h2 id="6-消息发送和接收基本应用"><a href="#6-消息发送和接收基本应用" class="headerlink" title="6. 消息发送和接收基本应用"></a>6. 消息发送和接收基本应用</h2><h3 id="6-1-添加jar-依赖"><a href="#6-1-添加jar-依赖" class="headerlink" title="6.1 添加jar 依赖"></a>6.1 添加jar 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-生产者"><a href="#6-2-生产者" class="headerlink" title="6.2 生产者"></a>6.2 生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/13</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;生产者&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生产者组,简单来说就是多个发送用一类消息的生产者称之为一个生产者组</span></span><br><span class="line"><span class="comment">         * RocketMQ 支持事务消息,在发送事务消息时, 如果事务消息异常(producer 挂了),</span></span><br><span class="line"><span class="comment">         * broker 端会来回查事务的状态,这个时候会根据group 名称来查找对应的producer 来</span></span><br><span class="line"><span class="comment">         * 执行相应的回查逻辑,相当于实现了producer 的高可用.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;producer_group&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行namesrv 服务地址, 获取broker 的相关信息</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.86.128:9876&quot;</span>);</span><br><span class="line">        producer.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建一个消息实例,指定topic、tag、消息内容</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,<span class="comment">// topic</span></span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>, <span class="comment">// tag</span></span><br><span class="line">                        (<span class="string">&quot;Hello World&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)<span class="comment">// message Body</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 发送消息并且发送结果</span></span><br><span class="line">                SendResult sendResult = producer.send(message);</span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SendResult</code> 中有一个sendStatus状态, 表示消息的发送状态, 一共有四种状态. </p><ol><li><code>FLUSH_DISK_TIMEOUT</code>: 表示没有在规定的时间内完成刷盘(需要Broker的刷新策略设置成<code>SYNC_FLUSH</code> 才会报这个错)</li><li><code>FLUSH_SLAVE_TIMEOUT</code>: 表示在主备方式下, 并且Broker 设置成<code>成SYNC_MASTER</code> 方式,没有在设定时间内完成主从同步. </li><li><code>SLAVE_NOT_AVAILABLE</code>: 这个状态产生的场景和<code>FLUSH_SLAVE_TIMEOUT</code> 类似,表示在主备方式下, 并且Broker 被设置为<code>SYNC_MASTER</code> , 并且没有找到被配置为Slave 的Broker. </li><li><code>SEND OK</code>: 表示发送成功,发送成功的具体含义, 比如消息是否已经被存储到磁盘? 消息是否被同步到了Slave 上？消息在Slave 是否被写入磁盘? 需要结合所配置的刷盘策略,主从策略来定. 这个状态还可以简单理解为, 没有发生上面累出的三个问题状态就是<code>SEND OK</code>.</li></ol><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p><code>consumerGroup</code>:位于同一个<code>consumerGroup</code> 中的consumer 实例和<code>producerGroup</code> 中的各个producer 实例承担的角色类似,同一个group 中可以配置多个consumer, 可以体改消费端的并发消费能力以及容灾. </p><p>​    和Kafka 一样,多个consumer 会对消息做负载均衡, 意味着同一个topic 下的不同messageQueue 会分发给同一个group中的不同 consumer. </p><p>​    同时, 如果我们希望消息能够达到广播的目的, 只需要把consumer 加入到不同的group就行. </p><p>​    RocketMQ 提供了两种消息消费模式,一种是pull主动去拉, 另一种是push,被动接收. 但是实际上,RocketMQ 都是pull模式,只是push在pull模式上做了一层封装,也就是pull到消息以后触发业务消息. </p><p> nameServer 的地址: nameserver 地址,用于或者broker、topic. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPullConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/13</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;消费者&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者的组名, 这个和kafka 的一样的, 需要特别注意</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;consumer_group&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定NameServer 的地址, 多个地址用, 隔开</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.86.128:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  设置consumer 第一次启动是从队列头部开始还是从队尾开始消费</span></span><br><span class="line">        <span class="comment">// 如果非第一次启动,则按照上次消费的位置继续消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 订阅TopicTest 下的所有tag的消息</span></span><br><span class="line">        <span class="comment">// * 表示不过滤,可以通过tag来过滤</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注册消息监听,这里有两种监听 MessageListenerConcurrently以及MessageListenerOrderly, 前者是普通监听, 后者是顺序监听.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;receive Message : &quot;</span> + list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-RocketMQ-控制台安装"><a href="#7-RocketMQ-控制台安装" class="headerlink" title="7. RocketMQ 控制台安装"></a>7. RocketMQ 控制台安装</h2><p>​    启动好服务之后, 总得有一个可视化节界面来看看我们配置的节点把, Rocket 官方提供了一个可视化控制台,大家可以在这个地址下载. </p><p><a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p><p>这个是RocketMQ的扩展,里面不仅包含控制台的扩展,也包含了对大数据 flume、hbase 等组件的对接和扩展. </p><h3 id="7-1-下载源码包"><a href="#7-1-下载源码包" class="headerlink" title="7.1  下载源码包"></a>7.1  下载源码包</h3><p><a href="https://github.com/apache/rocketmq-externals/archive/master.zip">https://github.com/apache/rocketmq-externals/archive/master.zip</a></p><h3 id="7-2-解压并修改配置"><a href="#7-2-解压并修改配置" class="headerlink" title="7.2 解压并修改配置"></a>7.2 解压并修改配置</h3><ul><li><p><code>cd /$&#123;rocketmq-externals-home&#125;/rocket-console/</code></p></li><li><p>修改<code>application.properties</code> 文件</p></li><li><p>配置namesrvAddr地址，指向目标服务的ip和端口:</p><p><code>rocketmq.config.namesrvAddr=192.168.86.128:9876</code></p></li></ul><h3 id="7-3-运行"><a href="#7-3-运行" class="headerlink" title="7.3  运行"></a>7.3  运行</h3><ol><li><code> cd /$&#123;rocketmq-externals-home&#125;/rocket-console/</code></li><li><code>mvn spring-boot:run</code></li></ol><h3 id="7-4-通过控制台创建消息"><a href="#7-4-通过控制台创建消息" class="headerlink" title="7.4  通过控制台创建消息"></a>7.4  通过控制台创建消息</h3><p>要能够发送和接受消息,需要先创建Topic, 这里的topic 和kafka 的topic 的概念是一样的.<br>进入到控制台,选择Topic</p><p><img src="http://files.luyanan.com//img/20200114093613.png"></p><p><img src="http://files.luyanan.com//img/20200114093628.png"></p><p>readQueueNums和writeQueueNums分别表示读队列数和写队列数</p><p>writeQueueNums表示producer发送到的MessageQueue的队列个数</p><p>readQueueNumbs表示Consumer读取消息的MessageQueue队列个数，其实类似于kafka的分区的概 念 </p><p>这两个值需要相等，在集群模式下如果不相等，假如说writeQueueNums=6,readQueueNums=3, 那 么每个broker上会有3个queue的消息是无法消费的。</p><h2 id="8-RocketMQ消息支持的模式"><a href="#8-RocketMQ消息支持的模式" class="headerlink" title="8. RocketMQ消息支持的模式"></a>8. RocketMQ消息支持的模式</h2><h3 id="8-1-NormalProducer（普通）"><a href="#8-1-NormalProducer（普通）" class="headerlink" title="8.1 NormalProducer（普通）"></a>8.1 NormalProducer（普通）</h3><h4 id="8-1-1-消息同步发送"><a href="#8-1-1-消息同步发送" class="headerlink" title="8.1.1 消息同步发送"></a>8.1.1 消息同步发送</h4><p>​    普通消息的发送和接收已经前面演示过了,在上面的案例中是基于同步消息发送模式,也就是说 消息发送出去后, producer 会等到broker 回应后才能继续发送下一个消息. </p><p><img src="http://files.luyanan.com//img/20200114094305.png"></p><h4 id="8-1-2-消息异步发送"><a href="#8-1-2-消息异步发送" class="headerlink" title="8.1.2 消息异步发送"></a>8.1.2 消息异步发送</h4><p>​    异步发送是指发送方发送数据后,不等接收方发回响应,接着发送下个数据包的通讯方式.MQ的异步发送, 需要用户实现异步发送回调接口(SendCalllable).消息发送方在发送了一条消息后,不需要等待服务器响应即可返回,进行第二条消息发送。发送方通过回调接口接受服务器响应, 并对响应结果进行处理. </p><p><img src="http://files.luyanan.com//img/20200114094904.png"></p><blockquote><p>异步代码改造</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步发送</span></span><br><span class="line">             producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                     System.out.println(sendResult);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                     throwable.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br></pre></td></tr></table></figure><h3 id="8-2-OneWay"><a href="#8-2-OneWay" class="headerlink" title="8.2 OneWay"></a>8.2 OneWay</h3><p>单向(OneWay) 发送特点为发送方只负责发送消息, 不等待服务器且没有回调函数触发,即只发送请求不等待应发, 效率最高. </p><p><img src="http://files.luyanan.com//img/20200114095934.png"></p><blockquote><p>producer.sendOneway(msg);</p></blockquote><h3 id="8-3-OrderProducer（顺序）"><a href="#8-3-OrderProducer（顺序）" class="headerlink" title="8.3  OrderProducer（顺序）"></a>8.3  OrderProducer（顺序）</h3><p>​     在kafka 中, 消息可以通过自定义分区策略来实现消息的顺序发送,实现原理就是把同一类消息发送到相同的分区上. </p><p>​    在RocketMQ中,是基于多个Message Queue 来实现类似于Kafka 的分区效果的. 如果一个Topic 要发送和接收的数据量非常大,需要能支持增加并行处理的机器来提高处理速度,这时候一个Topic 可以根据需求设置一个或者多个Message Queue . Topic 有了多个Message Queue 后, 消息可以并行的向各个Message Queue 发送, 消息者也可以从多个Message Queue 读取消息并消费. </p><blockquote><p>要了解RocketMQ消息的顺序消费, 还的对RocketMQ的整体架构有一定的了解 </p></blockquote><h4 id="8-3-1-RocketMQ-消息发送和消费的基本原理"><a href="#8-3-1-RocketMQ-消息发送和消费的基本原理" class="headerlink" title="8.3.1 RocketMQ 消息发送和消费的基本原理"></a>8.3.1 RocketMQ 消息发送和消费的基本原理</h4><p>​    这是一个比较宏观的部署架构图,Rocketmq 天然支持高可用,它可以支持多主多从的架构部署,这也是和kafka 最大的区别. </p><p>​    原因是RocketMQ 中并没有master 选举功能,所以通过配置多个Master 节点来保证RocketMQ 的高可用, 和所有的集群角色定位一样,Master 节点负责接收事务请求,slave 节点只负责接收读请求,并且接收master 同步过来的数据和slave 保持一致. 当master 挂了以后,如果当前rocketmq 是一主多从, 就意味着无法接收发送端的消息,但是消费者仍然能够继续消费. </p><p>​    所以配置多个主节点后, 可以保证其中一个master节点挂了之后, 另外一个master 节点仍然能够堆外提供消息发送服务. </p><p>​    当存在多个主节点时, 一条消息只会发送到其中一个主节点, rocketmq 对于多个master节点的消息发送, 会做负载均衡,使得消息可以平衡的发送到多个master 节点上. </p><p>​    一个消费者可以同时消费多个master 节点上的消息,在下面的这个架构图中, 两个master 节点恰好可以平均分发到两个消费者上,如果此时只有一个消费者,那么这个消费者会同时消费两个master 节点的数据. </p><p>​    由于每个master 可以配置多个slave, 所以如果其中一个master 挂了, 消息仍然可以被消费者从slave 节点消费到,可以完美的实现rocketmq 消息的高可用. </p><p>​    <img src="http://files.luyanan.com//img/20200114103512.png"></p><p>接下来,站在topic 的角度来看看消息是如何分发和处理的, 假设有两个master 节点的集群, 创建了一个TestTopic, 并且对这个topic 创建了两个队列,也就是分区. </p><p>​    消费者定义了两个分组, 分组的概念也是跟kafka 一样, 通过分区可以实现消息的广播. </p><p><img src="http://files.luyanan.com//img/20200114103713.png"></p><p>​    将下来, 站在topic 的角度来看看消息是如何分发和处理的,假设有两个master节点的集群, 创建了一个TestTopic,并且对这个topic 创建了两个队列,也就是分区. </p><p>​    消费者定义了两个分组,分组的概念也是和kafka 一样, 通过分组可以实现消息的广播. </p><p><img src="http://files.luyanan.com//img/20200114104339.png"></p><h4 id="8-3-2-集群支持"><a href="#8-3-2-集群支持" class="headerlink" title="8.3.2 集群支持"></a>8.3.2 集群支持</h4><p>RocketMQ 天生对集群的支持非常友好. </p><h5 id="1-单Master"><a href="#1-单Master" class="headerlink" title="1. 单Master"></a>1. 单Master</h5><p>优点: 除了配置简单没有什么优点</p><p>缺点: 不可靠, 该集群重启或者宕机,将导致 整个服务不可用</p><h5 id="2-多Master"><a href="#2-多Master" class="headerlink" title="2. 多Master"></a>2. 多Master</h5><p>优点: 配置简单, 性能最高</p><p>缺点: 可能会有少量消息丢失(配置相关), 单台机器重启或者宕机期间,该机器下未被消费的消息将在机器恢复前不可订阅, 影响消息实时性. </p><h5 id="3-多Master-多Slave-异步复制"><a href="#3-多Master-多Slave-异步复制" class="headerlink" title="3. 多Master,多Slave(异步复制)"></a>3. 多Master,多Slave(异步复制)</h5><p>每个master 配置一个slave, 有多对master-slave, 集群采用异步复制的方式, 主备有短暂的消息延迟,毫秒级</p><p>优点: 性能同多master 一样,实时性高, 主备间切换应用透明, 不需要人工干预. </p><p>缺点: Master 宕机或者磁盘损坏时会有少量的消息丢失. </p><h5 id="4-多Master-多Slave-同步双写"><a href="#4-多Master-多Slave-同步双写" class="headerlink" title="4.  多Master,多Slave(同步双写)"></a>4.  多Master,多Slave(同步双写)</h5><p>每个Master 配一个Slave, 有多对Master-slave, 集群采用同步双写方式, 主备都写成功, 向应用返回成功. </p><p>优点: 服务可用性与数据可用性非常高. </p><p>缺点: 性能比异步集群略低, 当前版本主宕机备不能自动切换为主. </p><p>需要注意的是:在RocketMQ 中, 1台机器只能要么是Master, 要么是slave, 这个在初始化的机器配置里面, 就定死了. 不会像kafka 那样存在master 动态选举的功能. 其中Master 的<code>brokerId=0,Slaved的brokerId&gt;0</code></p><p>有点类似于mysql的主从的概念,master 挂了以后, Slave仍然可以提供读服务,但是由于有多主的存在, 当一个master 挂了以后,可以写到其他的master上. </p><h3 id="8-4-消息发送到topic-多个MessageQueue"><a href="#8-4-消息发送到topic-多个MessageQueue" class="headerlink" title="8.4 消息发送到topic 多个MessageQueue"></a>8.4 消息发送到topic 多个MessageQueue</h3><p>接下来演示一下 topic 创建多个MessageQueue </p><ol><li><p>创建一个队列,设置2个写队列和2个读队列,如果读和写的队列不一样,会存在消息无法消费的问题. </p><p> <img src="http://files.luyanan.com//img/20200114112938.png"></p><ol start="2"><li><p>构建生产者和消费者, 参考上面写的生产者和消费者的代码</p></li><li><p>消费者数量控制对于队列的消费情况</p></li><li><p>如果消费队列为2,启动一个消费者,那么这个消费者会消费两个队列</p></li><li><p>如果两个消费者消费这个队列,那么意味着消费会均衡平摊到这两个消费者</p></li><li><p>如果消费者数大于<code>readQueueNumbs</code>, 那么会有一些消费者消费不到消息,浪费资源. </p></li></ol></li></ol><h3 id="8-5-消息的顺序消费"><a href="#8-5-消息的顺序消费" class="headerlink" title="8.5 消息的顺序消费"></a>8.5 消息的顺序消费</h3><p>​    首先需要保证顺序的消息要发送到用一个MessageQueue;其次, 一个MessageQueue 只能被一个消费者消费,这点是消息队列的分配机制来保证的; 最后, 一个消费者内部对一个mq 的消费者要保证是有序的. </p><p>​    我们要做到生产者- messagequeue - 消费者,是一对一的关系.</p><h3 id="8-6-自定义消息发送负责"><a href="#8-6-自定义消息发送负责" class="headerlink" title="8.6 自定义消息发送负责"></a>8.6 自定义消息发送负责</h3><p>​    通过自定义发送策略来实现消息只发送到同一个队列. </p><p>​    因为同一个Topic 会有多个MessageQueue, 如果使用Producer 会轮流向各个Message Queue 发送消息. Consumer 在消费消息的时候, 会根据负载均衡策略, 消费被分配到Message Queue. </p><p>​    如果不经过特定的设置, 某条消息被发往哪个Message Queue, 被哪个Consumer 消费是未知的. </p><p>​      如果业务需要我们把消息发送到指定的Message Queue 里面, 比如把某一类型的消息都发往相同的Message Queue, 那是不是可以实现顺序消息的功能呢？ </p><p>​     和kafka 一样,rocketMQ 也实现了消息的路由功能,我们可以自定义消息分发策略,可以实现<code>MessageQueueSelector</code> , 来实现自己的消息分发策略. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义消息发送规则</span></span><br><span class="line">producer.send(message, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = o.hashCode();</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">int</span> index = key % size;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);<span class="comment">// list.get(0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;key_&quot;</span> + i);</span><br></pre></td></tr></table></figure><h3 id="8-7-如何保证消息消费顺序呢"><a href="#8-7-如何保证消息消费顺序呢" class="headerlink" title="8.7 如何保证消息消费顺序呢?"></a>8.7 如何保证消息消费顺序呢?</h3><p>​    通过分区规则可以实现同类消息在rocketmq 上的顺序存储,但是对于消费端来说,如何保证消费的顺序?</p><p>​    我们前面写的消息消费代码使用的是<code>MessageListenerConcurrently</code> 并发监听, 也就是基于多个线程并行来消费消息,这个无法保证消息消费的顺序. </p><p>​    RocketMQ 中提供了<code>MessageListenerOrderly</code> 一个类来实现顺序消费. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序消费</span></span><br><span class="line">     consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> </span>&#123;</span><br><span class="line">             list.stream().forEach(m -&gt; System.out.println(<span class="keyword">new</span> String(m.getBody())));</span><br><span class="line">             <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><p>顺序消费会带来一些问题： </p><ol><li>遇到消息失败的消息, 无法跳过,当前队列消费暂停. </li><li>降低了消息处理的性能. </li></ol><h3 id="8-8-消费端的负载均衡"><a href="#8-8-消费端的负载均衡" class="headerlink" title="8.8 消费端的负载均衡"></a>8.8 消费端的负载均衡</h3><p>​    和kafka 一样,消费端也会针对Message Queue 做负载均衡,使得每个消费者能够合理的消费多个分区的消息. </p><h5 id="8-8-1-消费端会通过RebalanceService-线程-10秒做一次机遇topic下的所有队列负载"><a href="#8-8-1-消费端会通过RebalanceService-线程-10秒做一次机遇topic下的所有队列负载" class="headerlink" title="8.8.1 消费端会通过RebalanceService 线程, 10秒做一次机遇topic下的所有队列负载"></a>8.8.1 消费端会通过<code>RebalanceService</code> 线程, 10秒做一次机遇topic下的所有队列负载</h5><ul><li>消费者遍历自己所有的topic, 依次调用<code>rebalanceByTopic</code>. </li><li>根据topic 获取此topic 下的所有queue</li><li>选择一台broker 获取机遇group 的所有消费端(有心跳向所有broker 注册客户端信息)</li><li>选择队列分配策略实例 <code>AllocateMessageQueueStrategy</code> 执行分配算法</li></ul><h5 id="8-8-2-什么时候触发负载均衡"><a href="#8-8-2-什么时候触发负载均衡" class="headerlink" title="8.8.2 什么时候触发负载均衡"></a>8.8.2 什么时候触发负载均衡</h5><ul><li>消费者启动之后</li><li>消费者数量发生变更</li><li>每10秒会触发检查一次<code>rebalance</code></li></ul><h5 id="8-8-3-分配算法"><a href="#8-8-3-分配算法" class="headerlink" title="8.8.3 分配算法"></a>8.8.3 分配算法</h5><p>RocketMQ 提供了6种分区的分配算法</p><ul><li><code>AllocateMessageQueueAveragely</code>: 平均分配算法(默认)</li><li><code>AllocateMessageQueueAveragelyByCircle</code>: 环状分配消息队列</li><li><code>AllocateMessageQueueByConfig</code>: 按照配置来分配队列, 根据用户指定的配置来进行负载</li><li><code>AllocateMessageQueueByMachineRoom</code>: 按照指定机房来配置队列</li><li><code>AllocateMachineRoomNearby</code>: 按照就近机房来配置队列</li><li><code>AllocateMessageQueueConsistentHash</code>: 一致性Hash,根据消费者的cid进行</li></ul><h2 id="9-消息的可靠性原则"><a href="#9-消息的可靠性原则" class="headerlink" title="9. 消息的可靠性原则"></a>9. 消息的可靠性原则</h2><p>​    在实际使用RocketMQ 的时候我们并不能保证每次发送的消息都刚好能被消费者一次性正常消费成功,可能会存在需要多次消费才能成功或者一直消费失败的情况,那作为发送者该做如何处理呢? </p><h3 id="9-1-消息消费端的确认机制"><a href="#9-1-消息消费端的确认机制" class="headerlink" title="9.1 消息消费端的确认机制"></a>9.1 消息消费端的确认机制</h3><p>​    RocketMQ 提供了ack机制,以保证消息能够被正常消费. 发送方为了保证消息肯定消费成功,只有使用方明确表示消费成功,RocketMQ 才会认为消息消费成功. 中途断电、抛出异常都不会认为成功. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;receive Message : &quot;</span> + list);</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>​    所有的消费者在设置监听的时候会提供一个回调,业务实现消费回调的时候, 当回调方法中返回<code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code>, RocketMQ 才会认为这批消息(默认是1条),是消费完成的. 如果这个时候消息消费失败, 例如数据库异常、余额扣款不足等一切业务认为消息需要重试的场景,只要返回<code>回ConsumeConcurrentlyStatus.RECONSUME_LATER</code>, RocketMQ 就会认为这批消息消费失败了. </p><h3 id="9-2-消息的衰减机制"><a href="#9-2-消息的衰减机制" class="headerlink" title="9.2 消息的衰减机制"></a>9.2 消息的衰减机制</h3><p>​    为了保证消息肯定至少被消费一次,RocketMQ 会把这批消息重新发回到broker,在延迟的某个时间点(默认是10s, 业务可设置)后, 再次投递到这个<code>consumerGroup</code>. 而如果一直这样重复消费都持续到一定次数(默认16次),就会投递到DLQ死信队列,应用可以监控死信队列来做人工干预. </p><p> 可以修改broker-a.conf 文件</p><blockquote><p>messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</p></blockquote><h3 id="9-3-重试消息的处理机制"><a href="#9-3-重试消息的处理机制" class="headerlink" title="9.3 重试消息的处理机制"></a>9.3 重试消息的处理机制</h3><p>​    一般情况下,我们在实际生产中是不需要重试16次, 这样既浪费时间又浪费性能,理论上当尝试重复次数达到我们想要的结果时如果还是消费失败, 那么我们就需要将对应的消息进行记录,并且结束重试尝试.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener((MessageListenerConcurrently) (list,</span><br><span class="line">consumeOrderlyContext) -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line"><span class="keyword">if</span>(messageExt.getReconsumeTimes()==<span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//可以将对应的数据保存到数据库，以便人工干预</span></span><br><span class="line">System.out.println(messageExt.getMsgId()+<span class="string">&quot;,&quot;</span>+messageExt.getBody());</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RocketMQ-基本原理分析&quot;&gt;&lt;a href=&quot;#RocketMQ-基本原理分析&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ 基本原理分析&quot;&gt;&lt;/a&gt;RocketMQ 基本原理分析&lt;/h1&gt;&lt;h2 id=&quot;1-思考一下消息中间件的设计&quot;&gt;&lt;a href=&quot;#1-思考一下消息中间件的设计&quot; class=&quot;headerlink&quot; title=&quot;1. 思考一下消息中间件的设计&quot;&gt;&lt;/a&gt;1. 思考一下消息中间件的设计&lt;/h2&gt;&lt;h3 id=&quot;1-1-可以先从基本的需求开始考虑&quot;&gt;&lt;a href=&quot;#1-1-可以先从基本的需求开始考虑&quot; class=&quot;headerlink&quot; title=&quot;1.1 可以先从基本的需求开始考虑&quot;&gt;&lt;/a&gt;1.1 可以先从基本的需求开始考虑&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;最基本的是要能支持消息的发送和接收, 需要涉及网络通信就一定就会涉及到NIO.&lt;/li&gt;
&lt;li&gt;消息中心的消息存储(持久化/非持久化)&lt;/li&gt;
&lt;li&gt;消息的序列化和非序列化&lt;/li&gt;
&lt;li&gt;是否跨语言&lt;/li&gt;
&lt;li&gt;消息的确认机制,如何避免消息重发. &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-高级功能&quot;&gt;&lt;a href=&quot;#1-2-高级功能&quot; class=&quot;headerlink&quot; title=&quot;1.2 高级功能&quot;&gt;&lt;/a&gt;1.2 高级功能&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%BC%96%E7%A8%8B(2)/"/>
    <id>http://luyanan.com/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%BC%96%E7%A8%8B(2)/</id>
    <published>2021-03-01T09:46:52.839Z</published>
    <updated>2020-12-24T09:34:50.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-Spring-AMQP"><a href="#3-Spring-AMQP" class="headerlink" title="3. Spring AMQP"></a>3. Spring AMQP</h2><h3 id="3-1-Spring-AMQP-介绍"><a href="#3-1-Spring-AMQP-介绍" class="headerlink" title="3.1 Spring AMQP 介绍"></a>3.1 Spring AMQP 介绍</h3><p>思考： </p><p>Java API 方式编程, 有什么问题? </p><p>Spring 封装RabbitMQ的时候, 它做了什么呢? </p><ol><li> 管理对象(队列,交换机、绑定)</li><li>封装方法(发送消息、接收消息)</li></ol><p>​    Spring AMQP 是对Spring 基于AMQP 的消息收发解决方案, 它是一个抽象层, 不依赖特定的AMQP Broker 实现和客户端的抽象, 所以我们可以很方便的替换. 我们我们可以使用<code>spring-rabbit</code> 来实现. </p><h3 id="3-2-Spring-AMQP-核心组件"><a href="#3-2-Spring-AMQP-核心组件" class="headerlink" title="3.2 Spring AMQP 核心组件"></a>3.2 Spring AMQP 核心组件</h3><h4 id="3-2-1-ConnectionFactory"><a href="#3-2-1-ConnectionFactory" class="headerlink" title="3.2.1 ConnectionFactory"></a>3.2.1 ConnectionFactory</h4><p>​    Spring AMQP 的连接工厂接口, 用于创建连接, <code>CachingConnectionFactory</code> 是<code>ConnectionFactory</code>的一个实现类. </p><h4 id="3-2-2-RabbitAdmin"><a href="#3-2-2-RabbitAdmin" class="headerlink" title="3.2.2 RabbitAdmin"></a>3.2.2 RabbitAdmin</h4><p>​    RabbitAdmin 是<code>AmqpAdmin</code>的实现, 封装了对RabbitMQ的基础管理操作, 比如对交换机、队列、绑定的声明和删除等. </p><p>​      编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.rabbitspring.admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.ConsumerTagStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line"></span><br><span class="line">        factory.setUri(<span class="string">&quot;amqp://guest:guest@127.0.0.1:5672&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">rabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> rabbitAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">container</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">        container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.rabbitspring.admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.rabbitmq.rabbitspring.admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AdminTest.class);</span><br><span class="line"></span><br><span class="line">        RabbitAdmin rabbitAdmin = applicationContext.getBean(RabbitAdmin.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个交换机</span></span><br><span class="line">        rabbitAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;ADMIN_EXCHANGE&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 声明一个队列</span></span><br><span class="line">        rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;ADMIN_QUEUE&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 声明一个绑定</span></span><br><span class="line">        rabbitAdmin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">&quot;ADMIN_QUEUE&quot;</span>, Binding.DestinationType.QUEUE, <span class="string">&quot;ADMIN_EXCHANGE&quot;</span>, <span class="string">&quot;admin&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    为什么我们在配置文件(Spring) 或者配置类(SpringBoot) 里面定义了交换机、队列、绑定关系,并没有直接调用Channel 的declare方法, Spring 在启动的时候就可以帮我们创建这些元数据? 这些数据就是由RabbitAdmin 完成的. </p><p>​    RabbitAdmin 实现了InitializingBean 接口,里面由一个唯一的方法 afterPropertiesSet(),这个方法会在RabbitAdmin 的属性值设置完的时候被调用. </p><p>​    在<strong>afterPropertiesSet()</strong> 方法中, 调用了一个<code>initialize()</code> 方法, 这里面创建了三个Collection,用来盛放交换机、队列、绑定关系. </p><p>​    最后依次声明返回类型为Exchange、Queue和Binding的这些Bean, 底层还是调用了Channel 的declare方法. </p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declareExchanges(channel, exchanges.toArray(<span class="keyword">new</span> Exchange[exchanges.size()]));</span><br><span class="line">declareQueues(channel, queues.toArray(<span class="keyword">new</span> Queue[queues.size()]));</span><br><span class="line">declareBindings(channel, bindings.toArray(<span class="keyword">new</span> Binding[bindings.size()]));</span><br></pre></td></tr></table></figure></code></pre><h4 id="3-2-3-Message"><a href="#3-2-3-Message" class="headerlink" title="3.2.3 Message"></a>3.2.3 Message</h4><p> Message 是Spring AMQP 对消息的封装. </p><p>  两个重要的属性: </p><ul><li>body: 消息内容</li><li>messageProperties: 消息属性</li></ul><p><img src="http://files.luyanan.com//img/20200108171217.png"></p><h4 id="3-2-4-RabbitTemplate-消息模板"><a href="#3-2-4-RabbitTemplate-消息模板" class="headerlink" title="3.2.4 RabbitTemplate 消息模板"></a>3.2.4 RabbitTemplate 消息模板</h4><p>​    RabbitTemplate 是AmqpTemplate 的一个实现(目前到此为止也是唯一的实现), 用来简化消息的收发,支持消息的确认(Configm)与返回(Return). 跟JDBCTemplate 一样, 它封装了建立连接、创建消息信道、收发消息、消息合适转换(ConvertAndSend -&gt;Message)、关闭信道、关闭连接等等操作. </p><p> 对于多个服务器连接, 可以定义多个Template, 可以注入到任何需要收发消息的地方使用. </p><p>确认与回发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">       RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">       rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 回发</span></span><br><span class="line">       rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String routingKey)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;回发的消息：&quot;</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;replyCode: &quot;</span> + replyCode);</span><br><span class="line">               System.out.println(<span class="string">&quot;replyText: &quot;</span> + replyText);</span><br><span class="line">               System.out.println(<span class="string">&quot;exchange: &quot;</span> + exchange);</span><br><span class="line">               System.out.println(<span class="string">&quot;routingKey: &quot;</span> + routingKey);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 确认</span></span><br><span class="line">       rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;发送消息失败：&quot;</span> + cause);</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;发送异常：&quot;</span> + cause);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-MessageListener-消息侦听"><a href="#3-2-5-MessageListener-消息侦听" class="headerlink" title="3.2.5 MessageListener 消息侦听"></a>3.2.5 MessageListener 消息侦听</h4><h5 id="MessageListener"><a href="#MessageListener" class="headerlink" title="MessageListener :"></a>MessageListener :</h5><p>​    MessageListener 是Spring AMQP 异步消息投递的监听器接口, 它只有一个方法<code>onMessage</code>,用于处理消息队列送来的消息, 作用类似于Java API 中的Comsumer. </p><p>​    </p><h5 id="MessageListenerContainer"><a href="#MessageListenerContainer" class="headerlink" title="MessageListenerContainer"></a>MessageListenerContainer</h5><p>​    MessageListenerContainer 可以理解为MessageListener 的容器, 一个Contailer 只有一个listener, 但是可以生成多个线程使用的MessageListener同时消费消息. </p><p>​    Contailer 可以管理Listener 的生命周期, 可以用于对于消费者进行配置. </p><p>例如: 动态添加队列、对消费者进行设置,例如ConsumerTag、Arguments、并发、消费者数量、消息确认模式等. </p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">container</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">       SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">       <span class="comment">// 设置监听的队列</span></span><br><span class="line">       container.setQueues(getSecondQueue(), getThirdQueue());</span><br><span class="line">       <span class="comment">// 最小消费数</span></span><br><span class="line">       container.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//最大的消费者数量</span></span><br><span class="line">       container.setMaxConcurrentConsumers(<span class="number">5</span>);</span><br><span class="line">       <span class="comment">// 是否重回队列</span></span><br><span class="line">       container.setDefaultRequeueRejected(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//签收模式</span></span><br><span class="line">       container.setAcknowledgeMode(AcknowledgeMode.AUTO);</span><br><span class="line">   </span><br><span class="line">       container.setExposeListenerChannel(<span class="keyword">true</span>);</span><br><span class="line">       container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> container;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>在SpringBoot 2.0 中新增了一个<code>DirectMessageListenerContainer。</code></p><h5 id="DirectMessageListenerContainer"><a href="#DirectMessageListenerContainer" class="headerlink" title="DirectMessageListenerContainer"></a>DirectMessageListenerContainer</h5><p>Spring 整合IBM MQ、JMS、Kafka 也是这么做的. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory containerFactory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    containerFactory.setConnectionFactory(connectionFactory);</span><br><span class="line">    containerFactory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    containerFactory.setAcknowledgeMode(AcknowledgeMode.NONE);</span><br><span class="line">    containerFactory.setAutoStartup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> containerFactory;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以在消费者上指定, 当我们需要监听多个RabbitMQ 的服务器的时候, 指定不同的<code>MessageListenerContainerFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;first_queue&quot;, containerFactory = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="meta">@Payload</span> Object message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First_queue received mes : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>产生关系与继承关系</p><p><img src="http://files.luyanan.com//img/20200109103854.png"></p><p><img src="http://files.luyanan.com//img/20200109103906.png"></p><p>整合代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory(<span class="keyword">new</span> URI(RabbitConfig.rabbitUrl));</span><br><span class="line">        SimpleRabbitListenerContainerFactory containerFactory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        containerFactory.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        SimpleMessageListenerContainer container = containerFactory.createListenerContainer();</span><br><span class="line">        <span class="comment">// 不用工厂模式也可以创建</span></span><br><span class="line">        container.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        container.setQueueNames(<span class="string">&quot;BASIC_SECOND_QUEUE&quot;</span>);</span><br><span class="line">        container.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        container.start();</span><br><span class="line"></span><br><span class="line">        AmqpTemplate template = <span class="keyword">new</span> RabbitTemplate(factory);</span><br><span class="line">        template.convertAndSend(<span class="string">&quot;BASIC_SECOND_QUEUE&quot;</span>, <span class="string">&quot;msg1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-6-转换器MessageConvertor"><a href="#3-2-6-转换器MessageConvertor" class="headerlink" title="3.2.6  转换器MessageConvertor"></a>3.2.6  转换器MessageConvertor</h4><h5 id="MessageConvertor-的作用"><a href="#MessageConvertor-的作用" class="headerlink" title="MessageConvertor 的作用?"></a>MessageConvertor 的作用?</h5><p>​    RabbitMQ的消息在网络传输中需要转换成byte[]（字节数组）进行发送, 消费者需要对字节数组进行解析. </p><p>​    在Spring AMQP 中, 消息会被封装为<code>org.springframework.amqp.core.Message</code> 对象. 消息的序列化和反序列化, 就是处理Message 的消息体body 对象.    </p><p>   如果消息已经是byte[] 格式,就不需要转换. </p><p>  如果是String, 会转换成byte[].</p><p>   如果是Java 对象,会使用JDK 序列化对象转换为byte<a href="%E4%BD%93%E7%A7%AF%E5%A4%A7,%E6%95%88%E6%9E%9C%E5%B7%AE"></a>. </p><p>   在调用RabbitTemplate 的<code>convertAndSend()</code> 方法发送消息的时候, 会使用<code>MessageConvertor</code> 进行消息的序列化,默认使用<code>SimpleMessageConverter</code>.</p><p>​    在某些情况下,我们需要选择其他的高效的序列化工具.如果我们不想在每次发送消息的时候自己处理消息,就可以直接定义一个 <code>MessageConverter</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MessageConvertor-如何工作的"><a href="#MessageConvertor-如何工作的" class="headerlink" title="MessageConvertor 如何工作的?"></a>MessageConvertor 如何工作的?</h5><p>​    调用了RabbitTemplate 的 <code> convertAndSend()</code> 方法时会使用对应的MessageConvertor  进行消息的序列化和反序列化. </p><p>​    序列化: Object-&gt; json-&gt; Message(body)-&gt; byte[]</p><p>​    反序列化: byte[] -&gt; Message -&gt; json -&gt; Object</p><h5 id="有哪些MessageConvertor"><a href="#有哪些MessageConvertor" class="headerlink" title="有哪些MessageConvertor?"></a>有哪些MessageConvertor?</h5><p>​    在Spring 中提供一个默认的转换器: <code>SimpleMessageConverter</code>.</p><p>​    <code>Jackson2JsonMessageConverter</code>(RabbitMQ自带): 将对象转换为json, 然后再转换成字节数字进行传递. </p><p><img src="http://files.luyanan.com//img/20200109110534.png"></p><h5 id="如何自定义MessageConvertor"><a href="#如何自定义MessageConvertor" class="headerlink" title="如何自定义MessageConvertor"></a>如何自定义MessageConvertor</h5><p>   例如: 我们要使用Gson 格式化消息. </p><p> 创建一个类, 实现MessageConverter 接口，重写 toMessage()和 fromMessage() 方法。</p><ul><li>toMessage(): Java 对象转换为Message</li><li>fromMessage(): Message 对象转换为Java 对象</li></ul><h3 id="3-3-Spring-集成RabbitMQ-配置解读"><a href="#3-3-Spring-集成RabbitMQ-配置解读" class="headerlink" title="3.3 Spring 集成RabbitMQ 配置解读"></a>3.3 Spring 集成RabbitMQ 配置解读</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">virtual-host</span>=<span class="string">&quot;/&quot;</span> <span class="attr">username</span>=<span class="string">&quot;guest&quot;</span> <span class="attr">password</span>=<span class="string">&quot;guest&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">&quot;connectAdmin&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;MY_FIRST_QUEUE&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> <span class="attr">declared-by</span>=<span class="string">&quot;connectAdmin&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">&quot;MY_DIRECT_EXCHANGE&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">declared-by</span>=<span class="string">&quot;connectAdmin&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;MY_FIRST_QUEUE&quot;</span> <span class="attr">key</span>=<span class="string">&quot;FirstKey&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;amqpTemplate&quot;</span> <span class="attr">exchange</span>=<span class="string">&quot;$&#123;exchange&#125;&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageReceiver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.consumer.FirstConsumer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">&quot;MY_FIRST_QUEUE&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageReceiver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://files.luyanan.com//img/20200109111942.png"></p><h3 id="3-4-SpringBoot集成RabbitMQ"><a href="#3-4-SpringBoot集成RabbitMQ" class="headerlink" title="3.4 SpringBoot集成RabbitMQ"></a>3.4 SpringBoot集成RabbitMQ</h3><p>在SpringBoot工程中, 为什么没有定义Spring AMQP的任何一个对象, 也能实现消息的收发? SpringBoot 做了什么? </p><p>我们这里模拟: </p><p>​    3个交换机与4个队列绑定. 4个消费者分别监听4个队列. </p><p>​    生产者发送4条消息,4个队列收到5条消息. 消费者打印出5条消息. </p><h4 id="3-4-1-配置文件"><a href="#3-4-1-配置文件" class="headerlink" title="3.4.1  配置文件"></a>3.4.1  配置文件</h4><p> 定义交换机、队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.rabbitspring.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String direct_exchange = <span class="string">&quot;DIRECT_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicexchange = <span class="string">&quot;topicexchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String fanoutexchange = <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String firstqueue = <span class="string">&quot;first_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String secondqueue = <span class="string">&quot;second_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String thirdqueue = <span class="string">&quot;third_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String fourthqueue = <span class="string">&quot;fourth_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(direct_exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(topicexchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(fanoutexchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  创建四个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">firstqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(firstqueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">secondqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(secondqueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">thirdqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(thirdqueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fourthqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(fourthqueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义绑定关系</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">firstBind</span><span class="params">(<span class="meta">@Qualifier(&quot;firstqueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;directExchange&quot;)</span> DirectExchange directExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(<span class="string">&quot;best&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">secondBind</span><span class="params">(<span class="meta">@Qualifier(&quot;secondqueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;topicExchange&quot;)</span> TopicExchange topicExchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(topicExchange).with(<span class="string">&quot;*.test.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">threadBind</span><span class="params">(<span class="meta">@Qualifier(&quot;thirdqueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">fourthBind</span><span class="params">(<span class="meta">@Qualifier(&quot;fourthqueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">        factory.setAutoStartup(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-2-消费者"><a href="#3-4-2-消费者" class="headerlink" title="3.4.2 消费者"></a>3.4.2 消费者</h4><p>这里定义4个消费者分别消费4个队列的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.rabbitspring.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = RabbitConfig.firstqueue, containerFactory = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First queue received msg:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他消费者类似</p><h4 id="3-4-3-生产者配置文件"><a href="#3-4-3-生产者配置文件" class="headerlink" title="3.4.3  生产者配置文件"></a>3.4.3  生产者配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.rabbitspring.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-4-生产者发送消息"><a href="#3-4-4-生产者发送消息" class="headerlink" title="3.4.4 生产者发送消息"></a>3.4.4 生产者发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.rabbitspring.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String directroutingkey = <span class="string">&quot;java.best&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String topicroutingkey1 = <span class="string">&quot;shanghai.test.teacher&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String topicroutingkey2 = <span class="string">&quot;changsha.test.student&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitConfig.direct_exchange, <span class="string">&quot;direct msg&quot;</span>, <span class="string">&quot;北京市&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(topicroutingkey1, <span class="string">&quot;topic msg: shanghai.test.teacher&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(topicroutingkey2, <span class="string">&quot;topic msg: changsha.test.student&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String value = mapper.writeValueAsString(map);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitConfig.fanoutexchange, <span class="string">&quot;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-SpringBoot-参数解析"><a href="#3-5-SpringBoot-参数解析" class="headerlink" title="3.5 SpringBoot 参数解析"></a>3.5 SpringBoot 参数解析</h3><p><a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/common-application-properties.html">https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/common-application-properties.html</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a></p><blockquote><p>注: 前缀spring.rabbitmq 全部省略</p></blockquote><p>全部配置总体上分为三类: 连接类、消息消费类、消息发送类. </p><blockquote><p>基于SpringBoot 2.1.5</p></blockquote><table><thead><tr><th>属性值</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>addres</td><td>客户端连接的地址, 有多个的时候可以使用逗号分隔,该地址可以是ip和port的结合</td><td></td></tr><tr><td>host</td><td>RabbitMQ的主机地址</td><td>localhost</td></tr><tr><td>port</td><td>RabbitMQ的端口号</td><td></td></tr><tr><td>virtual-host</td><td>连接到 RabbitMQ 的虚拟主机</td><td></td></tr><tr><td>username</td><td>登录到 RabbitMQ 的用户名</td><td></td></tr><tr><td>password</td><td>登录到 RabbitMQ 的密码</td><td></td></tr><tr><td>ssl.enabled</td><td>启动SSL 支持</td><td>false</td></tr><tr><td>ssl.key-store</td><td>保存SSL证书的地址</td><td></td></tr><tr><td>ssl.key-store-password</td><td>·访问SSL证书的地址使用的密码</td><td></td></tr><tr><td>ssl.trust-store</td><td>SSL的可信地址</td><td></td></tr><tr><td>ssl.trust-store-password</td><td>访问SSL可信地址的密码</td><td></td></tr><tr><td>ssl.algorithm</td><td>SSL算法, 默认使用Rabbit 的客户端算法库</td><td></td></tr><tr><td>cache.channel.checkout-timeout</td><td>当缓存已满的时候, 获取Channel 的等待时间,单位为毫秒</td><td></td></tr><tr><td>cache.channel.size</td><td>缓存中保存的channel 的数量</td><td></td></tr><tr><td>cache.connection.mode</td><td>连接缓存的模式</td><td>CHANNEL</td></tr><tr><td>cache.connection.size</td><td>缓存的连接数</td><td></td></tr><tr><td>connnection-timeout</td><td>连接超时参数单位为毫秒,设置为0代表无穷大</td><td></td></tr><tr><td>dynamic</td><td>默认创建一个AmqpAdmin的Bean</td><td>true</td></tr><tr><td>listener.simple.acknowledge-mode</td><td>容器的acknowledge模式</td><td></td></tr><tr><td>listener.simple.auto-startup</td><td>启动的时候自动启动容器</td><td>true</td></tr><tr><td>listener.simple.concurrency</td><td>消费者的最小数量</td><td></td></tr><tr><td>listener.simple.default-requeue-rejected</td><td>投递消息失败时是否重新排队</td><td>true</td></tr><tr><td>listener.simple.max-concurrency</td><td>消费者的最大数量</td><td></td></tr><tr><td>listener.simple.missing-queues-fata</td><td>容器上声明的队列不可用时是否失败</td><td></td></tr><tr><td>listener.simple.prefetch</td><td>在当个请求中处理的消息个数,它应该大于等于事务数量</td><td></td></tr><tr><td>listener.simple.retry.enabled</td><td>无论是不是重试的发布</td><td>false</td></tr><tr><td>listener.simple.retry.initial-interval</td><td>第一次投递和第二次投递尝试的时间间隔</td><td>1000ms</td></tr><tr><td>listener.simple.retry.max-attempts</td><td>尝试投递消息的最大数量</td><td>3</td></tr><tr><td>listener.simple.retry.max-interval</td><td>两次尝试的最大时间间隔</td><td>10000ms</td></tr><tr><td>listener.simple.retry.multiplier</td><td>上一次尝试时间间隔的乘数</td><td>1.0</td></tr><tr><td>listener.simple.retry.stateless</td><td>重试是有状态的还是无状态的</td><td>true</td></tr><tr><td>listener.simple.transaction-size</td><td>在一个事务中处理的消息数量,为了获取最佳消化, 该值应设置为小于等于每个请求中处理的消息个数,即listener.prefetch 的值</td><td></td></tr><tr><td>publisher-confirms</td><td>开启 Publisher Confirm 值</td><td></td></tr><tr><td>publisher-returns</td><td>开启Publisher Return机制</td><td></td></tr><tr><td>template.mandatory</td><td>启动强制信息</td><td>false</td></tr><tr><td>template.receive-timeout</td><td>receive() 方法的超时时间</td><td>0</td></tr><tr><td>template.reply-timeout</td><td>sendAndReceive() 方法的超时时间</td><td>5000</td></tr><tr><td>template.retry.enabled</td><td>设置为true的时候RabbitTemplate 能够实现重试</td><td>false</td></tr><tr><td>template.retry.initial-interval</td><td>第一次发布与第二次发布消息的时间间隔</td><td>1000</td></tr><tr><td>template.retry.max-attempts</td><td>尝试发布消息的最大数量</td><td>3</td></tr><tr><td>template.retry.max-interval</td><td>尝试发布消息的最大时间间隔</td><td>10000</td></tr><tr><td>template.retry.multiplier</td><td>上一次尝试时间间隔的乘数</td><td>1.0</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;3-Spring-AMQP&quot;&gt;&lt;a href=&quot;#3-Spring-AMQP&quot; class=&quot;headerlink&quot; title=&quot;3. Spring AMQP&quot;&gt;&lt;/a&gt;3. Spring AMQP&lt;/h2&gt;&lt;h3 id=&quot;3-1-Spring-AMQP-介绍&quot;&gt;&lt;a href=&quot;#3-1-Spring-AMQP-介绍&quot; class=&quot;headerlink&quot; title=&quot;3.1 Spring AMQP 介绍&quot;&gt;&lt;/a&gt;3.1 Spring AMQP 介绍&lt;/h3&gt;&lt;p&gt;思考： &lt;/p&gt;
&lt;p&gt;Java API 方式编程, 有什么问题? &lt;/p&gt;
&lt;p&gt;Spring 封装RabbitMQ的时候, 它做了什么呢? &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%BC%96%E7%A8%8B(1)/"/>
    <id>http://luyanan.com/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%BC%96%E7%A8%8B(1)/</id>
    <published>2021-03-01T09:46:52.832Z</published>
    <updated>2020-12-24T09:34:50.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ工作模型与java编程"><a href="#RabbitMQ工作模型与java编程" class="headerlink" title="RabbitMQ工作模型与java编程"></a>RabbitMQ工作模型与java编程</h1><h2 id="1-MQ入门"><a href="#1-MQ入门" class="headerlink" title="1. MQ入门"></a>1. MQ入门</h2><h3 id="1-1-MQ的诞生历程"><a href="#1-1-MQ的诞生历程" class="headerlink" title="1.1 MQ的诞生历程"></a>1.1 MQ的诞生历程</h3><p>我们要去用MQ, 先来了解一下MQ是怎么诞生的,这样对于它解决了什么问题理解会更加深刻.大家知不知道世界上第一个MQ叫什么名字,是什么时候诞生的? </p><p>​    1983年的时候, 有个在MIT工作的印度小伙伴突发奇想,以前我们的软件相互通信,都是点对点的,而且要实现相同的协议, 能不能有一种专门用来通信的中间件,就想主板(BUS)一样,把不同的软件集成起来呢? 于是它搞了一家公司(Tekneron),开发了世界上第一个消息队列软件The Information Bus(TIB). 最开始的时候, 它被高盛这些公司用在了金融交易里面。 因为TIB 实现了发布订阅(Publish/Subscrbe)模型, 信息的生产者和消费者完全解耦,这个特性引起了电信行业特别是新闻机构的注意. 1994年路透社收购了Teknekron. </p><p><img src="http://files.luyanan.com//img/20200107105026.png"></p><p> TIB 的成功马上引起了业界大佬IBM的注意, 他们研发了自己的IBM MQ(IBM Wesphere). 后面微软也加入了这场战斗, 研发了MSMQ. 这个时候,每个厂商的产品是孤立的. 大家都有自己的技术壁垒. 比如一个应用订阅了IBM MQ的消息, 如果又要订阅MSMQ的消息, 因为协议、API不同,又要重复去实现,为什么大家都不愿意去创建标准接口,来实现不同的MQ产品的互通呢? 跟现在微信里面不能打开淘宝页面是一个道理(商业竞争).</p><p>​    JDBC 协议大家非常熟悉吧? J2EE 制定了JDBC的规范,那么各个数据库厂商自己去实现协议, 提供jar, 在java里面即可以使用相同的API做操作不同的数据库了. MQ产品的问题也是一样的，2001年的时候,SUM公司发布了JMS 规范,它想要在各大厂商的MQ上面统一包装一层java 的规范,大家都只需要针对API变成就可以了,不需要关注使用了什么样的消息中间件,只要选择合适的MQ驱动.但是JMS 只适用于java语言,它是跟语言绑定的,没有从根本上解决这个问题(只是一个API)。</p><p>​    所以在06年的时候,AMQP规范发布了.它是跨语言和跨平台的, 真正的促进了消息队列的繁荣发展. </p><p>​    07年的时候, Rabbit技术公司基于AMQP 开发了BabbitMQ 1.0.为什么要用Erlang语言呢? 因为Erlang 是作者Matthias 擅长的开发语言. 第二个家就是Erlang是为了电话交换机编写的语言, 天生适合分布式和高并发. </p><p><img src="http://files.luyanan.com//img/20200107113557.png"></p><p>​    为什么要取Rabbit Technologies 这个名字呢? 因为兔子跑得快，而且繁殖起来很疯狂. </p><p>​    从最开始用于金融行业里面,现在RabbitMQ 已经在世界各地的公司中遍地开花. 国内的绝大部分大厂都在用BabbitMQ，包括头条、美团、滴滴、去哪儿、艺龙、淘宝等. </p><h4 id="1-1-2-什么是MQ-Message-Queue"><a href="#1-1-2-什么是MQ-Message-Queue" class="headerlink" title="1.1.2 什么是MQ(Message Queue)"></a>1.1.2 什么是MQ(Message Queue)</h4><p> MQ的本质是什么呢? </p><p>​    消息队列,又叫消息中间件.是指用高效可靠的消息传递机制进行与平台无关的数据交流,并基于数据通信来进行分布式系统的集成. 通过提供消息传递和消息队列模型,可以在分布式坏境下扩展进程的通信(维基百科).</p><p>​    基于以上的描述(MQ是用来解决通信的问题), 我们知道, MQ的几个主要特点: </p><ol><li>是一个独立运行的服务。生产者发送消息,消费者接受消息, 需要先跟服务器建立连接. </li><li>采用队列作为数据结构,有先进先出的特点. </li><li>具有发布订阅的模型,消费者可以获取自己需要的消息. </li></ol><p>​    <img src="http://files.luyanan.com//img/20200107135046.png"></p><p>​    我们可以把RabbitMQ比喻成邮局和邮差, 它是用来帮我们存储和转发消息的. </p><p>   问题: 如果仅仅是解决消息消费的问题, java里面已经有了那么多的队列的实现,为什么不用他们了呢? 这个问题的答案就跟有了HashMap 之后, 为什么还要Redis 作缓存是一样的. </p><p><img src="http://files.luyanan.com//img/20200107135232.png"></p><p>因为Queue 不能跨进程, 不能在分布系统中使用,并且没有持久化机制等等. </p><h4 id="1-1-3-为什么要使用MQ呢"><a href="#1-1-3-为什么要使用MQ呢" class="headerlink" title="1.1.3 为什么要使用MQ呢?"></a>1.1.3 为什么要使用MQ呢?</h4><p>​    我们已经知道MQ是什么了, 那在什么地方可以用MQ,或者说，为什么要使用MQ呢? 这是一个很常见的面试题,如果你的项目中使用了MQ,还不知道这个问题的答案,说明你自己从来没有思考总结过,因为这个项目是别人架构设计的,你可能只是做了一些维护的工作.有一天你自己去做架构的时候, 你搞一个MQ进去,理由就是以前的项目也是这么干的,这就很危险了.</p><h5 id="1-1-3-1-实现异步通信"><a href="#1-1-3-1-实现异步通信" class="headerlink" title="1.1.3.1 实现异步通信"></a>1.1.3.1 实现异步通信</h5><p>​    同步的通信的什么样呢?</p><p>  发出一个调用请求后, 在没有得到结果之前, 就不返回. 由调用者主动等待这个调用的结果.</p><p>   而异步是相反的, 调用在发出之后, 这个调用就直接返回了, 所以没有返回结果. 也就是说, 当一个异步过程调用发出后, 调用者不会马上得到结果.而是在调用发出后, 被调用者通过状态, 通知来通知调用者,或通过回调函数来处理这个调用.</p><p>​    <img src="http://files.luyanan.com//img/20200107135909.png"></p><p><img src="http://files.luyanan.com//img/20200107135921.png"></p><p>举个例子:</p><p>   大家都用过手机银行的跨行转账功能。大家用APP的转账功能 的时候, 有一个实时模式, 有一个非实时模式. </p><p>​    实时转账实际上是异步通信, 因为这里面涉及的机构比较多, 调用链路比较长, 本行做了一系列处理之后, 转发给银联或者人民银行的支付系统,再转发给接受行, 接受行处理以后再原路返回. </p><p>​    所以转账以后会有一行小字提示: 具体到账时间以对方行处理为准. 也就是说转出行只保证这个转账的消息发出。那为什么到账时间又那么快呢? 很多时间我们转账之后, 不用几秒钟对方就收到了,是因为大部分的MQ都有一个低延迟的特性, 能够在短时间内处理非常多的消息. </p><p>​     很多理财软件体现也是一样的, 先提交申请, 到账时间不定. 这个是用MQ实现系统间异步通信的一个场景. </p><h5 id="1-1-3-2-实现系统解耦"><a href="#1-1-3-2-实现系统解耦" class="headerlink" title="1.1.3.2 实现系统解耦"></a>1.1.3.2 实现系统解耦</h5><p>​    第二个主要的功能是用来实现系统解耦.既然说到解耦,那我们先来了解一下耦合的概念. </p><p>​    耦合是系统内部或者系统之间存在相互作用,相互影响和相互依赖. </p><p>​    在我们的分布式系统中, 一个业务流程涉及到多个系统的时候, 他们之间就会形成一个依赖关系. </p><p>​    <img src="http://files.luyanan.com//img/20200107140915.png"></p><p>   比如我们以12306网站退票为例,在传统的通信方式中, 订单系统发生了退货的动作, 那么要依次调用所有下游系统的API,比如调用库存系统的API恢复库存,因为这张火车票还要释放出去给其他乘客购买;调用支付系统的API,不管是支付宝还是微信还是银行卡,要把手续费扣掉之后, 原路返回给消费者. 调用通知系统API通知用户退货成功. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">stockService.updateInventory ();</span><br><span class="line">payService.refund();</span><br><span class="line">noticeService.notice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个过程是串行执行的, 如果在恢复库存的时候发生了异常, 那么后面的代码都不会执行. 由于这一系列的动作, 恢复库存、资金退还、发送通知,本质上没有一个严格的先后顺序,也没有直接的依赖关系, 也就是说, 只要用户提交了退货的请求, 后面的这些动作都是要完成的.库存有没有恢复成功, 不影响资金的退还和发送通知. </p><p>​    如果把串行改成并行, 我们有什么思路?</p><p>​    (多线程）</p><p>   多线程或者线程池是可以实现的, 但是每一个需要并行执行的地方都引入线程,又会带来线程或者线程池的管理问题. </p><p>​    所以, 这种情况下, 我们可以引入MQ实现系统之间依赖关系的解耦合. </p><p>​    引入MQ后: </p><p>​                    <img src="http://files.luyanan.com//img/20200107141930.png"></p><p>​    订单系统只需要把退货的消息发送到消息队列上, 由各个下游的业务系统自己创建队列, 然后监听队列消费消息. </p><p>​    在这种情况下,订单系统里面不需要配置其他系统的IP、端口号、接口地址了. 因为它不需要关心消费者在网络上的什么位置, 所以下游系统该IP没有任何影响. 甚至不需要关系消费者有没有消费成功, 它只需要把消费者发到消息队列的服务器上就可以了. </p><p>​    这样, 我们就实现了系统之间依赖关系的解耦. </p><h5 id="1-1-3-3-实现流量削峰"><a href="#1-1-3-3-实现流量削峰" class="headerlink" title="1.1.3.3  实现流量削峰"></a>1.1.3.3  实现流量削峰</h5><p>​    第三个主要的功能是,实现流量削峰. </p><p>   在很多的电商系统里面, 有一个瞬间流量达到峰值的情况, 比如京东的618、淘宝的双11、小米抢购.普通的硬件服务器肯定支撑不了这种百万或者千万级别的并发量, 就像2012年的小米一样, 动不动就服务器崩溃. </p><p>​    如果通过堆硬件的方式去解决, 那么在流量峰值过去之后就会出现巨大的资源浪费, 那要怎么办呢? 如果说要保护我们的应用服务器和数据库, 限流也是可以的,但是这样又会导致订单的丢失, 没有达到我们的目的. </p><p>​    为了解决这个问题, 我们就可以引入MQ,MQ既然的队列, 一定有队列特性，我们知道队列的特定是什么?</p><blockquote><p> 先入先出(FIFO)</p></blockquote><p>​    这样我们就可以先把所有的流量都承接下来, 转换成MQ消息发送到消息队列服务器上, 业务层就可以根据自己的消费速率去处理这些消息,处理完成后再返回结果.就像我们在火车站排队一样, 大家只能一个一个单独买票,不会因为人多就导致售票员忙不过来. 如果要处理的快一点, 大不了多开几个窗口(增加几个消费者).</p><p>​     这个是我们利用MQ实现流量削峰的一个案例. </p><p>总结起来: </p><ul><li> 对于数据量大或者处理耗时长的操作, 我们可以引入MQ实现异步通信, 减少客户端的等待, 提升响应速度. </li><li>对于改动影响大的系统之间, 可以引入MQ实现解耦, 减少系统之间的直接依赖. </li><li>对于会出现瞬间的流量峰值的系统, 我们可以引入MQ实现流量削峰, 达到保护应用和数据库的目的. </li></ul><p>​    所以对于一些特定的业务场景, MQ对于优化我们的系统还是有很大的帮助的, 那么大家想一下, 把传统的RPC通信改成MQ通信会不会带来一些问题呢? </p><h4 id="1-1-4-实现消息队列带来的问题"><a href="#1-1-4-实现消息队列带来的问题" class="headerlink" title="1.1.4 实现消息队列带来的问题"></a>1.1.4 实现消息队列带来的问题</h4><p>​    系统可用性降低: 原来是两个节点的通信, 现在还需要独立运行一个服务,如果MQ 服务器或者通信网络出现一些问题, 就会导致请求失败. </p><p>​    系统复杂度提高: 为什么说复杂, 第一个就是你必须理解相关的模型和概念,才能正确的配置和使用MQ.第二个就是使用MQ发送消息必须要考虑消息丢失和消息重复消息的问题. 一旦消费没有被正确的消费,就会带来数据一致性问题. </p><p>​    所以我们在做系统架构的时候一定要根据实际情况来分析, 不要因为我们说了这么多MQ能解决的问题, 就盲目的引入MQ.</p><h3 id="1-2-RabbitMQ-简介"><a href="#1-2-RabbitMQ-简介" class="headerlink" title="1.2 RabbitMQ 简介"></a>1.2 RabbitMQ 简介</h3><h4 id="1-2-1-基本特性"><a href="#1-2-1-基本特性" class="headerlink" title="1.2.1 基本特性"></a>1.2.1 基本特性</h4><p>   官网: <a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><ul><li><strong>高可靠:</strong> RabbitMQ提供了多种多样的特性让你在可靠性和性能之间做出权衡, 包括持久化、发送应答、发布确认以及高可用性. </li><li><strong>灵活的路由:</strong> 通过交换机(Exchange) 实现消息的灵活路由. </li><li><strong>支持多客户端:</strong> 对主流开发语言(Python、Java、Ruby、C#、JavaScript、GO、Elixir、Objective-C、Swift等) 都有客户端实现</li><li><strong>集群和扩展性:</strong> 多个节点组成一个逻辑的服务器, 实现负载均衡. </li><li><strong>高可用队列:</strong> 通过镜像队列实现队列中数据的复制. </li><li><strong>权限管理:</strong> 通过用户与虚拟机实现权限管理. </li><li><strong>插件系统:</strong> 支持各种丰富的插件扩展,同时也支持自定义插件.</li><li><strong>与Spring集成:</strong> Spring 对AMQP 进行了封装. </li></ul><h4 id="1-2-2-AMQP协议"><a href="#1-2-2-AMQP协议" class="headerlink" title="1.2.2 AMQP协议"></a>1.2.2 AMQP协议</h4><h5 id="1-2-2-1-总体介绍"><a href="#1-2-2-1-总体介绍" class="headerlink" title="1.2.2.1 总体介绍"></a>1.2.2.1 总体介绍</h5><p><a href="http://www.amqp.org/sites/amqp.org/files/amqp.pdf">http://www.amqp.org/sites/amqp.org/files/amqp.pdf</a></p><p>AMQP: 高级消息队列协议, 是一个工作于应用层的协议, 最新的版本是1.0版本. </p><p><img src="http://files.luyanan.com//img/20200107145823.png"></p><p>​    除了RabbitMQ之外, AMQP的实现还有 OpenAMQ、Apache Qpid、Redhat Enterprise MRG、AMQP Infrastructure 、ØMQ、Zyre。</p><p>​    除了AMQP之外, RabbitMQ支持多种协议. STOMP、MQTT、HTTP 和Websocket. </p><p>​    可以使用 WireShark 等工具对 RabbitMQ 通信的 AMQP 协议进行抓包。</p><h5 id="1-2-2-2-工作模型"><a href="#1-2-2-2-工作模型" class="headerlink" title="1.2.2.2 工作模型"></a>1.2.2.2 工作模型</h5><p>由于RabbitMQ 实现了AMQP协议, 所以BabbitMQ 的工作模式也是基于AMQP 的. 理解这种图片至关重要. </p><p><img src="http://files.luyanan.com//img/20200107150655.png"></p><h6 id="1-Broker"><a href="#1-Broker" class="headerlink" title="1. Broker"></a>1. Broker</h6><p>​     我们要使用RabbitMQ 来收发消息, 必须安装一个RabbitMQ的服务, 可以安装在window上也可以安装在linux上, 默认是5672端口号。这台BabbitMQ 的服务器我们把它叫做Broker, 中文翻译是代理/中介. 因为MQ 服务器帮助我们做的事情就是存储、转发消息.</p><h6 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h6><p>​     无论是生产者发送消息或者消费者接收消息, 都必须要跟broker 之间建立一个连接, 这个连接是一个TCP的长连接. </p><h6 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h6><p>​    如果所有的生产者发送消息和消费者接收消息, 都直接创建和释放TCP连接的话, 对于Broker 来说肯定会造成很大的性能损耗,因为TCP 连接是非常宝贵的资源,创建和释放也要消耗时间. </p><p>​    所有在AMQP 里面引入了Channel 的概念,它是一个虚拟的连接.我们把它翻译成通道,或者消费信道. 这样我们就可以在保持的TCP长连接里面去创建和释放Channel, 大大减少了资源消耗. 另外一个需要注意的是,Channel 是RabbitMQ 原生API里面最重要的编程接口,也就是我们定义交换机、队列、绑定关系、发送消息、消费消息,调用的都是Channel 接口上的方法. </p><p>​    <a href="https://stackoverflow.com/questions/18418936/rabbitmq-and-relationship-between-channel-and-connection">https://stackoverflow.com/questions/18418936/rabbitmq-and-relationship-between-channel-and-connection</a></p><h6 id="4-Queue"><a href="#4-Queue" class="headerlink" title="4. Queue"></a>4. Queue</h6><p>​    现在我们已经连接到Broker了, 可以收发消息了.在其他一些MQ里面,比如ActiviteMQ和Kafka, 我们的消息都是发送到队列上. </p><p>​    队列是真正用来存储消息的, 是一个独立运行的进程, 有自己的数据库(Mnesia).</p><p>​    消费者获取消息的模式有两种模式,一种是push模式, 只要生产者发到服务器上, 就马上推送到消费者. 另一个是pull模式, 消息存放在服务端, 只有消费端主动获取才能拿到消息. 消费者需要写 一个while循环不断的从队列获取消息吗? 不需要,我们可以基于事件机制,实现消费者对队列的监听. </p><p>​    由于队列有FIFO的特性, 只有确定前一条消息被消费者接收之后, 才会把这条消息从数据库删除,继续投递下一条消息. </p><h6 id="5-Exchange"><a href="#5-Exchange" class="headerlink" title="5. Exchange"></a>5. Exchange</h6><p>​    在RabbitMQ 里面永远不会出现消息直接发送到队列的情况. 因为在AMQP 里面引入了交换机(Exchange) 的概念, 用来实现消息的灵活路由. </p><p>​    交换机是一个绑定列表, 用来查找匹配的绑定关系. </p><p>​    队列使用绑定建(Binging Key) 跟交换机建立绑定关系. </p><p>​    生产者发送的消息需要携带路由键(Routing Key), 交换机收到消息时会会根据它保存到绑定列表,决定将消息路由到哪些与他绑定的队列上. </p><p>​    注意: 交换机与队列、队列与消费者都是多对多的关系. </p><h6 id="6-Vhost"><a href="#6-Vhost" class="headerlink" title="6. Vhost"></a>6. Vhost</h6><p>​    我们每个需要实现基于RabbitMQ的异步通信系统, 都需要在服务器上创建自己要用到的交换机、队列和他们的绑定关系. 如果某个业务系统不想跟别人混用一个系统,怎么办?  再采购一台硬件服务器单独安装一个RabbitMQ 服务? 这种方式成本太高了. 在同一个硬件服务器上安装多个BabbitMQ的服务呢? 比如再运行一个5673的端口? 没有必要,因为RabbitMQ 提供了虚拟主机Vhost. </p><p>​    Vhost 除了可以提高硬件资源的利用率之外, 还可以实现资源的隔离和权限的控制.它的作用类似于编程语言中的namespace 和package,不同的Vhost 中可以有同名的Exchange 和Queue, 他们是完全透明的. </p><p>​    这个时候,我们可以为不同的业务系统创建不同的用户(User), 然后给这些用户分给Vhost权限.比如给风控系统的用户分配风控系统的Vhost的权限, 这个用户就可以访问里面的交换机和队列. 给超级管理员分配所有Vhost 的权限. </p><p>​    我们说到RabbitMQ 引入Exchange 是为了实现消息的灵活路由,到底有哪些路由方式呢? </p><h5 id="1-2-2-3-路由方式"><a href="#1-2-2-3-路由方式" class="headerlink" title="1.2.2.3 路由方式"></a>1.2.2.3 路由方式</h5><h6 id="直连Direct"><a href="#直连Direct" class="headerlink" title="直连Direct"></a>直连Direct</h6><p>​    队列与直连的交换机绑定,需指定一个精确的绑定键.</p><p>​     生产者发送消息时会携带一个路由键.只有当路由键与其中的某个绑定键完全匹配的时候,这条消息才会从交换机路由到满足路由关系的此队列上. </p><p><img src="http://files.luyanan.com//img/20200107162455.png"></p><blockquote><p>例如: channel.basicPublish(“MY_DIRECT_EXCHANGE”,”spring”,”msg 1”); 只有第一个队列能收到消息</p></blockquote><h6 id="主题Topic"><a href="#主题Topic" class="headerlink" title="主题Topic"></a>主题Topic</h6><p>队列与主图类型的交换机绑定时, 可以在绑定键中使用通配符.两个通配符:</p><ul><li><code>#</code> 0个或者多个单词</li><li><code>*</code> 不多不少一个单词</li></ul><p>单词(word) 指的是用英文的点 “.” 隔开的字符. 例如 <code>abc.def</code> 是两个单词. </p><p><img src="http://files.luyanan.com//img/20200107163142.png"></p><p> 解析: 第一个队列支持路由键以 <code>spring</code>开头的消息路由, 后面可以有单词, 也可以没有. </p><p>​         第二个队列支持路由键以<code>netty</code> 开头,  而且后面是一个单词的消息路由. </p><p>​         第三个队列支持路由键以<code>mysql</code> 结尾, 而且前面是一个单词的消息路由. </p><blockquote><p>例如: </p><p>channel.basicPublish(“MY_TOPIC_EXCHANGE”,”spring.fjd.klj”,”msg 2”); 只有 第一个队列能收到消息。 channel.basicPublish(“MY_TOPIC_EXCHANGE”,”spring.jvm”, “msg 3”); 第 一 个队列和第三个队列能收到消息。</p></blockquote><h6 id="广播Fanout"><a href="#广播Fanout" class="headerlink" title="广播Fanout"></a>广播Fanout</h6><p>​    主题类型的交换机与队列绑定的时候,不需要指定绑定键. 因此生产者发送消息到广播类型的交换机上, 也不需要携带路由键. 消息达到交换机的时候, 所有与之绑定了的队列, 都会收到相同的消息的副本. </p><p>​    <img src="http://files.luyanan.com//img/20200107165221.png"></p><blockquote><p>例如: channel.basicPublish(“MY_FANOUT_EXCHANGE”, “”, “msg 4”); 三个队列都会 收到 msg 4。</p></blockquote><h3 id="1-3-基本使用"><a href="#1-3-基本使用" class="headerlink" title="1.3 基本使用"></a>1.3 基本使用</h3><h4 id="1-3-1-安装"><a href="#1-3-1-安装" class="headerlink" title="1.3.1  安装"></a>1.3.1  安装</h4><p>这里使用Docker 进行安装</p><ol><li><p>获取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定版本，该版本包含了web控制页面</span></span><br><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure></li><li><p>运行镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式一：默认guest 用户，密码也是 guest</span></span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式二：设置用户名和密码</span></span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:manageent </span><br></pre></td></tr></table></figure></li><li><p>访问url</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:15672&#x2F;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-3-2-Java-API编程"><a href="#1-3-2-Java-API编程" class="headerlink" title="1.3.2 Java API编程"></a>1.3.2 Java API编程</h4><h5 id="1-3-2-1-添加依赖"><a href="#1-3-2-1-添加依赖" class="headerlink" title="1.3.2.1  添加依赖"></a>1.3.2.1  添加依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-2-生产者"><a href="#1-3-2-2-生产者" class="headerlink" title="1.3.2.2 生产者"></a>1.3.2.2 生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq.rabbit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;生产者&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;交换机&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;SIMPLE_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 连接ip</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.86.128&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//定义虚拟机</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建消息通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;Hello World  -&gt;&quot;</span> + i;</span><br><span class="line">            <span class="comment">//  String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;test&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-3-2-3-消费者"><a href="#1-3-2-3-消费者" class="headerlink" title="1.3.2.3 消费者"></a>1.3.2.3 消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mq.rabbit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;消费者&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;交换机&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">&quot;SIMPLE_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;队列&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2020/1/8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SIMPLE_QUEUE = <span class="string">&quot;SIMPLE_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 连接ip</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.86.128&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//定义虚拟机</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建消息通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// String exchange, String type, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line"><span class="comment">// String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(SIMPLE_QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for message...&quot;</span>);</span><br><span class="line">        <span class="comment">// 绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(SIMPLE_QUEUE, EXCHANGE_NAME, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received message : &#x27;&quot;</span> + msg + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag : &quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;deliveryTag : &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 开始获取消息</span></span><br><span class="line">            channel.basicConsume(SIMPLE_QUEUE, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-3-2-4-参数详解"><a href="#1-3-2-4-参数详解" class="headerlink" title="1.3.2.4  参数详解"></a>1.3.2.4  参数详解</h5><ol><li><p>声明交换机</p><ul><li>String  type: 交换机的类型,direct、topic、fanout 中的一种. </li><li>boolean durable: 是否持久化,代表交换机在服务器重启后是否还存在</li></ul></li><li><p>声明队列的参数</p><ul><li><p>boolean durable: 是否持久化,代表队列在服务器重启后是否还存在. </p></li><li><p>boolean exclusive: 是否排他性队列. 排他性队列只能声明它的<code>connection</code> 中使用(可以在同一个connection的不同channel中使用),连接断开时自动删除. </p></li><li><p>boolean autoDelete: 是否自动删除. 如果为true, 至少有一个消费者连接到这个队列,之后所有与这个队列连接的消费者都断开时, 队列会自动删除. </p></li><li><p>Map&lt;String,Object&gt; arguments: 队列中的其他属性., 例如<img src="http://files.luyanan.com//img/20200108101236.png"></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>x-message-ttl</td><td>队列中消息的存活时间, 单位是毫秒</td></tr><tr><td>x-expires</td><td>队列在多久没消费者访问以后会被删除</td></tr><tr><td>x-max-length</td><td>队列的最大消息数</td></tr><tr><td>x-max-length-bytes</td><td>队列的最大容量, 单位Byte</td></tr><tr><td>x-dead-letter-exchange</td><td>队列的死信交换机</td></tr><tr><td>x-dead-letter-routing-key</td><td>死信交换机的路由键</td></tr><tr><td>x-max-priority</td><td>队列中消息的最大优先级,消息的优先级不能超过它</td></tr></tbody></table></li></ul></li><li><p>消息属性 BasicProperties</p><p> 以下列举了一些主要的参数</p><p><img src="http://files.luyanan.com//img/20200108101800.png"></p></li></ol><table><thead><tr><th>参数</th><th>释义</th></tr></thead><tbody><tr><td>Map&lt;String,Object&gt; headers</td><td>消息的其他自定义参数</td></tr><tr><td>Integer deliveryMode</td><td>2 持久化,其他: 瞬态</td></tr><tr><td>Integer priority</td><td>消息的优先级</td></tr><tr><td>String correlationId</td><td>关联ID,方便RPC相应的与请求关联</td></tr><tr><td>String replyTo</td><td>回调队列</td></tr><tr><td>String expiration</td><td>TTL,消息过期时间, 单位毫秒</td></tr></tbody></table><h4 id="1-3-3-UI管理界面的使用"><a href="#1-3-3-UI管理界面的使用" class="headerlink" title="1.3.3 UI管理界面的使用"></a>1.3.3 UI管理界面的使用</h4><p>​    RabbitMQ可以通过命令(RabbitMQ Cli)、HTTP API管理, 也可以通过可视化的界面去管理,这个网页就是managment 插件. </p><h5 id="1-3-3-1-启用管理插件"><a href="#1-3-3-1-启用管理插件" class="headerlink" title="1.3.3.1 启用管理插件"></a>1.3.3.1 启用管理插件</h5><ol><li><p>Windows启动管理插件</p><blockquote><p>cd C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.6\sbin</p><p>rabbitmq-plugins.bat enable rabbitmq_management</p></blockquote></li><li><p>Linux 启动管理插件</p><blockquote><p>cd /usr/lib/rabbitmq/bin ./rabbitmq-plugins enable rabbitmq_management</p></blockquote></li></ol><h5 id="1-3-3-2-管理界面访问端口"><a href="#1-3-3-2-管理界面访问端口" class="headerlink" title="1.3.3.2 管理界面访问端口"></a>1.3.3.2 管理界面访问端口</h5><p>​    默认端口号为15672, 默认用户是guest,密码是 guest</p><p>​    guest 用户默认只能在本地访问,远程用户需要创建其他的用户. </p><h5 id="1-3-3-3-虚拟机"><a href="#1-3-3-3-虚拟机" class="headerlink" title="1.3.3.3  虚拟机"></a>1.3.3.3  虚拟机</h5><p> 在Admin 选项卡中</p><p><img src="http://files.luyanan.com//img/20200108103842.png"></p><p>默认的虚拟机是/,可以创建自定义的虚拟机</p><h5 id="1-3-3-4-Linux-创建RabbitMQ-用户、权限"><a href="#1-3-3-4-Linux-创建RabbitMQ-用户、权限" class="headerlink" title="1.3.3.4 Linux 创建RabbitMQ 用户、权限"></a>1.3.3.4 Linux 创建RabbitMQ 用户、权限</h5><p>假如创建用户 admin，密码 admin,授权访问所有的vhost</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=15672/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">rabbitmqctl add_user admin admin</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-RabbitMQ-进阶知识"><a href="#2-RabbitMQ-进阶知识" class="headerlink" title="2.RabbitMQ 进阶知识"></a>2.RabbitMQ 进阶知识</h2><h3 id="2-1-TTL-Time-To-Live"><a href="#2-1-TTL-Time-To-Live" class="headerlink" title="2.1 TTL(Time To Live)"></a>2.1 TTL(Time To Live)</h3><h4 id="2-1-1-消息的过期时间"><a href="#2-1-1-消息的过期时间" class="headerlink" title="2.1.1  消息的过期时间"></a>2.1.1  消息的过期时间</h4><p> 有两种设置方式: </p><ol><li><p>通过队列属性设置消息过期时间</p><p> 所有队列中的消息超过时间未被消费, 都会过期. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;ttlQueue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">ttlQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列中的消息未被消费10秒后过期</span></span><br><span class="line">    map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 队列30秒没有使用以后会被删除</span></span><br><span class="line">    map.put(<span class="string">&quot;x-expire&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;TTL_QUEUE&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置单条消息的过期时间</p><p>在发送消息的时候指定消息属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(TtlSender.class);</span><br><span class="line">      RabbitAdmin rabbitAdmin = applicationContext.getBean(RabbitAdmin.class);</span><br><span class="line">      RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">      MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">      <span class="comment">// 消息的过期属性(单位ms)</span></span><br><span class="line">      messageProperties.setExpiration(<span class="string">&quot;4000&quot;</span>);</span><br><span class="line">      messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">      Message message = <span class="keyword">new</span> Message(<span class="string">&quot;这条消息4秒后过期&quot;</span>.getBytes(), messageProperties);</span><br><span class="line">      rabbitTemplate.send(<span class="string">&quot;TTL_EXCHANGE&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message);</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 随队列的过期时间属性,单位ms</span></span><br><span class="line">      rabbitTemplate.convertAndSend(<span class="string">&quot;TTL_EXCHANGE&quot;</span>, <span class="string">&quot;ttl&quot;</span>, <span class="string">&quot;这条消息&quot;</span>);</span><br></pre></td></tr></table></figure><p>同时指定了Message TTL 和Queue TTL,则小的那个时间生效. </p></li></ol><h3 id="2-2-死信队列"><a href="#2-2-死信队列" class="headerlink" title="2.2 死信队列"></a>2.2 死信队列</h3><h4 id="2-2-1-消息在某些情况下会变成死信-Dead-letter"><a href="#2-2-1-消息在某些情况下会变成死信-Dead-letter" class="headerlink" title="2.2.1  消息在某些情况下会变成死信(Dead letter)"></a>2.2.1  消息在某些情况下会变成死信(Dead letter)</h4><p>   队列在创建的时候可以指定一个死信交换机DLX(Dead Letter Exchange).死信交换机绑定的队列被为死信队列DLQ(Dead Letter Queue),DLX 实际上也就是普通的交换机,DLQ 也是普通的队列(例如替补球员也是普通的球员). </p><p>​    <img src="http://files.luyanan.com//img/20200108113112.png"></p><h4 id="2-2-2-什么情况下会变成死信"><a href="#2-2-2-什么情况下会变成死信" class="headerlink" title="2.2.2 什么情况下会变成死信?"></a>2.2.2 什么情况下会变成死信?</h4><ol><li>消息被消费者拒绝并且未设置重回队列: (NACK || Reject ) &amp;&amp; requeue == false</li><li>消息过期.</li><li>队列达到最长长度,超过了Max Length(消息数) 或者Max Length Bytes (字节数), 最先入队的消息会被发送到</li></ol><h4 id="2-2-3-死信队列如何使用"><a href="#2-2-3-死信队列如何使用" class="headerlink" title="2.2.3 死信队列如何使用"></a>2.2.3 死信队列如何使用</h4><h5 id="2-2-3-1-声明原交换机-原队列相互绑定"><a href="#2-2-3-1-声明原交换机-原队列相互绑定" class="headerlink" title="2.2.3.1 声明原交换机,原队列相互绑定"></a>2.2.3.1 声明原交换机,原队列相互绑定</h5><p>​    队列中的消息10秒后过期,因为没有消费者,会变成死信。指定原队列的死信交换机 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ORI_USER_EXCHANGE = <span class="string">&quot;ORI_USER_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ORI_USER_QUEUE = <span class="string">&quot;ORI_USER_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  死信交换机</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEAD_LETTER_EXCHANGE = <span class="string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私信队列</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;DEAD_LETTER_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(&quot;oriUserExchange&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(ORI_USER_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(&quot;oriUserQueue&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>); <span class="comment">// 10 秒钟后成为死信</span></span><br><span class="line">      map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>); <span class="comment">// 队列中的消息变成死信后，进入死信交换机</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(ORI_USER_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(<span class="meta">@Qualifier(&quot;oriUserQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;oriUserExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;ori.user&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h5 id="2-2-3-2-声明死信交换机、死信队列-相互绑定"><a href="#2-2-3-2-声明死信交换机、死信队列-相互绑定" class="headerlink" title="2.2.3.2 声明死信交换机、死信队列, 相互绑定"></a>2.2.3.2 声明死信交换机、死信队列, 相互绑定</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">deadLetterExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(DEAD_LETTER_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;deadLetterQueue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bingDead</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> TopicExchange topicExchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无条件路由</span></span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(topicExchange).with(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-2-3-3-最终消费者监听死信队列"><a href="#2-2-3-3-最终消费者监听死信队列" class="headerlink" title="2.2.3.3  最终消费者监听死信队列"></a>2.2.3.3  最终消费者监听死信队列</h5><h5 id="2-2-3-4-生产者发送消息"><a href="#2-2-3-4-生产者发送消息" class="headerlink" title="2.2.3.4 生产者发送消息"></a>2.2.3.4 生产者发送消息</h5><p><img src="http://files.luyanan.com//img/20200108140243.png"></p><h3 id="2-3-延迟队列"><a href="#2-3-延迟队列" class="headerlink" title="2.3 延迟队列"></a>2.3 延迟队列</h3><p>​    我们在实际业务中有一些需要延迟发送消息的场景,例如:</p><ol><li>家里有一台智能热水器,需要在30分钟后启动</li><li>未付款的订单, 15分钟后关闭. </li></ol><p>RabbitMQ 本身不支持延时队列,总的来说有三种实现方案: </p><ol><li>先存储到数据库, 用定时任务扫描. </li><li>利用RabbitMQ的死信队列(Dead Letter Queue) 实现. </li><li>利用<code>rabbitmq-delayed-message-exchange</code> 插件. </li></ol><h4 id="2-3-1-TTL-DLX-的实现"><a href="#2-3-1-TTL-DLX-的实现" class="headerlink" title="2.3.1 TTL + DLX 的实现"></a>2.3.1 TTL + DLX 的实现</h4><p> 基于消息TTL,我们来看一下如何利用死信队列(DLQ) 实现延迟队列</p><p> 总体步骤: </p><ol><li>创建一个交换机</li><li>创建一个队列,与上述交换机绑定,并且通过属性指定队列的死信交换机. </li><li>创建一个死信交换机</li><li>创建一个死信队列</li><li>将死信交换机绑定到死信队列</li><li>消费者监听死信队列.</li></ol><p>​    消息的流转流程: </p><p>   生产者-&gt; 原交换机-&gt; 原队列(超过TTL之后)-&gt; 死信交换机-&gt; 死信队列-&gt; 最终消费者. </p><p><strong>使用死信队列实现延迟消息的缺点:</strong></p><ol><li>如果统一用队列来设置消息的TTL,当梯度非常多的情况下, 比如1分钟、2分钟、5分钟、10分钟、20分钟、30分钟… 需要创建很多交换机和队列来路由消息. </li><li>如果单独设置消息的TTL, 则可能造成队列中的消息阻塞,前一条消息没有出队(没有被消费), 后面的消息无法投递(比如前一条消息的过期TTL是30min, 第二条消息的TTL 是10min. 10min后, 即使第二条消息应该投递了,但是由于第一条消息还未出队,所以无法投递)</li><li>可能存在一定的时间误差</li></ol><h4 id="2-3-2-基于延迟队列插件的实现-linux"><a href="#2-3-2-基于延迟队列插件的实现-linux" class="headerlink" title="2.3.2 基于延迟队列插件的实现(linux)"></a>2.3.2 基于延迟队列插件的实现(linux)</h4><p>​    在RabbitMQ  3.5.7 以及以后的版本提供了一个插件(<code>rabbitmq-delayed-message-exchange</code>) 来实现延迟队列功能. 同时插件依赖 Erlang/OPT 18.0以及以上. </p><p>​    插件源码地址: </p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p><p>插件下载地址: </p><p><a href="https://bintray.com/rabbitmq/community-plugins/rabbitmq_delayed_message_exchange">https://bintray.com/rabbitmq/community-plugins/rabbitmq_delayed_message_exchange</a></p><h5 id="2-3-2-1-进入插件目录"><a href="#2-3-2-1-进入插件目录" class="headerlink" title="2.3.2.1 进入插件目录"></a>2.3.2.1 进入插件目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis rabbitmq </span><br><span class="line"><span class="built_in">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.12/plugins</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-2-2-下载插件"><a href="#2-3-2-2-下载插件" class="headerlink" title="2.3.2.2 下载插件"></a>2.3.2.2 下载插件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget</span><br><span class="line">https://bintray.com/rabbitmq/community-plugins/download_file?file_path=rabbitmq_delayed_message_exchange-0.0.1.ez</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv download_file?file_path=rabbitmq_delayed_message_exchange-0.0.1.ez</span><br><span class="line">rabbitmq_delayed_message_exchange-0.0.1.ez</span><br></pre></td></tr></table></figure><p><img src="http://files.luyanan.com//img/20200108142813.png"></p><h5 id="2-3-2-3-启动插件"><a href="#2-3-2-3-启动插件" class="headerlink" title="2.3.2.3 启动插件"></a>2.3.2.3 启动插件</h5><blockquote><p>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p></blockquote><h5 id="2-3-2-4-停用插件"><a href="#2-3-2-4-停用插件" class="headerlink" title="2.3.2.4 停用插件"></a>2.3.2.4 停用插件</h5><blockquote><p>rabbitmq-plugins disable rabbitmq_delayed_message_exchange</p></blockquote><h5 id="2-3-2-5-插件的使用"><a href="#2-3-2-5-插件的使用" class="headerlink" title="2.3.2.5 插件的使用"></a>2.3.2.5 插件的使用</h5><p>​    通过声明一个<code>x-delayed-message</code> 类型的Exchange来使用<code>delayed-messaging</code> 特性. <code>x-delayed-message</code> 是插件提供的类型,并不是rabbitmq本身的(区别与direct、topic、fanout、headers).</p><p><img src="http://files.luyanan.com//img/20200108151743.png"></p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  死信交换机</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEAD_LETTER_EXCHANGE = <span class="string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私信队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;DEAD_LETTER_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(DEAD_LETTER_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>, map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p> 生产者: </p><p>​    消息属性中指定 <code>x-delay</code> 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(TtlSender.class);</span><br><span class="line">        RabbitAdmin rabbitAdmin = applicationContext.getBean(RabbitAdmin.class);</span><br><span class="line">        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟的间隔时间, 目标时间减去当前时刻</span></span><br><span class="line">        messageProperties.setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="string">&quot;目标时刻&quot;</span> - System.currentTimeMillis());</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;这条消息4秒后过期&quot;</span>.getBytes(), messageProperties);</span><br><span class="line">        rabbitTemplate.send(<span class="string">&quot;DELAY_EXCHANGE&quot;</span>, <span class="string">&quot;#&quot;</span>, message);</span><br></pre></td></tr></table></figure><h3 id="2-4-服务端流控-Flow-Control"><a href="#2-4-服务端流控-Flow-Control" class="headerlink" title="2.4 服务端流控(Flow Control)"></a>2.4 服务端流控(Flow Control)</h3><p><a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a></p><p><a href="https://www.rabbitmq.com/flow-control.html">https://www.rabbitmq.com/flow-control.html</a></p><p><a href="https://www.rabbitmq.com/memory.html">https://www.rabbitmq.com/memory.html</a></p><p><a href="https://www.rabbitmq.com/disk-alarms.html">https://www.rabbitmq.com/disk-alarms.html</a></p><p>​    当RabbitMQ 生产MQ消息的速度远大于消费消息的速度时,会产生大量的消息堆积, 占用系统资源, 导致机器的性能下降. 我们想要控制服务端接受消息的数量, 应该怎么做呢? </p><p>​    队列有两个控制长度的属性:</p><ul><li><p>x-max-length： 队列中最大存储最大消息数, 超过这个数量, 队头的消息会被丢弃. </p></li><li><p>x-max-length-bytes: 队列中存储的最大消息容量(单位bytes), 超过这个容量, 队头的消息会被丢弃. </p></li></ul><p><img src="http://files.luyanan.com//img/20200108155125.png"></p><p>需要注意的是: 设置队列长度只能消息堆积的情况下有意思,而且会删除先入队的消息,不能真正的实现服务端限流. </p><p>​    有没有其他办法实现服务端限流吗? </p><h4 id="2-4-1-内存控制"><a href="#2-4-1-内存控制" class="headerlink" title="2.4.1 内存控制"></a>2.4.1 内存控制</h4><p>​    RabbitMQ 会在启动时检测机器的物理内存数值.默认当MQ 占用40%以上内存时, MQ会主动抛出一个内存警告并阻塞所有连接(Connections). 可以通过修改rabbitmq.config 文件来调整内存阈值,默认值是0.4,如下所示: </p><blockquote><p>[{rabbit, [{vm_memory_high_watermark, 0.4}]}].</p></blockquote><p>​    也可以用命令动态设置,如果设置为0, 则所有的消息都不能发布. </p><blockquote><p>rabbitmqctl set_vm_memory_high_watermark 0.3</p></blockquote><h4 id="2-4-2-磁盘控制"><a href="#2-4-2-磁盘控制" class="headerlink" title="2.4.2 磁盘控制"></a>2.4.2 磁盘控制</h4><p>​    另一种方式是通过磁盘来控制消息的发布. 当磁盘空间低于指定的值时(默认50MB)，触发流控措施. </p><p>​    例如: 指定为磁盘的30% 或者2GB.</p><p><a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a></p><blockquote><p>disk_free_limit.relative = 3.0</p><p> disk_free_limit.absolute = 2GB</p></blockquote><h3 id="2-5-消费端限流"><a href="#2-5-消费端限流" class="headerlink" title="2.5 消费端限流"></a>2.5 消费端限流</h3><p><a href="https://www.rabbitmq.com/consumer-prefetch.html">https://www.rabbitmq.com/consumer-prefetch.html</a></p><p>​    默认情况下, 如果不进行配置, RabbitMQ 会尽可能的把队列中的消息发送到消费者. 因为消费者会在本地缓存消息, 如果消息数量过多,可能回导致OOM 或者影响其他进程的正常运行. </p><p>​    在消费者处理能力有限, 例如消费者数量太少, 或者单条消息的处理时间过长的情况下, 如果我们希望在一定数量的消息消费完之前, 不再推送消息过来, 就要用到消费段的流量控制措施. </p><p>​    可以基于Consumer 或者channel 设置<code>prefetch count</code>的值,含义为 Consumer 端的最大的<code>unacked messages</code> 数目. 当超过这个数值的消息未被确认, RabbitMQ 会停止投递新的消息给该消费者. </p><blockquote><p>channel.basicQos(2); // 如果超过 2 条消息没有发送 ACK，当前消费者不再接受队列消息 channel.basicConsume(QUEUE_NAME, false, consumer);</p></blockquote><p>SimpleMessageListenerContainer</p><blockquote><p>container.setPrefetchCount(2);</p></blockquote><p>SpringBoot 配置</p><blockquote><p>spring.rabbitmq.listener.simple.prefetch=2</p></blockquote><p>举例: channel 的 <code>prefetch count</code> 设置为5, 当消费者有5条消息没有给Broker 发送ACK后, RabbitMQ 不再给这个消费者投递消息. </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RabbitMQ工作模型与java编程&quot;&gt;&lt;a href=&quot;#RabbitMQ工作模型与java编程&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ工作模型与java编程&quot;&gt;&lt;/a&gt;RabbitMQ工作模型与java编程&lt;/h1&gt;&lt;h2 id=&quot;1-MQ入门&quot;&gt;&lt;a href=&quot;#1-MQ入门&quot; class=&quot;headerlink&quot; title=&quot;1. MQ入门&quot;&gt;&lt;/a&gt;1. MQ入门&lt;/h2&gt;&lt;h3 id=&quot;1-1-MQ的诞生历程&quot;&gt;&lt;a href=&quot;#1-1-MQ的诞生历程&quot; class=&quot;headerlink&quot; title=&quot;1.1 MQ的诞生历程&quot;&gt;&lt;/a&gt;1.1 MQ的诞生历程&lt;/h3&gt;&lt;p&gt;我们要去用MQ, 先来了解一下MQ是怎么诞生的,这样对于它解决了什么问题理解会更加深刻.大家知不知道世界上第一个MQ叫什么名字,是什么时候诞生的? &lt;/p&gt;
&lt;p&gt;​    1983年的时候, 有个在MIT工作的印度小伙伴突发奇想,以前我们的软件相互通信,都是点对点的,而且要实现相同的协议, 能不能有一种专门用来通信的中间件,就想主板(BUS)一样,把不同的软件集成起来呢? 于是它搞了一家公司(Tekneron),开发了世界上第一个消息队列软件The Information Bus(TIB). 最开始的时候, 它被高盛这些公司用在了金融交易里面。 因为TIB 实现了发布订阅(Publish/Subscrbe)模型, 信息的生产者和消费者完全解耦,这个特性引起了电信行业特别是新闻机构的注意. 1994年路透社收购了Teknekron. &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/RabbitMQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    <id>http://luyanan.com/RabbitMQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/</id>
    <published>2021-03-01T09:46:52.820Z</published>
    <updated>2020-12-24T09:34:50.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ可靠性投递和实践经验"><a href="#RabbitMQ可靠性投递和实践经验" class="headerlink" title="RabbitMQ可靠性投递和实践经验"></a>RabbitMQ可靠性投递和实践经验</h1><h2 id="1-可靠性投递"><a href="#1-可靠性投递" class="headerlink" title="1. 可靠性投递"></a>1. 可靠性投递</h2><p>在RabbitMQ里面提供了很多保证可靠投递的机制, 这也是RbabitMQ的一个特性. </p><p>​    我们在讲可靠性投递的时候,必须要明确一个问题,因为效率与可靠性是无法兼得的, 如果要保证每一个环节都成功, 势必会对消息的收发效率造成影响. 所以如果是一些业务实时一致性不是特别高的场景, 可以牺牲一些可靠性换取效率. </p><p>​    比如发送通知或者记录日志的这种场景, 如果用户没有收到通知,不会造成业务影响,只要再次发送就可以了. </p><p>​    我们再来回顾一下RabbitMQ的工作模型 </p><p><img src="http://files.luyanan.com//img/20200109155845.png"></p><p>   在我们使用RabbitMQ 收发消息的时候, 有几个主要环节:</p><ol><li><p>代表消息从生产者发送Broker, 生产者把消息发到Broker 之后, 怎么知道自己的消息有没有被Broker 成功接收呢? </p></li><li><p>代表消息从Exchange 路由到Queue  </p><p>  Exchange 是一个绑定列表,如果消息没有办法路由到正确的队列,会发生什么事情? 怎么处理呢? </p></li><li><p>代表消息在Queue 中存储. </p><p> 队列是一个独立运行的服务,有自己的数据库(Mnesina),它是真正用来存储消息的. 如果还没有消费者来消息, 那么消息要一直存储到队列里面. 如果队列出了问题, 消息肯定会丢失. 怎么保证消息在队列稳定的存储呢? </p></li><li><p>代表消费者订阅Queue 并消费消息呢? </p><p>  队列的特性是什么? FOFI. 队列里面的消息是一条一条投递的,也就是说, 只有上一条消息被消费者接收以后, 才能把这一条消息从数据库删除,继续投递下一条消息. 那么问题来了, Broker 怎么知道消费者已经接收到了消息呢? </p></li></ol><h3 id="1-1-消息发送到RabbitMQ-服务器"><a href="#1-1-消息发送到RabbitMQ-服务器" class="headerlink" title="1.1 消息发送到RabbitMQ 服务器"></a>1.1 消息发送到RabbitMQ 服务器</h3><p>​     第一个环节是生产者发送消息到Broker. 可能以为网络或者Broker 的问题导致消息发送失败,生产者不能确定Broker 有没有正常的接收. </p><p>​    在RabbitMQ 里面提供了两种机制 服务端确认机制,也就是在生产者发送消息给RabbitMQ的服务端的时候, 服务端会通过某种方式返回一个应答,只要生产者收到了这个应答, 就知道消息发送成功了. </p><p>​    第一种是Transaction(事务),第二种Confirm(确认)模式。 </p><h4 id="1-1-1-Transaction-事务-模式"><a href="#1-1-1-Transaction-事务-模式" class="headerlink" title="1.1.1 Transaction(事务)模式"></a>1.1.1 Transaction(事务)模式</h4><p>​    事务模式怎么使用呢? </p><p>  我们通过一个channel.txSelect() 的方法把信道设置成事务模式,然后就可以发布消息给RabbitMQ了,如果<code>channel.txCommit()</code> 方法调用成功, 就说明事务提交成功, 则消息一定达到了RabbitMQ中. </p><p>​    如果在事务提交执行以前由于RabbitMQ 异常崩溃或者其他原因导致抛出异常, 这个时候我们便可以将其捕获, 进而通过执行<code>channel.txRollback()</code> 方法来实现事务回滚. </p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, KeyManagementException, URISyntaxException, IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setUri(RabbitMQConfig.rabbitMQUrl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    <span class="comment">//创建消息通道</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;TRANSACTION_QUEUE&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.txSelect();</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;TRANSACTION_QUEUE&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        channel.txCommit();</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        channel.txRollback();</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送失败, 回滚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="http://files.luyanan.com//img/20200110093320.png"></p><p>​                                    AMQP 协议抓包示意</p><p>​    在事务模式里面, 只有收到了服务器端的<code>Commit-OK</code>的指令, 才能提交成功. 所以可以解决生产者和服务端确认的问题. 但是事务模式有一个特点, 它是阻塞的, 一条消息没有发送完毕,不能发送下一条消息,它会榨干RabbitMQ服务器的性能. 所以不建议大家在生产环境中使用. </p><p>​    SpingBoot 中的配置</p><blockquote><p>rabbitTemplate.setChannelTransacted(true);</p></blockquote><p>​    那么有没有其他可以保证消息被Broker 接收,但是又不大量消耗性能的方式呢? 这个就是第二种模式, 叫做确认(Confirm)模式. </p><h4 id="Confirm-确认-模式"><a href="#Confirm-确认-模式" class="headerlink" title="Confirm(确认)模式"></a>Confirm(确认)模式</h4><p>​    确认模式有三种, 一种是普通确认模式. </p><p>​    这生产者这边通过调用 <code>channel.confirmSelect()</code> 方法将信道设置为Confirm 模式, 然后发送消息. 一旦消息被投递到所有匹配的队列之后, RabbitMQ就会发送一个确认(Basic.ACK) 给生产者,也就是调用 <code>channel.waitForConfirms()</code> 返回true, 这样生产者就知道消息被服务端接受了. </p><p>​    这种发送一条消息确认一条消息的方式效率还是不太高,所以我们还有一种批量确认的方式. 批量确认就是在开启Confirm 模式后, 只要<code>channel.waitForConfirmsOrDie();</code> 方法没有抛出异常,就代表哦消息都被服务端接受了. </p><p>​    批量确认的方式比单条确认的方式效率要高,但是也有两个问题,第一个就是批量的数量的确认,对于不同的业务, 到底发送多少条消息确认一次? 数量太少, 效率提升不上去. 数量多的话, 又会带来另外一个问题. 比如我们发1000条消息才确认一次, 如果前面999条消息都被服务端接受了,如果第1000条消息被拒绝了,那么前面所有的消息都要被重发. </p><p>   有没有一种方式,可以一边发送一边确认呢? 这个就是异步的确认模式. </p><p>​    异步确认模式需要添加一个<code>ConfirmListener</code>, 并且用一个<code>SortedSet</code> 来维护没有被确认的消息. </p><p>​    Confirm 模式是在Channel 上开启的,因为<code>RabbitTemplate</code> 对Channel 进行封装,叫做<code>ConfimrCallback</code>.</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;发送消息失败：&quot;</span> + cause);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;发送异常：&quot;</span> + cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2-消息从交换机路由到队列"><a href="#1-2-消息从交换机路由到队列" class="headerlink" title="1.2 消息从交换机路由到队列"></a>1.2 消息从交换机路由到队列</h3><p>​    第二个环节就是消息从交换机路由到队列. 在什么情况下, 消息会无法路由到正确的队列呢? 可能是因为路由键错误或者队列不存在. </p><p>​    我们这里有两种方式处理无法路由的消息,一种就是让服务端重发给生产者, 一种是让交换机路由到另一个备份的交换机,</p><p>   消息回发的方式: 使用mandatory 参数和 ReturnListener（在 Spring AMQP 中是 ReturnCallback）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;回发的消息：&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;replyCode: &quot;</span>+replyCode);</span><br><span class="line">System.out.println(<span class="string">&quot;replyText: &quot;</span>+replyText);</span><br><span class="line">System.out.println(<span class="string">&quot;exchange: &quot;</span>+exchange);</span><br><span class="line">System.out.println(<span class="string">&quot;routingKey: &quot;</span>+routingKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>   消息路由到备份交换机的方式,在创建交换机的时候, 从属性中指定备份交换机. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;alternate-exchange&quot;</span>,<span class="string">&quot;ALTERNATE_EXCHANGE&quot;</span>); <span class="comment">// 指定交换机的备份交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;TEST_EXCHANGE&quot;</span>,<span class="string">&quot;topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br></pre></td></tr></table></figure><blockquote><p> 注意区别: 队列可以指定死信交换机,交换机可以指定备份交换机. </p></blockquote><h3 id="1-3-消息在队列中存储"><a href="#1-3-消息在队列中存储" class="headerlink" title="1.3 消息在队列中存储."></a>1.3 消息在队列中存储.</h3><p>   第三个环节是消息对队列中存储,如果没有消费者的话,队列一直存在在数据库中. </p><p>​    如果RabbitMQ 的服务或者硬件发生故障,比如系统宕机、重启、关闭等等, 可能会导致内存中的消息丢失, 所以我们要本消息本身和元数据(队列、交换机、绑定) 都保存到磁盘</p><p>解决方案:</p><h4 id="1-3-1-队列持久化"><a href="#1-3-1-队列持久化" class="headerlink" title="1.3.1 队列持久化"></a>1.3.1 队列持久化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;Queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// queueName, durable, exclusive, autoDelete, Properties</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;TEST_QUEUE&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-交换机持久化"><a href="#1-3-2-交换机持久化" class="headerlink" title="1.3.2 交换机持久化"></a>1.3.2 交换机持久化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;Exchange&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// exchangeName, durable, exclusive, autoDelete, Properties</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;TEST_EXCHANGE&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-消息持久化"><a href="#1-3-3-消息持久化" class="headerlink" title="1.3.3 消息持久化"></a>1.3.3 消息持久化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">&quot;持久化消息&quot;</span>.getBytes(), messageProperties);</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;TEST_EXCHANGE&quot;</span>, <span class="string">&quot;test&quot;</span>, message);</span><br></pre></td></tr></table></figure><h4 id="1-3-4-集群"><a href="#1-3-4-集群" class="headerlink" title="1.3.4 集群"></a>1.3.4 集群</h4><p>如果只有一个RabbitMQ的节点, 即使交换机、队列、消息做了持久化, 如果服务崩溃或者硬件发生故障,RabbitMQ 的服务一样是不可用的, 所以为了提高MQ服务的可用性, 保障消息的传输, 我们需要有多个RabbitMQ 的节点 . </p><h3 id="1-4-消息投递到消费者"><a href="#1-4-消息投递到消费者" class="headerlink" title="1.4 消息投递到消费者"></a>1.4 消息投递到消费者</h3><p>​    如果消费者受到消息后没来得及处理即发生异常,或者处理过程中发生了异常, 会导致失败。 服务端应该以某种方式得知消费者对消息的接收情况,并决定是否重新投递这条消息给其他消费者. </p><p>​    RabbitMQ 提供了消费者的消息确认机制(message acknowledgement), 消费者可以自动或者手动的发送ACK 给服务端. </p><p>​    没有收到ACK 的消息, 消费者断开连接后, RabbitMQ 会把这条消息发送给其他消费者, 如果没有其他消费者, 消费者重启后会重新消费这条消息,重复执行业务逻辑. </p><p>​    消费者在订阅队列时,可以指定 <code>autoAck</code>参数, 当<code>autoAck</code> 参数等于false的时候, RabbitMQ 会等待消费者显式的回复确认信号后才从队列中移除消息. </p><p>​    如何设置手动Ack? </p><p>​    SimpleRabbitListenerContainer 或者 SimpleRabbitListenerContainerFactory</p><blockquote><p>factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</p></blockquote><p><code>application.peroperties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.listener.direct.acknowledge-mode</span>=<span class="string">manual</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br></pre></td></tr></table></figure><p>注意这三个值的区别:</p><ul><li>NONE: 自动ACK</li><li>MANUAL: 手动ACK</li><li>AUTO: 如果方法未抛出异常,则发送ACK</li></ul><p>当抛出<code>AmqpRejectAndDontRequeueException</code> 异常的时候,则消息会被拒绝, 则不重新入队. 当抛出<code>ImmediateAcknowledgeAmqpException</code> 异常, 则消费者会发送ACK, 其他的异常,则消息会拒绝, 且 <code>requeue=true</code> 会重新入队. </p><p>在SpringBoot 中, 消费者又怎么调用ACK,或者说怎么获得Cahnenl 的参数呢? </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondConsumer</span> </span>&#123;</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msgContent,Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Second Queue received msg : &quot;</span> + msgContent );</span><br><span class="line">channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     如果消息无法处理或者消费失败, 也有两种拒绝的方式,<code>Basic.Reject()</code> 拒绝单条, <code>Basic.Nack()</code> 批量拒绝. 如果<code>requeue</code> 参数设置为true ,可以把这条消息重新存入队列, 以便发给下一个消费者(当然, 只有一个消费者的时候, 这种方式可能会出现无限循环重复消费的情况, 可以投递到新的队列或者只打印异常日志).</p><p>​    思考: 服务端收到了ACK 或者Nack , 生产者会知道吗? 即使消费者没有接受到消息, 或者消费时出现了异常,生产者也是完全不知情的. </p><p>​    例如: 我们寄出去一个快递，是怎么知道收件人有没有收到的? 因为有物流追踪和签收反馈,所以寄件人可以知道. </p><p>   在没有用上电话的年代, 我们寄出去一封信, 是怎么知道收信人有没有收到信件? 只有收到回信,才知道寄出去的信被收到了. </p><p>   所以,这个是生产者最终确定消费者有没有消费成功的两种方式: </p><ol><li>消费者收到消息,处理完毕后, 调用生产者的API</li><li>消费者收到消息, 处理完毕后, 发送一条响应给生产者. </li></ol><h3 id="1-5-消费者回调"><a href="#1-5-消费者回调" class="headerlink" title="1.5 消费者回调"></a>1.5 消费者回调</h3><h4 id="1-5-1-调用生产者API"><a href="#1-5-1-调用生产者API" class="headerlink" title="1.5.1 调用生产者API"></a>1.5.1 调用生产者API</h4><p>​    例如: 提单系统给其他系统分别发送了碎屏保信息后， 其他系统必须在处理完消息后调用提单系统提供的API,来修改提单系统中的数据. 只要API没有被调用,数据状态没有被修改,提单系统就认为下游系统没有收到这条消息. </p><h4 id="1-5-2-发送响应消息给生产者"><a href="#1-5-2-发送响应消息给生产者" class="headerlink" title="1.5.2 发送响应消息给生产者"></a>1.5.2 发送响应消息给生产者</h4><p>​    例如：商业银行与人民银行二代支付通信, 无论是人行收到了商业银行的消息还是商业银行收到了人行的消息, 都必须发送一条响应消息(叫做回执报文)。 </p><p><img src="http://files.luyanan.com//img/20200110140724.png"></p><h3 id="1-6-补偿机制"><a href="#1-6-补偿机制" class="headerlink" title="1.6  补偿机制"></a>1.6  补偿机制</h3><p>   如果生产者的API就是没有被调用, 也就是没有收到消费者的响应消息, 怎么办? </p><p>​    不要着急, 可能是消费者处理时间太长或者网络超时. </p><p>​    生产者与消费者之间应该约定一个超时时间,比如5分钟,对于超过这个时间没有得到响应的消息, 可以设置一个定时重发的机制, 但是要控制发送的间隔和控制次数, 比如每隔2分钟发送一次, 最多重发三次,否则会造成消息堆积. </p><p>   重发可以通过消息落库+定时任务来实现. </p><p>​    重发, 是否发送一模一样的消息. </p><p>​    ATM机上运行的系统叫C端(ATMC),前置系统叫P端(ATMP), 它接受ATMC 的消息, 再转发给卡系统或者核心系统. </p><pre><code>- 如果客户存款, 没有收到核心系统的应答, 不知道有没有记账成功,最多发送5条存款确认报文, 因为已经吞钞了, 所以要保证成功. - 如果客户取款, ATMC未得到应答,最多发送5次存款冲正报文, 因为没有吐钞, 所以要保证失败。</code></pre><h3 id="1-7-消息幂等性"><a href="#1-7-消息幂等性" class="headerlink" title="1.7 消息幂等性"></a>1.7 消息幂等性</h3><p>​    如果消费者每一个接收生产者的消息都成功了, 只是在响应或者调用API的时候出了问题, 会不会出现消息的重复处理? 例如: 存款100元,ATM重发了5次, 核心系统一共处理了6次,余额会增加了600元. </p><p>​    所以, 为了避免相同消息的重复处理, 必须要采取一定的措施,RabbitMQ 服务端是没有这种控制的(同一批的消息有个递增的DeliveryTag), 它不知道你是不是就是要把一条消息发送两次, 只能在消费端控制. </p><p>​    如何避免消息的重复消费? </p><p>​    消息出现重复可能会有两个原因:</p><ol><li><p>生产者的问题,环节1重复发送消息, 比如在开启了Confirm 模式但未收到确认,消费者重复投递. </p></li><li><p>环节4出现了问题, 由于消费者未发送ACK 或者其他原因, 消息重复投递. </p></li><li><p>生产者代码或者网络问题 . </p><p>对于重复发送的消息, 可以对每一条消息生成一个唯一的业务ID, 通过日志或者消息落库来做重复控制. </p></li></ol><h3 id="1-8-最终一致"><a href="#1-8-最终一致" class="headerlink" title="1.8 最终一致"></a>1.8 最终一致</h3><p>​    如果确实是消费者宕机了或者代码出现了BUG 导致无法正常消息, 在我们尝试多次重发以后, 消息最终也没有得到处理,怎么办? </p><p>​    例如存款的场景, 客户的钱已经被吞了, 但是余额没有增加, 这个时候银行出现了脏款, 应该怎么处理呢? 如果客户没有主动通知银行, 这个问题是怎么发现的? 银行最终是怎么把这个账务做平的?</p><p>   在我们的金融系统中, 都会有双方对账或者多放对账的操作, 通常是在一天的业务结束之后, 第二天营业之前. 我们会约定一个标准, 比如ATM 跟核心系统对账, 肯定是以核心系统为准.ATMC 获取到核心的对账文件, 然后解析,登记成数据, 然后跟自己记录的流水比较, 找出核心有, ATM没有的, 或者ATM有,核心没有的. 或者两边都有大那是金额不一致的数据. </p><p>   对账以后,我们再手工平账.比如取款记了账但是没吐钞的, 做一笔冲正.存款吞了钞但是没记账的, 那么把钱退给客户, 要么补一笔账. </p><h3 id="1-9-消息的顺序性"><a href="#1-9-消息的顺序性" class="headerlink" title="1.9 消息的顺序性"></a>1.9 消息的顺序性</h3><p>  消息的顺序性指的是消费者消费消息的顺序跟生产者生产消息的顺序是一致的. </p><p>   例如:商户信息同步到其他系统,有三个业务操作: 1. 新增门店 2: 绑定产品； 3: 激活门店. 这种情况下消息消费顺序不能颠倒(门店不存在时无法绑定产品和激活). </p><p>   又比如: 1. 发送微博 2:发表评论;3:: 删除微博,  顺序不能颠倒. </p><p>   在RabbitMQ 中, 一个队列有多个消费者时，由于不同的消费者消费消息的速度是不一样的, 顺序无法保证。 只有一个队列仅有一个消费者的情况下才能保证顺序消费(不同的业务消息发送到不同的专用队列上).</p><h2 id="2-集群和高可用"><a href="#2-集群和高可用" class="headerlink" title="2  集群和高可用"></a>2  集群和高可用</h2><h3 id="2-1-为什么要做集群"><a href="#2-1-为什么要做集群" class="headerlink" title="2.1 为什么要做集群?"></a>2.1 为什么要做集群?</h3><p>​    集群主要用以实现高可用于负载均衡. </p><ul><li>高可用: 如果集群中的某些MQ 服务器不可用, 客户端还可以连接其他MQ 服务器. </li><li>负载均衡: 在高并发的场景下, 单台MQ 服务器能处理的消息是有限的. 可以分发给多台MQ服务器. </li></ul><p>​    RabbitMQ 有两种集群模式: 普通集群模式和镜像队列模式. </p><h3 id="2-2-RabbitMQ-如何支持集群"><a href="#2-2-RabbitMQ-如何支持集群" class="headerlink" title="2.2 RabbitMQ 如何支持集群?"></a>2.2 RabbitMQ 如何支持集群?</h3><p>   应用做集群,需要面对数据同步和通信的问题.因为Erling天生具备分布式的特性, 所以RabbitMQ 天然支持集群, 不需要通过引入ZK或者数据库来实现数据同步. </p><p>  RabbitMQ  通过<code>/var/lib/rabbitmq/.erlang.cookie</code> 来验证身份, 需要在所有节点上保持一致. </p><h3 id="2-3-RabbitMQ的节点类型"><a href="#2-3-RabbitMQ的节点类型" class="headerlink" title="2.3 RabbitMQ的节点类型?"></a>2.3 RabbitMQ的节点类型?</h3><p> 集群有两种节点类型,一种是磁盘节点(Disc Node),一种是内存节点(RAM Node). </p><ul><li>磁盘节点 : 将元数据(包括队列名称属性、交换机的类型名字属性、绑定、vhost)放在磁盘中. </li><li>内存节点: 将元数据放在内存中. </li></ul><blockquote><p>内存节点会将磁盘节点下的地址存放在磁盘中(不然重启就没办法同步数据了), 如果是持久化的消息, 会同时存在在内存和磁盘</p><p>集群中至少需要一个磁盘节点来持久化元数据,否则全部内存节点崩溃时, 就无法同步元数据. 未指定类型的情况下, 默认为磁盘节点. </p><p>我们一般把应用连接到内存节点(读写快), 磁盘节点用来备份. </p></blockquote><p> 集群通过25672 端口两两通信, 需要开放防火墙的端口. </p><p>需要注意是的: RabbitMQ 集群无法搭建在广域网上, 除非使用federation 或者 shovel等插件(没必要, 在同一个机房做集群). </p><p>集群的配置步骤</p><ol><li>配置hosts</li><li>同步<code>erlang.cookie</code></li><li>加入集群(join cluster)</li></ol><h3 id="2-4普通集群"><a href="#2-4普通集群" class="headerlink" title="2.4普通集群"></a>2.4普通集群</h3><p>普通集群模式下, 不同的节点之间只会相互同步元数据</p><p><img src="http://files.luyanan.com//img/20200110161020.png"></p><p>疑问: 为什么不直接把队列的内容(消息) 在所有节点上复制一份呢? </p><p>  主要是出于存储和同步数据的网络开销的考虑,如果所有节点都存储相同的数据,就无法达到线性的增加性能和存储容量的目的(堆机器).</p><p>​    假如生产者连接的是节点3, 要将消息通过交换机A 路由到队列1, 最终消息还是会转发到节点1上存储, 吨位队列1的内容只是在节点1上. </p><p>​    同理,如果消费者连接的是节点2, 要从队列1上拉取消息, 消息会从节点1转发到节点2上。其他节点起到一个路由的作用,类似于指针 . </p><p>​    普通集群模式不能保证队列的高可用性, 因为队列内容不会复制, 如果节点失效将导致相关队列不可用, 因此我们需要第二种集群模式. </p><h3 id="2-5-镜像集群"><a href="#2-5-镜像集群" class="headerlink" title="2.5 镜像集群"></a>2.5 镜像集群</h3><p>第二种集群模式叫做镜像对垒. </p><p> 镜像队列模式下, 消息内容会在镜像节点间同步, 可用性更高. 不过也有一定的副作用, 系统性能会降低, 节点过多的情况下同步的代价比较大. </p><p>​    </p><h3 id="2-6-高可用"><a href="#2-6-高可用" class="headerlink" title="2.6  高可用"></a>2.6  高可用</h3><p>​    集群搭建成功后, 如果有多个内存节点, 那么生产者和消费者应该连接到哪个节点呢? 如果在我们的代码中根据一定的策略来选择要使用的服务器, 那每个地方都要修改,客户端的代码就会出现很多的重复, 修改起来也比较麻烦. </p><p><img src="http://files.luyanan.com//img/20200110171720.png"></p><p>​    所以需要一个负载均衡的组件(例如HAProxy、LVS、Nginx) ,由负载的组件来做路由。这个时候, 只需要俩呢及到负载组件的IP地址就可以了. </p><p>​    <img src="http://files.luyanan.com//img/20200110171833.png"></p><p>负载分为四层负载和四层负载. </p><p><strong>四层负载</strong>:工作在OSI模式的第四层, 即传输层(TCP位于第四层),它是根据IP端口进行转发(LVS 支持四层负载). RabbltMQ 是TCP的5672端口. </p><p><strong>七层负载</strong>: 工作在第七层,应用层(HTTP层位于第七层). 可以根据请求资源类型分配到后端服务器(Nginx支持七层负载, HAProxy 支持四层负载和七层负载). </p><p>   但是如果这个负载的组件也挂了呢? 客户端就无法连接到任意一台MQ 的服务器了.所以负载软件本身也需要做一个集群.新的问题又来了, 如果有两台负载的软件,客户端应该连哪个呢? </p><p>​     负载之上再负载? 陷入死循环了. 这个时候我们就要换个思路了. </p><p>   我们应该需要这样一个组件: </p><ol><li>它本身有路由(负载)功能, 可以监控集群中节点的状态(比如监控HAProxy), 如果某个节点出现异常或者发生了故障，就把它剔除掉. </li><li>为了提高可用性,它也可以部署多个服务, 但是只有一个自动选举出来的Master 服务器(叫做主路由器), 通过广播心跳消息实现. </li><li>Master 服务器对外一个虚拟的IP, 提供各种网络功能. 也就是谁抢占到了VIP, 就由谁对外提供网络服务. 应用端只需要连接到这一个IP就行了. </li></ol><p>这个协议叫做做 VRRP 协议（虚拟路由冗余协议 Virtual Router Redundancy Protocol），这个组件就是 Keepalived，它具有 Load Balance 和 High Availability 的功能。</p><h2 id="3-实践经验总结"><a href="#3-实践经验总结" class="headerlink" title="3. 实践经验总结"></a>3. 实践经验总结</h2><h3 id="3-1-资源管理"><a href="#3-1-资源管理" class="headerlink" title="3.1 资源管理"></a>3.1 资源管理</h3><p>到底是在消费者创建还是在生产者创建呢? </p><p>​    如果A项目和B项目有互相发送和接收消息,应该创建几个vhost，几个exchange呢? </p><p>交换机和队列, 实际上是作为资源, 由运维管理员创建的. </p><h3 id="3-2-配置文件与命名规范"><a href="#3-2-配置文件与命名规范" class="headerlink" title="3.2  配置文件与命名规范"></a>3.2  配置文件与命名规范</h3><ol><li><p>元数据的命名集中放在properties 文件中,不需要硬编码 . 如果有多个系统,可以配置多个<code>xxx_mq.properties</code>. </p></li><li><p>命名体现元数据类型</p><ul><li>虚拟机命名: <code>_VHOST</code></li><li>交换机命名:<code>XXX_Exchange</code></li><li>队列命名:<code>XXX_QUEUE</code>.</li></ul></li><li><p>命名体现数据来源和去向</p><p> 例如： 销售系统发往产品系统的交换机: SALE_TO_PRODUCT_EXCHANGE。做到 见名知义，不用去查文档（当然注释是必不可少的）。</p></li></ol><h3 id="3-3-调用封装"><a href="#3-3-调用封装" class="headerlink" title="3.3 调用封装"></a>3.3 调用封装</h3><p>在项目中,可以对Template 做进一步封装,简化消息的发送., </p><p>例如:如果交换机、路由键是固定的, 封装之后就只需要一个参数: 消息内容. </p><p> 另外,如果想要平滑的迁移不同的MQ(如果有这种需求),也可以再做一层简单的封装. </p><h3 id="3-4-信息落库-定时任务"><a href="#3-4-信息落库-定时任务" class="headerlink" title="3.4 信息落库+定时任务"></a>3.4 信息落库+定时任务</h3><p>​    将需要发送的消息保存在数据库中,可以实现消息的可追溯和重复控制,需要配合定时任务来实现. </p><ol><li>将需要发送的消息登记在消息表中. </li><li>定时任务一分钟或者半分钟扫描一次,将未发送的消息发送到MQ 服务器,并且修改状态为已发送. </li><li>如果需要重发消息, 将制定消息的状态修改为未发送即可. </li></ol><p>副作用:降低效率,浪费存储空间. </p><h3 id="3-5-生产环境运维监控"><a href="#3-5-生产环境运维监控" class="headerlink" title="3.5 生产环境运维监控"></a>3.5 生产环境运维监控</h3><p>虽然RabbitMQ 提供了一个简单的管理界面,但是如果对于系统性能、高可用和其他参数有一定定制化的监控需求的话,我们就需要通过其他的方式来实现监控了. </p><p>​    主要关注:磁盘、内存和连接数. </p><h3 id="3-6-日志追踪"><a href="#3-6-日志追踪" class="headerlink" title="3.6 日志追踪"></a>3.6 日志追踪</h3><p>​    RabbitMQ 可以通过<code>Firehose</code>  功能来记录消息的流入流出的情况, 用于调试、排错. </p><p>​    它是通过创建一个TOPIC 类型的交换机(<code>amq.rabbitmq.trace</code>), 把生产者发送给Broker 的消息或者Broker 发送给消费者的消息发送到这个默认的交换机上来实现的. </p><p>​    另外RabbitMQ 也提供了一个个 Firehose 的 GUI 版本，就是 Tracing 插件. </p><p>​     启动Tracing 插件管理界面右侧选项卡会多一个Tracing, 可以添加相应的策略. </p><p>​    RabbitMQ 还提供了其他的插件来增强功能. </p><p><a href="https://www.rabbitmq.com/firehose.html">https://www.rabbitmq.com/firehose.html</a></p><p><a href="https://www.rabbitmq.com/plugins.html">https://www.rabbitmq.com/plugins.html</a></p><h3 id="3-7-如何减少连接数"><a href="#3-7-如何减少连接数" class="headerlink" title="3.7 如何减少连接数"></a>3.7 如何减少连接数</h3><p>   在发送大批量消息的情况下, 创建和释放连接依然有不小的开销. 我们可以跟接收方约定批量消息的格式,比如支持JSON 数组的格式,通过合同消息内容,可以减少生产者/消费者与Broker 的连接. </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RabbitMQ可靠性投递和实践经验&quot;&gt;&lt;a href=&quot;#RabbitMQ可靠性投递和实践经验&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ可靠性投递和实践经验&quot;&gt;&lt;/a&gt;RabbitMQ可靠性投递和实践经验&lt;/h1&gt;&lt;h2 id=&quot;1-可靠性投递&quot;&gt;&lt;a href=&quot;#1-可靠性投递&quot; class=&quot;headerlink&quot; title=&quot;1. 可靠性投递&quot;&gt;&lt;/a&gt;1. 可靠性投递&lt;/h2&gt;&lt;p&gt;在RabbitMQ里面提供了很多保证可靠投递的机制, 这也是RbabitMQ的一个特性. &lt;/p&gt;
&lt;p&gt;​    我们在讲可靠性投递的时候,必须要明确一个问题,因为效率与可靠性是无法兼得的, 如果要保证每一个环节都成功, 势必会对消息的收发效率造成影响. 所以如果是一些业务实时一致性不是特别高的场景, 可以牺牲一些可靠性换取效率. &lt;/p&gt;
&lt;p&gt;​    比如发送通知或者记录日志的这种场景, 如果用户没有收到通知,不会造成业务影响,只要再次发送就可以了. &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://luyanan.com/Nacos%E9%95%BF%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%9B%86%E7%BE%A4%E5%88%86%E6%9E%90/"/>
    <id>http://luyanan.com/Nacos%E9%95%BF%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%9B%86%E7%BE%A4%E5%88%86%E6%9E%90/</id>
    <published>2021-03-01T09:46:52.806Z</published>
    <updated>2020-12-24T09:34:50.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="长轮询的时间间隔"><a href="#长轮询的时间间隔" class="headerlink" title="长轮询的时间间隔"></a>长轮询的时间间隔</h1><p>我们知道客户端会有一个长训轮的任务去检查服务器端的配置是否发生了变化, 如果发生了变更, 那么客户端会拿到变更的<code>groupKey</code> 再根据 <code>groupKey</code> 去获取配置项的最新值 跟新到本地的缓存以及文件中,那么这种每次都靠客户端去请求, 那请求的时间间隔设置多少合适呢? </p><p>如果间隔时间设置的太长的话有可能无法及时获取服务端的变更, 如果间隔时间设置的太短的话, 那么频繁的请求对于服务端来说无疑也是一种负担,所以最好的方式是客户端每隔一段长度适中的时间去服务端请求, 而在这期间如果配置发生了变更, 服务端能够主动将变更后的结果推送给客户端, 这样既能够保证客户端能够实时感知到配置的变化, 也降低了服务端的压力, 我们来看看nacos 设置的间隔时间是多久? </p><h2 id="长轮询的概念"><a href="#长轮询的概念" class="headerlink" title="长轮询的概念"></a>长轮询的概念</h2><p>那么在讲解原理之前, 先给大家解释一下什么叫长轮询. </p><p>客户端发起一个请求到服务端, 服务端收到客户端的请求后, 并不会立即响应给客户端, 而是先把请求hold住, 然后服务端会在hold 住的这段时间内检查数据是否有更新, 如果有, 则响应给客户端. 如果一直没有数据变更, 则达到一定时间(长轮询时间间隔)才返回. </p><p>长轮询典型的场景有: 扫码登陆、扫码支付. </p><p><img src="http://files.luyanan.com//img/20191210211140.png"></p><h2 id="客户端长轮询"><a href="#客户端长轮询" class="headerlink" title="客户端长轮询"></a>客户端长轮询</h2><p>我们在 <code>ClientWorker</code>  这个类中, 找到<code>checkUpdateConfigStr</code> 这个方法, 这里面就是去服务端查询发生变化的  groupKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Server获取值变化了的DataID列表。返回的对象里只有dataId和group是有效的。 保证不返回NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="keyword">boolean</span> isInitializingCacheList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; params = Arrays.asList(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line"><span class="keyword">long</span> timeout = TimeUnit.SECONDS.toMillis(<span class="number">30L</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; headers = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">headers.add(<span class="string">&quot;Long-Pulling-Timeout&quot;</span>);</span><br><span class="line">headers.add(<span class="string">&quot;&quot;</span> + timeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class="line"><span class="keyword">if</span> (isInitializingCacheList) &#123;</span><br><span class="line">headers.add(<span class="string">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>);</span><br><span class="line">headers.add(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">&quot;/listener&quot;</span>, headers, params,</span><br><span class="line">agent.getEncode(), timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HttpURLConnection.HTTP_OK == result.code) &#123;</span><br><span class="line">setHealthServer(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> parseUpdateDataIdResponse(result.content);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">setHealthServer(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (result.code == HttpURLConnection.HTTP_INTERNAL_ERROR) &#123;</span><br><span class="line">log.error(<span class="string">&quot;NACOS-0007&quot;</span>, LoggerHelper.getErrorCodeStr(<span class="string">&quot;Nacos&quot;</span>, <span class="string">&quot;Nacos-0007&quot;</span>, <span class="string">&quot;环境问题&quot;</span>,</span><br><span class="line"><span class="string">&quot;[check-update] get changed dataId error&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">log.error(agent.getName(), <span class="string">&quot;NACOS-XXXX&quot;</span>, <span class="string">&quot;[check-update] get changed dataId error, code=&#123;&#125;&quot;</span>,</span><br><span class="line">result.code);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">log.error(agent.getName(), <span class="string">&quot;NACOS-XXXX&quot;</span>, <span class="string">&quot;[check-update] get changed dataId exception, msg=&#123;&#125;&quot;</span>,</span><br><span class="line">e.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法最终会发起http请求, 注意这里面有个 <code>timeout</code> 属性. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">&quot;/listener&quot;</span>, headers, params,</span><br><span class="line">agent.getEncode(), timeout);</span><br></pre></td></tr></table></figure><p> timeout 是在init这个方法中赋值的, 默认情况下是30秒, 可以通过 <code>configLongPollTimeout</code> 进行修改, </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       timeout = Math.max(NumberUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class="line">           Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class="line"></span><br><span class="line">       taskPenaltyTime = NumberUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class="line"></span><br><span class="line">       enableRemoteSyncConfig = Boolean.parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所有从这里得出的一个基本结论是:</p><blockquote><p>客户端发起一个轮询请求,超时时间是 30s, 那么客户端为什么要等待30s 才超时呢？不是越快越好吗?</p></blockquote><h2 id="客户端长轮询的时间间隔"><a href="#客户端长轮询的时间间隔" class="headerlink" title="客户端长轮询的时间间隔"></a>客户端长轮询的时间间隔</h2><p>我们可以在nacos 的日志目录下 <code>$NACOS_HOME/nacos/logs/config-client-request.log</code> 文件中: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-08-04 13:22:19,736|0|nohangup|127.0.0.1|polling|1|55|0</span><br><span class="line">2019-08-04 13:22:49,443|29504|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:23:18,983|29535|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:23:48,493|29501|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:24:18,003|29500|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:24:47,509|29501|timeout|127.0.0.1|polling|1|55</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到一个现象, 在配置没有发生变化的情况下, 客户端会等待29.5s以上, 才请求到服务端的结果. 然后客户端拿到服务器端的结果后, 在做后续的操作. </p><p>如果在配置发生变更的情况下, 由于客户端基于长轮询的连接保持, 所以返回的时间会非常短. 我摁可以做个小实验, 在<code>nacos console</code> 中频繁修改数据在观察一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2019-08-04 13:30:17,016|0|inadvance|127.0.0.1|polling|1|55|example+DEFAULT_GROUP</span><br><span class="line">2019-08-04</span><br><span class="line">13:30:17,022|3|null|127.0.0.1|get|example|DEFAULT_GROUP||e10e4d5973c497e490a8d7a</span><br><span class="line">9e4e9be64|unknown</span><br><span class="line">2019-08-04</span><br><span class="line">13:30:20,807|10|true|0:0:0:0:0:0:0:1|publish|example|DEFAULT_GROUP||81360b7e732a</span><br><span class="line">5dbb37d62d81cebb85d2|null</span><br><span class="line">2019-08-04 13:30:20,843|0|inadvance|127.0.0.1|polling|1|55|example+DEFAULT_GROUP</span><br><span class="line">2019-08-04</span><br><span class="line">13:30:20,848|1|null|127.0.0.1|get|example|DEFAULT_GROUP||81360b7e732a5dbb37d62d8</span><br><span class="line">1cebb85d2|unknown</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://files.luyanan.com//img/20191212102604.png"></p><h2 id="服务端的处理"><a href="#服务端的处理" class="headerlink" title="服务端的处理"></a>服务端的处理</h2><p>分析完客户端之后, 随着好奇心的驱使, 服务端是如何处理客户端的请求呢? 那么同样, 我们需要思考几个问题:</p><ul><li>客户端的长轮询响应时间是受到哪些因素的影响</li><li>客户端的超时时间为什么要设置30s</li></ul><p>客户端发送请求的地址是 <code>/v1/cs/configs/listener</code>, 找到服务端对应的方法. </p><h3 id="ConfigController"><a href="#ConfigController" class="headerlink" title="ConfigController"></a>ConfigController</h3><p>nacos 是使用 spring mvc 提供的rest api, 这里会调用<code>inner.doPollingConfig</code> 进行处理. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 比较MD5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;/listener&quot;, method = RequestMethod.POST)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       request.setAttribute(<span class="string">&quot;org.apache.catalina.ASYNC_SUPPORTED&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">       String probeModify = request.getParameter(<span class="string">&quot;Listening-Configs&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(probeModify)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid probeModify&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       probeModify = URLDecoder.decode(probeModify, Constants.ENCODE);</span><br><span class="line"></span><br><span class="line">       Map&lt;String, String&gt; clientMd5Map;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           clientMd5Map = MD5Util.getClientMd5Map(probeModify);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid probeModify&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// do long-polling</span></span><br><span class="line">       inner.doPollingConfig(request, response, clientMd5Map, probeModify.length());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="doPollingConfig"><a href="#doPollingConfig" class="headerlink" title="doPollingConfig"></a>doPollingConfig</h3><p>这个方法中,兼容了长轮询和短轮询的逻辑, 我们只需要关注长轮询的部分, 再次进入到 <code>longPollingService.addLongPollingClient</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 轮询接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">doPollingConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Map&lt;String, String&gt; clientMd5Map, <span class="keyword">int</span> probeRequestSize)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 长轮询</span></span><br><span class="line">      <span class="keyword">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class="line">          longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class="line">          <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// else 兼容短轮询逻辑</span></span><br><span class="line">      List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 兼容短轮询result</span></span><br><span class="line">      String oldResult = MD5Util.compareMd5OldResult(changedGroups);</span><br><span class="line">      String newResult = MD5Util.compareMd5ResultString(changedGroups);</span><br><span class="line"></span><br><span class="line">      String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class="line">      <span class="keyword">if</span> (version == <span class="keyword">null</span>) &#123;</span><br><span class="line">          version = <span class="string">&quot;2.0.0&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> versionNum = Protocol.getVersionNumber(version);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 2.0.4版本以前, 返回值放入header中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class="line">          response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class="line">          response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          request.setAttribute(<span class="string">&quot;content&quot;</span>, newResult);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 禁用缓存</span></span><br><span class="line">      response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">      response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache,no-store&quot;</span>);</span><br><span class="line">      response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">      <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="longPollingService-addLongPollingClient"><a href="#longPollingService-addLongPollingClient" class="headerlink" title="longPollingService.addLongPollingClient"></a>longPollingService.addLongPollingClient</h3><p>从方法的名字上可以推出, 这个方法应该是把客户端的长轮询请求添加到某个任务中. </p><ul><li>获得客户端传递过来的超时时间, 并且进行本地计算, 提前500s 返回响应, 这就能解释为什么客户端响应超时时间是29.5+了, 当然如果 <code>isFixedPolling=true</code> 的情况下, 不会提前返回响应. </li><li>根据客户端请求过来的md5和服务端对应的group 下对应内容的md5 进行比较, 如果不一致, 则通过<code>generateResponse</code>  将结果返回. </li><li>如果配置文件没有发生变化, 则通过 <code>scheduler.execute</code>   启动了一个定时任务, 将客户端的长轮询请求封装成一个叫<code> ClientLongPolling</code> 的任务, 交给 <code> scheduler</code> 去执行. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLongPollingClient</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> probeRequestSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class="line">      String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class="line">      String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class="line">      String tag = req.getHeader(<span class="string">&quot;Vipserver-Tag&quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class="number">500</span>);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 提前500ms返回响应，为避免客户端超时 <span class="doctag">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">long</span> timeout = Math.max(<span class="number">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class="line">      <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">          timeout = Math.max(<span class="number">10000</span>, getFixedPollingInterval());</span><br><span class="line">          <span class="comment">// do nothing but set fix polling timeout</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">          List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class="line">          <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              generateResponse(req, rsp, changedGroups);</span><br><span class="line">              LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                  System.currentTimeMillis() - start, <span class="string">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                  clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (noHangUpFlag != <span class="keyword">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class="line">              LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class="string">&quot;nohangup&quot;</span>,</span><br><span class="line">                  RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class="line">                  changedGroups.size());</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String ip = RequestUtil.getRemoteIp(req);</span><br><span class="line">      <span class="comment">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class="line">      <span class="keyword">final</span> AsyncContext asyncContext = req.startAsync();</span><br><span class="line">      <span class="comment">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class="line">      asyncContext.setTimeout(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">      scheduler.execute(</span><br><span class="line">          <span class="keyword">new</span> ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ClientLongPolling"><a href="#ClientLongPolling" class="headerlink" title="ClientLongPolling"></a>ClientLongPolling</h3><p>我们来分析一下, ClientLongPolling 到底做了什么操作? 或者说我们可以先猜测一下应该会做什么事情? </p><ul><li>这个任务是要阻塞 29.5s 才能执行, 以为立马执行没有任何意思, 毕竟前面已经执行过一次了</li><li>如果在29.5s+ 之内, 数据发生变化, 需要提前通知, 需要有一种监控机制. </li></ul><p>基于这些猜想, 我们来看看他的实现过程. </p><p>从代码粗粒度来看 ，它的实现似乎跟我们的猜想一致, 在run方法中, 通过<code>scheduler.schedule</code> 实现了一个定时任务, 它的delay 时间正好是前面计算的29.5s. 在这个任务中, 会通过<code>MD5Util.compareMd5</code> 来进行计算. </p><p>那另外一个, 当数据发生变化以后, 肯定不能得到 29.5s 之后才通知呀, 那怎么办呢? 我们发现有一个 <code>allsubs</code> 的东西, 它似乎和发布订阅有关系,那是不是有可能当前的<code>clientLongPolling</code> 订阅了数据变化的时间呢? </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          asyncTimeoutFuture = scheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      getRetainIps().put(ClientLongPolling.<span class="keyword">this</span>.ip, System.currentTimeMillis());</span><br><span class="line">                      <span class="comment">/**</span></span><br><span class="line"><span class="comment">                       * 删除订阅关系</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      allSubs.remove(ClientLongPolling.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">                          LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                              (System.currentTimeMillis() - createTime),</span><br><span class="line">                              <span class="string">&quot;fix&quot;</span>, RequestUtil.getRemoteIp((HttpServletRequest)asyncContext.getRequest()),</span><br><span class="line">                              <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                              clientMd5Map.size(), probeRequestSize);</span><br><span class="line">                          List&lt;String&gt; changedGroups = MD5Util.compareMd5(</span><br><span class="line">                              (HttpServletRequest)asyncContext.getRequest(),</span><br><span class="line">                              (HttpServletResponse)asyncContext.getResponse(), clientMd5Map);</span><br><span class="line">                          <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                              sendResponse(changedGroups);</span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                              (System.currentTimeMillis() - createTime),</span><br><span class="line">                              <span class="string">&quot;timeout&quot;</span>, RequestUtil.getRemoteIp((HttpServletRequest)asyncContext.getRequest()),</span><br><span class="line">                              <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                              clientMd5Map.size(), probeRequestSize);</span><br><span class="line">                          sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      LogUtil.defaultLog.error(<span class="string">&quot;long polling error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;, timeoutTime, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">          allSubs.add(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="allSubs"><a href="#allSubs" class="headerlink" title="allSubs"></a>allSubs</h3><p>allSubs 是一个队列, 队列里面存放了 <code>ClientLongPolling</code> 这个对象, 这个队列似乎和配置变更有某种关联关系. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长轮询订阅关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ClientLongPolling&gt; allSubs;</span><br></pre></td></tr></table></figure><p>那这个时候, 我的第一想法是, 先去看一下当前类的类图, 发现 <code>LongPollingService</code> 继承了<code>AbstractEventListener</code>,事件监听. </p><p><img src="http://files.luyanan.com//img/20191212111937.png"></p><h3 id="AbstractEventListener"><a href="#AbstractEventListener" class="headerlink" title="AbstractEventListener"></a>AbstractEventListener</h3><p>这里面有个抽象的onEvent方法, 明显是用来处理事件的方法, 而抽象方法必须由子类实现, 所以意味着<code>LongPollingService</code> 里面肯定实现了onEvent 方法. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">AbstractEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * automatic register</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          EventDispatcher.addEventListener(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 感兴趣的事件列表</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> event list</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">abstract</span> <span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; interest();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 处理事件</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> event event</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="LongPollingService-onEvent"><a href="#LongPollingService-onEvent" class="headerlink" title="LongPollingService.onEvent"></a>LongPollingService.onEvent</h3><p>这个事件的实现方法中: </p><ul><li>判断事件类型是否为<code>LocalDataChangeEvent</code></li><li>通过<code>scheduler.execute</code> 执行 <code>DataChangeTask</code> 这个任务. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">         <span class="comment">// ignore</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (event <span class="keyword">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class="line">             LocalDataChangeEvent evt = (LocalDataChangeEvent)event;</span><br><span class="line">             scheduler.execute(<span class="keyword">new</span> DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="DataChangeTask-run"><a href="#DataChangeTask-run" class="headerlink" title="DataChangeTask.run"></a>DataChangeTask.run</h3><p>从名字来看, 这个是数据变化的任务, 最让人兴奋的是, 这里面有一个循环迭代器, 从 <code>allsubs</code> 里面获取<code>ClientLongPolling</code></p><p>最后通过<code>clientSub.sendResponse</code>把数据返回到客户端, 所以这也就能理解为啥数据变化能够实时触发更新了. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">                ClientLongPolling clientSub = iter.next();</span><br><span class="line">                <span class="keyword">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class="line">                    <span class="comment">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class="line">                    iter.remove(); <span class="comment">// 删除订阅关系</span></span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                        (System.currentTimeMillis() - changeTime),</span><br><span class="line">                        <span class="string">&quot;in-advance&quot;</span>,</span><br><span class="line">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class="line">                        <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class="line">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            LogUtil.defaultLog.error(<span class="string">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么接下来的一个疑问是, 数据变化之后是如何触发事件的呢? 所以我们定位到数据变化的请求类中, 在 <code>configController</code> 这个类中, 找到POST 请求的方法. </p><p>找到配置变更的位置, 发现数据持久化之后 , 会通过<code>EventDispatcher</code> 进行事件发布, <code>EventDispatcher.fireEvent</code>. 但这个事件似乎不是我们所关心的时间, 原因是这里发布的事件是 <code>ConfigDataChangeEvent</code>,而<code>LongPollingService</code> 最感兴趣的事件是 <code>LocalDataChangeEvent</code>. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 增加或更新非聚合数据。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">publishConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(&quot;dataId&quot;)</span> String dataId, <span class="meta">@RequestParam(&quot;group&quot;)</span> String group,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;tenant&quot;, required = false, defaultValue = StringUtils.EMPTY)</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                   String tenant,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(&quot;content&quot;)</span> String content,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;tag&quot;, required = false)</span> String tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;appName&quot;, required = false)</span> String appName,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;src_user&quot;, required = false)</span> String srcUser,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;config_tags&quot;, required = false)</span> String configTags,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;desc&quot;, required = false)</span> String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;use&quot;, required = false)</span> String use,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;effect&quot;, required = false)</span> String effect,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;schema&quot;, required = false)</span> String schema)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> String srcIp = RequestUtil.getRemoteIp(request);</span><br><span class="line">      String requestIpApp = RequestUtil.getAppName(request);</span><br><span class="line">      ParamUtils.checkParam(dataId, group, <span class="string">&quot;datumId&quot;</span>, content);</span><br><span class="line">      ParamUtils.checkParam(tag);</span><br><span class="line"></span><br><span class="line">      Map&lt;String, Object&gt; configAdvanceInfo = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> (configTags != <span class="keyword">null</span>) &#123;</span><br><span class="line">          configAdvanceInfo.put(<span class="string">&quot;config_tags&quot;</span>, configTags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (desc != <span class="keyword">null</span>) &#123;</span><br><span class="line">          configAdvanceInfo.put(<span class="string">&quot;desc&quot;</span>, desc);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (use != <span class="keyword">null</span>) &#123;</span><br><span class="line">          configAdvanceInfo.put(<span class="string">&quot;use&quot;</span>, use);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (effect != <span class="keyword">null</span>) &#123;</span><br><span class="line">          configAdvanceInfo.put(<span class="string">&quot;effect&quot;</span>, effect);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">          configAdvanceInfo.put(<span class="string">&quot;type&quot;</span>, type);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">          configAdvanceInfo.put(<span class="string">&quot;schema&quot;</span>, schema);</span><br><span class="line">      &#125;</span><br><span class="line">      ParamUtils.checkParam(configAdvanceInfo);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (AggrWhitelist.isAggrDataId(dataId)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;[aggr-conflict] &#123;&#125; attemp to publish single data, &#123;&#125;, &#123;&#125;&quot;</span>,</span><br><span class="line">              RequestUtil.getRemoteIp(request), dataId, group);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.NO_RIGHT, <span class="string">&quot;dataId:&quot;</span> + dataId + <span class="string">&quot; is aggr&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Timestamp time = TimeUtils.getCurrentTime();</span><br><span class="line">      String betaIps = request.getHeader(<span class="string">&quot;betaIps&quot;</span>);</span><br><span class="line">      ConfigInfo configInfo = <span class="keyword">new</span> ConfigInfo(dataId, group, tenant, appName, content);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(betaIps)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (StringUtils.isBlank(tag)) &#123;</span><br><span class="line">              persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, configAdvanceInfo, <span class="keyword">false</span>);</span><br><span class="line">              EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              persistService.insertOrUpdateTag(configInfo, tag, srcIp, srcUser, time, <span class="keyword">false</span>);</span><br><span class="line">              EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, tag, time.getTime()));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// beta publish</span></span><br><span class="line">          persistService.insertOrUpdateBeta(configInfo, betaIps, srcIp, srcUser, time, <span class="keyword">false</span>);</span><br><span class="line">          EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">true</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">      &#125;</span><br><span class="line">      ConfigTraceService.logPersistenceEvent(dataId, group, tenant, requestIpApp, time.getTime(),</span><br><span class="line">          LOCAL_IP, ConfigTraceService.PERSISTENCE_EVENT_PUB, content);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>后来我发现, 在 Nacos中有一个 <code>DumpService</code>, 它会定时把变更后的数据 dump 到磁盘上, <code>DumpService</code> 在spring 启动后, 会调用init 方法 启动几个 dump任务, 然后在任务结束后, 会触发一个 <code>LocalDataChangeEvent</code> 的事件. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       LogUtil.defaultLog.warn(<span class="string">&quot;DumpService start&quot;</span>);</span><br><span class="line">       DumpProcessor processor = <span class="keyword">new</span> DumpProcessor(<span class="keyword">this</span>);</span><br><span class="line">       DumpAllProcessor dumpAllProcessor = <span class="keyword">new</span> DumpAllProcessor(<span class="keyword">this</span>);</span><br><span class="line">       DumpAllBetaProcessor dumpAllBetaProcessor = <span class="keyword">new</span> DumpAllBetaProcessor(<span class="keyword">this</span>);</span><br><span class="line">       DumpAllTagProcessor dumpAllTagProcessor = <span class="keyword">new</span> DumpAllTagProcessor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       dumpTaskMgr = <span class="keyword">new</span> TaskManager(</span><br><span class="line">           <span class="string">&quot;com.alibaba.nacos.server.DumpTaskManager&quot;</span>);</span><br><span class="line">       dumpTaskMgr.setDefaultTaskProcessor(processor);</span><br><span class="line"></span><br><span class="line">       dumpAllTaskMgr = <span class="keyword">new</span> TaskManager(</span><br><span class="line">           <span class="string">&quot;com.alibaba.nacos.server.DumpAllTaskManager&quot;</span>);</span><br><span class="line">       dumpAllTaskMgr.setDefaultTaskProcessor(dumpAllProcessor);</span><br><span class="line"></span><br><span class="line">       Runnable dumpAll = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               dumpAllTaskMgr.addTask(DumpAllTask.TASK_ID, <span class="keyword">new</span> DumpAllTask());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Runnable dumpAllBeta = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               dumpAllTaskMgr.addTask(DumpAllBetaTask.TASK_ID, <span class="keyword">new</span> DumpAllBetaTask());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Runnable clearConfigHistory = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               log.warn(<span class="string">&quot;clearConfigHistory start&quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (ServerListService.isFirstIp()) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Timestamp startTime = getBeforeStamp(TimeUtils.getCurrentTime(), <span class="number">24</span> * getRetentionDays());</span><br><span class="line">                       <span class="keyword">int</span> totalCount = persistService.findConfigHistoryCountByTime(startTime);</span><br><span class="line">                       <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">int</span> pageSize = <span class="number">1000</span>;</span><br><span class="line">                           <span class="keyword">int</span> removeTime = (totalCount + pageSize - <span class="number">1</span>) / pageSize;</span><br><span class="line">                           log.warn(<span class="string">&quot;clearConfigHistory, getBeforeStamp:&#123;&#125;, totalCount:&#123;&#125;, pageSize:&#123;&#125;, removeTime:&#123;&#125;&quot;</span>,</span><br><span class="line">                               <span class="keyword">new</span> Object[] &#123;startTime, totalCount, pageSize, removeTime&#125;);</span><br><span class="line">                           <span class="keyword">while</span> (removeTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">// 分页删除，以免批量太大报错</span></span><br><span class="line">                               persistService.removeConfigHistory(startTime, pageSize);</span><br><span class="line">                               removeTime--;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                       log.error(<span class="string">&quot;clearConfigHistory error&quot;</span>, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           dumpConfigInfo(dumpAllProcessor);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 更新beta缓存</span></span><br><span class="line">           LogUtil.defaultLog.info(<span class="string">&quot;start clear all config-info-beta.&quot;</span>);</span><br><span class="line">           DiskUtil.clearAllBeta();</span><br><span class="line">           <span class="keyword">if</span> (persistService.isExistTable(BETA_TABLE_NAME)) &#123;</span><br><span class="line">               dumpAllBetaProcessor.process(DumpAllBetaTask.TASK_ID, <span class="keyword">new</span> DumpAllBetaTask());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 更新Tag缓存</span></span><br><span class="line">           LogUtil.defaultLog.info(<span class="string">&quot;start clear all config-info-tag.&quot;</span>);</span><br><span class="line">           DiskUtil.clearAllTag();</span><br><span class="line">           <span class="keyword">if</span> (persistService.isExistTable(TAG_TABLE_NAME)) &#123;</span><br><span class="line">               dumpAllTagProcessor.process(DumpAllTagTask.TASK_ID, <span class="keyword">new</span> DumpAllTagTask());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// add to dump aggr</span></span><br><span class="line">           List&lt;ConfigInfoChanged&gt; configList = persistService.findAllAggrGroup();</span><br><span class="line">           <span class="keyword">if</span> (configList != <span class="keyword">null</span> &amp;&amp; !configList.isEmpty()) &#123;</span><br><span class="line">               total = configList.size();</span><br><span class="line">               List&lt;List&lt;ConfigInfoChanged&gt;&gt; splitList = splitList(configList, INIT_THREAD_COUNT);</span><br><span class="line">               <span class="keyword">for</span> (List&lt;ConfigInfoChanged&gt; list : splitList) &#123;</span><br><span class="line">                   MergeAllDataWorker work = <span class="keyword">new</span> MergeAllDataWorker(list);</span><br><span class="line">                   work.start();</span><br><span class="line">               &#125;</span><br><span class="line">               log.info(<span class="string">&quot;server start, schedule merge end.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           LogUtil.fatalLog.error(</span><br><span class="line">               <span class="string">&quot;Nacos Server did not start because dumpservice bean construction failure :\n&quot;</span> + e.getMessage(),</span><br><span class="line">               e.getCause());</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">               <span class="string">&quot;Nacos Server did not start because dumpservice bean construction failure :\n&quot;</span> + e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!STANDALONE_MODE) &#123;</span><br><span class="line">           Runnable heartbeat = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   String heartBeatTime = TimeUtils.getCurrentTime().toString();</span><br><span class="line">                   <span class="comment">// write disk</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       DiskUtil.saveHeartBeatToDisk(heartBeatTime);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       LogUtil.fatalLog.error(<span class="string">&quot;save heartbeat fail&quot;</span> + e.getMessage());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           TimerTaskService.scheduleWithFixedDelay(heartbeat, <span class="number">0</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> initialDelay = <span class="keyword">new</span> Random().nextInt(INITIAL_DELAY_IN_MINUTE) + <span class="number">10</span>;</span><br><span class="line">           LogUtil.defaultLog.warn(<span class="string">&quot;initialDelay:&#123;&#125;&quot;</span>, initialDelay);</span><br><span class="line"></span><br><span class="line">           TimerTaskService.scheduleWithFixedDelay(dumpAll, initialDelay, DUMP_ALL_INTERVAL_IN_MINUTE,</span><br><span class="line">               TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">           TimerTaskService.scheduleWithFixedDelay(dumpAllBeta, initialDelay, DUMP_ALL_INTERVAL_IN_MINUTE,</span><br><span class="line">               TimeUnit.MINUTES);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       TimerTaskService.scheduleWithFixedDelay(clearConfigHistory, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>简单总结一i下刚才分析的过程: </p><ul><li><p>客户端发起长轮询请求. </p></li><li><p>服务端收到i请求后, 先比较服务端缓存中的数据是否相同,如果不同, 则直接返回. </p></li><li><p>如果相同, 则通过 <code>schedule</code> 延迟29.5s 之后再执行比较. </p></li><li><p>为了保证当服务端在 29.5s之内数据发生变化能够及时的通知给客户端, 服务端采用事件订阅的方式来监听服务端本地数据变化的事件, 一旦收到事件, 则触发<code>ClientLongPolling</code> , 把结果写回到客户端, 就完成了一次数据的推送. </p></li><li><p>如果 <code>ClientLongPolling</code> 任务完成了数据的推送之后, ClientLongPolling 中的调度任务又开始执行了怎么办？</p><p>  很见到那, 只要在进行推送操作之前, 先将原来等待执行的调度任务取消就行了,这样就方式了推送操作写完响应数据之后， 调用任务又去写响应数据, 这时肯定报错. 所以, 在<code>ClientLongPolling</code> 方法中, 最开始的一个步骤就是删除订阅事件. </p></li></ul><p>所以总的来说, Nacos 采用推+拉的方式, 来解决最开始关于长轮询事件间隔的问题, 当然, 30s 这个时间是可以设置的, 之所以设置成30s, 应该是一个经验值, </p><h1 id="集群选举问题"><a href="#集群选举问题" class="headerlink" title="集群选举问题"></a>集群选举问题</h1><p>Nacos 支持集群模式,很显然, . </p><p>而一旦涉及到集群, 就涉及到主从, 那么nacos 是一种什么样的机制来实现集群的呢? </p><p>nacos 的集群模式类似于zookeeper, 它分为leader 角色和 follower角色, 那么从这个角色的名字可以看出, 这个集群存在选举的机制, 因为如果自己不具备选举功能, 角色的命名可能就是master/slave了. </p><h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><p>nacos集群采用<code>raft</code> 算法来实现, 它是相对于zookeeper 的选举算法来说比较简单的一种. </p><p>选举算法的核心在 <code>RaftCore</code>中, 包括数据的处理和数据的同步. </p><p>在Raft 算法中, 节点有三种角色: </p><ul><li>Leader : 负责接受客户端的请求. </li><li>Candidate: 用于选举Leader 的一种角色</li><li>Follower: 负责响应来自leader  或者Candidate 的请求. </li></ul><p>选举分为两个节点:</p><ul><li>服务启动的时候</li><li>leader 挂了的时候</li></ul><p>所有节点启动的时候, 都是 folower 状态, 如果在一段时间内如果没有收到leader 的心跳(可能是没有leader 或者leader 挂了), 那么folower 会变成Candidate . 然后发起选举, 在选举之前, 会增加term, 这个term 和zookeeper 中的epoch 的道理是一样的. </p><ul><li>folower 会投自己一票, 并且给其他节点发送票据<code>vote</code>, 等待其他节点回复. </li><li>在这个过程中, 可能出现几种情况: <ul><li>收到过半的票数通过, 则成为leader</li><li>被告知其他节点已经成为了leader, 则自己切换为 folower</li><li>一段时间内没有收到过半的投票, 则重新发起选举. </li></ul></li><li>约束条件在任一term中, 单个节点最多只能投一票. </li></ul><p>选举的几种情况: </p><ul><li>第一种情况:  赢得选举后, leader 会给所有节点发送消息, 避免其他节点触发新的选举. </li><li>第二种情况: 比如有三个节点A、B、C。 A、B 同时发起选举, 而A的选举消息先达到C,C给A 投了一票, 当B 的消息达到C时, 已经不能满足上面提到的第一个约束, 而C不会给B投票, 而A和B显然都不会给对方投票. A 胜出之后, 会给B、C 发送心跳消息, 节点B发现节点A的term 不低于自己的term, 知道已经有了leader, 于是转换为folower. </li><li>第三种情况: 没有任何节点获得投票, 可能是平票的情况. 加入总共有四个节点, (A/B/C/D). NodeC、NodeD 同时成为了 candidate.但NodeA  投了NodeD 一票,NodeB 投了NodeC 一票. 这就出现了凭票 spilt vote 的情况. 这个时候大家都在等呀等呀. 知道超时后重新发起选举, 如果出现平票的情况, 那么就延长了系统不可用的时间, 于是raft 就引入了<code>randomized election timeouts</code>  来尽量避免平票的情况. </li></ul><h2 id="数据的处理"><a href="#数据的处理" class="headerlink" title="数据的处理"></a>数据的处理</h2><p>对于事务操作, 请求会转发给leader. </p><p>非事务操作, 可以任意一个节点来处理. </p><p>下面这段代码摘自 RaftCore,.在发布内容的时候, 做了两个事情. </p><ul><li>如果当前的节点不是leader, 则转发给leader 节点处理. </li><li>如果是, 则向所有节点发送 onPublish</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalPublish</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">           JSONObject params = <span class="keyword">new</span> JSONObject();</span><br><span class="line">           params.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line">           params.put(<span class="string">&quot;value&quot;</span>, value);</span><br><span class="line">           Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">           parameters.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">           raftProxy.proxyPostLarge(getLeader().ip, API_PUB, params.toJSONString(), parameters);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           OPERATE_LOCK.lock();</span><br><span class="line">           <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">final</span> Datum datum = <span class="keyword">new</span> Datum();</span><br><span class="line">           datum.key = key;</span><br><span class="line">           datum.value = value;</span><br><span class="line">           <span class="keyword">if</span> (getDatum(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               datum.timestamp.set(<span class="number">1L</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               datum.timestamp.set(getDatum(key).timestamp.incrementAndGet());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">           json.put(<span class="string">&quot;datum&quot;</span>, datum);</span><br><span class="line">           json.put(<span class="string">&quot;source&quot;</span>, peers.local());</span><br><span class="line"></span><br><span class="line">           onPublish(datum, peers.local());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> String content = JSON.toJSONString(json);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(peers.majorityCount());</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersIncludeMyself()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isLeader(server)) &#123;</span><br><span class="line">                   latch.countDown();</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">final</span> String url = buildURL(server, API_ON_PUB);</span><br><span class="line">               HttpClient.asyncHttpPostLarge(url, Arrays.asList(<span class="string">&quot;key=&quot;</span> + key), content, <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                       <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                           Loggers.RAFT.warn(<span class="string">&quot;[RAFT] failed to publish data to peer, datumId=&#123;&#125;, peer=&#123;&#125;, http code=&#123;&#125;&quot;</span>,</span><br><span class="line">                               datum.key, server, response.getStatusCode());</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       latch.countDown();</span><br><span class="line">                       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> STATE <span class="title">onContentWriteCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> STATE.CONTINUE;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!latch.await(UtilsAndCommons.RAFT_PUBLISH_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">               <span class="comment">// only majority servers return success can we consider this update success</span></span><br><span class="line">               Loggers.RAFT.error(<span class="string">&quot;data publish failed, caused failed to notify majority, key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;data publish failed, caused failed to notify majority, key=&quot;</span> + key);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">           Loggers.RAFT.info(<span class="string">&quot;signalPublish cost &#123;&#125; ms, key: &#123;&#125;&quot;</span>, (end - start), key);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           OPERATE_LOCK.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;长轮询的时间间隔&quot;&gt;&lt;a href=&quot;#长轮询的时间间隔&quot; class=&quot;headerlink&quot; title=&quot;长轮询的时间间隔&quot;&gt;&lt;/a&gt;长轮询的时间间隔&lt;/h1&gt;&lt;p&gt;我们知道客户端会有一个长训轮的任务去检查服务器端的配置是否发生了变化, 如果发生了变更, 那么客户端会拿到变更的&lt;code&gt;groupKey&lt;/code&gt; 再根据 &lt;code&gt;groupKey&lt;/code&gt; 去获取配置项的最新值 跟新到本地的缓存以及文件中,那么这种每次都靠客户端去请求, 那请求的时间间隔设置多少合适呢? &lt;/p&gt;
&lt;p&gt;如果间隔时间设置的太长的话有可能无法及时获取服务端的变更, 如果间隔时间设置的太短的话, 那么频繁的请求对于服务端来说无疑也是一种负担,所以最好的方式是客户端每隔一段长度适中的时间去服务端请求, 而在这期间如果配置发生了变更, 服务端能够主动将变更后的结果推送给客户端, 这样既能够保证客户端能够实时感知到配置的变化, 也降低了服务端的压力, 我们来看看nacos 设置的间隔时间是多久? &lt;/p&gt;
&lt;h2 id=&quot;长轮询的概念&quot;&gt;&lt;a href=&quot;#长轮询的概念&quot; class=&quot;headerlink&quot; title=&quot;长轮询的概念&quot;&gt;&lt;/a&gt;长轮询的概念&lt;/h2&gt;&lt;p&gt;那么在讲解原理之前, 先给大家解释一下什么叫长轮询. &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
