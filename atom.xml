<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员报社</title>
  
  <subtitle>程序员报社</subtitle>
  <link href="http://luyanan.com/atom.xml" rel="self"/>
  
  <link href="http://luyanan.com/"/>
  <updated>2021-03-12T02:15:06.403Z</updated>
  <id>http://luyanan.com/</id>
  
  <author>
    <name>luyanan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker-Compose(6)</title>
    <link href="http://luyanan.com/Docker-Compose(6)/"/>
    <id>http://luyanan.com/Docker-Compose(6)/</id>
    <published>2021-03-12T02:15:06.403Z</published>
    <updated>2021-03-12T02:15:06.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker之Docker-Compose"><a href="#Docker之Docker-Compose" class="headerlink" title="Docker之Docker-Compose"></a>Docker之Docker-Compose</h1><blockquote><p><code>官网</code>：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p></blockquote><h2 id="1-业务背景"><a href="#1-业务背景" class="headerlink" title="1.业务背景"></a>1.业务背景</h2><h2 id="2-Docker传统方式实现"><a href="#2-Docker传统方式实现" class="headerlink" title="2 Docker传统方式实现"></a>2 Docker传统方式实现</h2><h3 id="2-1-写Python代码-amp-build-image"><a href="#2-1-写Python代码-amp-build-image" class="headerlink" title="2.1 写Python代码&amp;build image"></a>2.1 写<code>Python</code>代码&amp;<code>build image</code></h3><blockquote><p>(1)创建文件夹</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/composetest</span><br><span class="line">cd /tmp/composetest</span><br></pre></td></tr></table></figure><blockquote><p>(2)创建<code>app.py</code>文件，写业务内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure><blockquote><p>(3)新建<code>requirements.txt</code>文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure><blockquote><p>(4)编写<code>Dockerfile</code></p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>(5)根据<code>Dockerfile</code>生成<code>image</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t python-app-image .</span><br></pre></td></tr></table></figure><blockquote><p>(6)查看<code>images</code>：<code>docker images</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python-app-image latest 7e1d81f366b7 3 minutes ago  213MB</span><br></pre></td></tr></table></figure><h3 id="2-2-获取Redis的image"><a href="#2-2-获取Redis的image" class="headerlink" title="2.2 获取Redis的image"></a>2.2 获取<code>Redis</code>的<code>image</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:alpine</span><br></pre></td></tr></table></figure><h3 id="2-3-创建两个container"><a href="#2-3-创建两个container" class="headerlink" title="2.3 创建两个container"></a>2.3 创建两个<code>container</code></h3><blockquote><p>(1)创建网络</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">docker network create --subnet&#x3D;172.20.0.0&#x2F;24 app-net </span><br></pre></td></tr></table></figure><blockquote><p>(1)创建<code>python</code>程序的<code>container</code>，并指定网段和端口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web -p 5000:5000 --network app-net python-app-image</span><br></pre></td></tr></table></figure><blockquote><p>(2)创建<code>redis</code>的<code>container</code>，并指定网段</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis --network app-net redis:alpine</span><br></pre></td></tr></table></figure><h3 id="2-4-访问测试"><a href="#2-4-访问测试" class="headerlink" title="2.4 访问测试"></a>2.4 访问测试</h3><p>ip[centos]:5000</p><h2 id="3-简介和安装"><a href="#3-简介和安装" class="headerlink" title="3 简介和安装"></a>3 简介和安装</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><blockquote><p><code>官网</code>：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration.</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h3><blockquote><p>Linux环境中需要单独安装</p><p><code>官网</code>：<a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.24.1&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h2 id="4-docker-compose实现"><a href="#4-docker-compose实现" class="headerlink" title="4 docker compose实现"></a>4 <code>docker compose</code>实现</h2><blockquote><p><code>reference</code>：<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p></blockquote><h3 id="4-1-同样的前期准备"><a href="#4-1-同样的前期准备" class="headerlink" title="4.1 同样的前期准备"></a>4.1 同样的前期准备</h3><p>新建目录，比如<code>composetest</code></p><p>进入目录，编写<code>app.py</code>代码</p><p>创建<code>requirements.txt</code>文件</p><p>编写<code>Dockerfile</code></p><h3 id="4-2-编写docker-compose-yaml文件"><a href="#4-2-编写docker-compose-yaml文件" class="headerlink" title="4.2 编写docker-compose.yaml文件"></a>4.2 编写<code>docker-compose.yaml</code>文件</h3><p>默认名称，当然也可以指定，<code>docker-compose.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">app-net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><blockquote><p>(1)通过<code>docker compose</code>创建容器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><blockquote><p>(2)访问测试</p></blockquote><p><img src="http://files.luyanan.com//img/20200417214122.png" alt="image-20200417214115069"></p><h2 id="5-详解docker-compose-yml文件"><a href="#5-详解docker-compose-yml文件" class="headerlink" title="5 详解docker-compose.yml文件"></a>5 详解<code>docker-compose.yml</code>文件</h2><blockquote><p>(1)<code>version: &#39;3&#39;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示docker-compose的版本</span><br></pre></td></tr></table></figure><blockquote><p>(2)<code>services</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个service表示一个container</span><br></pre></td></tr></table></figure><blockquote><p>(3)<code>networks</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相当于docker network create app-net</span><br></pre></td></tr></table></figure><blockquote><p>(4)<code>volumes</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相当于-v v1:&#x2F;var&#x2F;lib&#x2F;mysql</span><br></pre></td></tr></table></figure><blockquote><p>(5)<code>image</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示使用哪个镜像，本地build则用build，远端则用image</span><br></pre></td></tr></table></figure><blockquote><p>(6)<code>ports</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相当于-p 8080:8080</span><br></pre></td></tr></table></figure><blockquote><p>(7)<code>environment</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相当于-e </span><br></pre></td></tr></table></figure><h2 id="6-docker-compose常见操作"><a href="#6-docker-compose常见操作" class="headerlink" title="6 docker-compose常见操作"></a>6 <code>docker-compose</code>常见操作</h2><p>(1)查看版本</p><pre><code>docker-compose version</code></pre><p>(2)根据<code>yml</code>创建<code>service</code></p><pre><code>docker-compose up指定yaml：docker-compose  up -f xxx.yaml后台运行：docker-compose up</code></pre><p>(3)查看启动成功的<code>service</code></p><pre><code>docker-compose ps也可以使用docker ps</code></pre><p>(4)查看<code>images</code></p><pre><code>docker-compose images</code></pre><p>(5)停止/启动service</p><pre><code>docker-compose stop/start </code></pre><p>(6)删除<code>service</code>[同时会删除掉<code>network</code>和<code>volume</code>]</p><pre><code>docker-compose down</code></pre><p>(7)进入到某个service</p><pre><code>docker-compose exec redis sh</code></pre><h2 id="7-scale扩缩容"><a href="#7-scale扩缩容" class="headerlink" title="7 scale扩缩容"></a>7 <code>scale</code>扩缩容</h2><blockquote><p>(1)修改<code>docker-compose.yaml</code>文件，主要是把<code>web</code>的<code>ports</code>去掉，不然会报错</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">app-net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><blockquote><p>(2)创建<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><blockquote><p>(3)若要对<code>python</code>容器进行扩缩容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --scale web&#x3D;5 -d</span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose logs web</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker之Docker-Compose&quot;&gt;&lt;a href=&quot;#Docker之Docker-Compose&quot; class=&quot;headerlink&quot; title=&quot;Docker之Docker-Compose&quot;&gt;&lt;/a&gt;Docker之Docker-Compose&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;官网&lt;/code&gt;：&lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;https://docs.docker.com/compose/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-业务背景&quot;&gt;&lt;a href=&quot;#1-业务背景&quot; class=&quot;headerlink&quot; title=&quot;1.业务背景&quot;&gt;&lt;/a&gt;1.业务背景&lt;/h2&gt;&lt;h2 id=&quot;2-Docker传统方式实现&quot;&gt;&lt;a href=&quot;#2-Docker传统方式实现&quot; class=&quot;headerlink&quot; title=&quot;2 Docker传统方式实现&quot;&gt;&lt;/a&gt;2 Docker传统方式实现&lt;/h2&gt;&lt;h3 id=&quot;2-1-写Python代码-amp-build-image&quot;&gt;&lt;a href=&quot;#2-1-写Python代码-amp-build-image&quot; class=&quot;headerlink&quot; title=&quot;2.1 写Python代码&amp;amp;build image&quot;&gt;&lt;/a&gt;2.1 写&lt;code&gt;Python&lt;/code&gt;代码&amp;amp;&lt;code&gt;build image&lt;/code&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
    <category term="Python" scheme="http://luyanan.com/tags/Python/"/>
    
    <category term="Go" scheme="http://luyanan.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm(7)</title>
    <link href="http://luyanan.com/Docker%20Swarm(7)/"/>
    <id>http://luyanan.com/Docker%20Swarm(7)/</id>
    <published>2021-03-12T02:15:06.403Z</published>
    <updated>2021-03-12T02:15:06.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><blockquote><p><code>官网</code>：<a href="https://docs.docker.com/swarm/">https://docs.docker.com/swarm/</a></p></blockquote><h2 id="1-Install-Swarm"><a href="#1-Install-Swarm" class="headerlink" title="1 Install Swarm"></a>1 Install Swarm</h2><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><blockquote><p>(1)根据<code>Vagrantfile</code>创建3台<code>centos</code>机器</p><p>[<strong>大家可以根据自己实际的情况准备3台centos机器，不一定要使用vagrant+virtualbox</strong>]</p><p>新建<code>swarm-docker-centos7</code>文件夹，创建<code>Vagrantfile</code></p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">:name</span> =&gt; <span class="string">&quot;manager-node&quot;</span>,</span><br><span class="line">        <span class="symbol">:eth1</span> =&gt; <span class="string">&quot;192.168.0.11&quot;</span>,</span><br><span class="line">        <span class="symbol">:mem</span> =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        <span class="symbol">:cpu</span> =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">:name</span> =&gt; <span class="string">&quot;worker01-node&quot;</span>,</span><br><span class="line">        <span class="symbol">:eth1</span> =&gt; <span class="string">&quot;192.168.0.12&quot;</span>,</span><br><span class="line">        <span class="symbol">:mem</span> =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        <span class="symbol">:cpu</span> =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">:name</span> =&gt; <span class="string">&quot;worker02-node&quot;</span>,</span><br><span class="line">        <span class="symbol">:eth1</span> =&gt; <span class="string">&quot;192.168.0.13&quot;</span>,</span><br><span class="line">        <span class="symbol">:mem</span> =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        <span class="symbol">:cpu</span> =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line"></span><br><span class="line">  config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line">  </span><br><span class="line">   boxes.each <span class="keyword">do</span> <span class="params">|opts|</span></span><br><span class="line">      config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">        config.vm.hostname = opts[<span class="symbol">:name</span>]</span><br><span class="line">        config.vm.provider <span class="string">&quot;vmware_fusion&quot;</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">          v.vmx[<span class="string">&quot;memsize&quot;</span>] = opts[<span class="symbol">:mem</span>]</span><br><span class="line">          v.vmx[<span class="string">&quot;numvcpus&quot;</span>] = opts[<span class="symbol">:cpu</span>]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        config.vm.provider <span class="string">&quot;virtualbox&quot;</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">          v.customize [<span class="string">&quot;modifyvm&quot;</span>, <span class="symbol">:id</span>, <span class="string">&quot;--memory&quot;</span>, opts[<span class="symbol">:mem</span>]]</span><br><span class="line">  v.customize [<span class="string">&quot;modifyvm&quot;</span>, <span class="symbol">:id</span>, <span class="string">&quot;--cpus&quot;</span>, opts[<span class="symbol">:cpu</span>]]</span><br><span class="line">  v.customize [<span class="string">&quot;modifyvm&quot;</span>, <span class="symbol">:id</span>, <span class="string">&quot;--name&quot;</span>, opts[<span class="symbol">:name</span>]]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        config.vm.network <span class="symbol">:public_network</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:eth1</span>]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>(2)进入到对应的centos里面，使得root账户能够登陆，从而使用XShell登陆</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh manager-node/worker01-node/worker02-node</span><br><span class="line">sudo -i</span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">修改PasswordAuthentication yes</span><br><span class="line">passwd    修改密码</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><blockquote><p>(3)在win上ping一下各个主机，看是否能ping通</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.0.11&#x2F;12&#x2F;13</span><br></pre></td></tr></table></figure><blockquote><p>(4)在每台机器上安装<code>docker engine</code></p><p><code>小技巧</code>：要想让每个shell窗口一起执行同样的命令”查看–&gt;撰写–&gt;撰写窗口–&gt;全部会话”</p></blockquote><h3 id="1-2-搭建Swarm集群"><a href="#1-2-搭建Swarm集群" class="headerlink" title="1.2 搭建Swarm集群"></a>1.2 搭建Swarm集群</h3><blockquote><p>(1)进入<code>manager</code></p><p><code>提示</code>：<code>manager node</code>也可以作为<code>worker node</code>提供服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr&#x3D;192.168.0.11</span><br></pre></td></tr></table></figure><p><code>注意观察日志，拿到worker node加入manager node的信息</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-0a5ph4nehwdm9wzcmlbj2ckqqso38pkd238rprzwcoawabxtdq-arcpra6yzltedpafk3qyvv0y3 192.168.0.11:2377</span><br></pre></td></tr></table></figure><blockquote><p>(2)进入两个<code>worker</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-0a5ph4nehwdm9wzcmlbj2ckqqso38pkd238rprzwcoawabxtdq-arcpra6yzltedpafk3qyvv0y3 192.168.0.11:2377</span><br></pre></td></tr></table></figure><p><code>日志打印</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><blockquote><p>(3)进入到<code>manager node</code>查看集群状态</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure><blockquote><p>(4)<code>node</code>类型的转换</p><p>可以将<code>worker</code>提升成<code>manager</code>，从而保证manager的高可用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker node promote worker01-node</span><br><span class="line">docker node promote worker02-node</span><br><span class="line"></span><br><span class="line"><span class="comment">#降级可以用demote</span></span><br><span class="line">docker node demote worker01-node</span><br></pre></td></tr></table></figure><h3 id="1-3-在线的"><a href="#1-3-在线的" class="headerlink" title="1.3 在线的"></a>1.3 在线的</h3><blockquote><p><a href="http://labs.play-with-docker.com/">http://labs.play-with-docker.com</a></p></blockquote><h2 id="2-Swarm基本操作"><a href="#2-Swarm基本操作" class="headerlink" title="2 Swarm基本操作"></a>2 Swarm基本操作</h2><h3 id="2-1-Service"><a href="#2-1-Service" class="headerlink" title="2.1 Service"></a>2.1 Service</h3><blockquote><p>(1)创建一个<code>tomcat</code>的<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name my-tomcat tomcat</span><br></pre></td></tr></table></figure><blockquote><p>(2)查看当前<code>swarm</code>的<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure><blockquote><p>(3)查看<code>service</code>的启动日志</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service logs my-tomcat</span><br></pre></td></tr></table></figure><blockquote><p>(4)查看<code>service</code>的详情</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect my-tomcat</span><br></pre></td></tr></table></figure><blockquote><p>(5)查看<code>my-tomcat</code>运行在哪个<code>node</code>上</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps my-tomcat</span><br></pre></td></tr></table></figure><p><code>日志</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS</span><br><span class="line">u6o4mz4tj396        my-tomcat.1         tomcat:latest       worker01-node       Running             Running 3 minutes ago  </span><br></pre></td></tr></table></figure><blockquote><p>(6)水平扩展<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service scale my-tomcat&#x3D;3</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps my-tomcat</span><br></pre></td></tr></table></figure><p><code>日志</code>：可以发现，其他<code>node</code>上都运行了一个<code>my-tomcat</code>的<code>service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@manager-node ~]# docker service ps my-tomcat</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">u6o4mz4tj396        my-tomcat.1         tomcat:latest       worker01-node       Running             Running 8 minutes ago                        </span><br><span class="line">v505wdu3fxqo        my-tomcat.2         tomcat:latest       manager-node        Running             Running 46 seconds ago                       </span><br><span class="line">wpbsilp62sc0        my-tomcat.3         tomcat:latest       worker02-node       Running             Running 49 seconds ago  </span><br></pre></td></tr></table></figure><p>此时到<code>worker01-node</code>上：<code>docker ps</code>，可以发现<code>container</code>的<code>name</code>和<code>service</code>名称不一样，这点要知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">bc4b9bb097b8        tomcat:latest       &quot;catalina.sh run&quot;   10 minutes ago      Up 10 minutes       8080&#x2F;tcp            my-tomcat.1.u6o4mz4tj3969a1p3mquagxok</span><br></pre></td></tr></table></figure><blockquote><p>(7)如果某个<code>node</code>上的<code>my-tomcat</code>挂掉了，这时候会自动扩展</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[worker01-node]</span><br><span class="line">docker rm -f containerid</span><br><span class="line"></span><br><span class="line">[manager-node]</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps my-tomcat</span><br></pre></td></tr></table></figure><blockquote><p>(8)删除<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm my-tomcat</span><br></pre></td></tr></table></figure><h3 id="2-2-多机通信overlay网络-3-7的延续"><a href="#2-2-多机通信overlay网络-3-7的延续" class="headerlink" title="2.2 多机通信overlay网络[3.7的延续]"></a>2.2 多机通信<code>overlay</code>网络[3.7的延续]</h3><blockquote><p><code>业务场景</code>：workpress+mysql实现个人博客搭建</p><blockquote><p><a href="https://hub.docker.com/_/wordpress?tab=description">https://hub.docker.com/_/wordpress?tab=description</a></p></blockquote></blockquote><h4 id="2-2-1-传统手动方式实现"><a href="#2-2-1-传统手动方式实现" class="headerlink" title="2.2.1 传统手动方式实现"></a>2.2.1 传统手动方式实现</h4><h5 id="2-2-1-1-一台centos上，分别创建容器"><a href="#2-2-1-1-一台centos上，分别创建容器" class="headerlink" title="2.2.1.1 一台centos上，分别创建容器"></a>2.2.1.1 一台centos上，分别创建容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">01-创建mysql容器[创建完成等待一会，注意mysql的版本]</span><br><span class="line">docker run -d --name mysql -v v1:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;examplepass -e MYSQL_DATABASE&#x3D;db_wordpress mysql:5.6</span><br><span class="line"></span><br><span class="line">02-创建wordpress容器[将wordpress的80端口映射到centos的8080端口]</span><br><span class="line">docker run -d --name wordpress --link mysql -e WORDPRESS_DB_HOST&#x3D;mysql:3306 -e WORDPRESS_DB_USER&#x3D;root -e WORDPRESS_DB_PASSWORD&#x3D;examplepass -e WORDPRESS_DB_NAME&#x3D;db_wordpress -p 8080:80 wordpress</span><br><span class="line"></span><br><span class="line">03-查看默认bridge的网络，可以发现两个容器都在其中</span><br><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line">04-访问测试</span><br><span class="line">win浏览器中输入：ip[centos]:8080，一直下一步</span><br></pre></td></tr></table></figure><h5 id="2-2-1-2-使用docker-compose创建"><a href="#2-2-1-2-使用docker-compose创建" class="headerlink" title="2.2.1.2 使用docker compose创建"></a>2.2.1.2 使用docker compose创建</h5><blockquote><p><code>docker-compose</code>的方式还是在一台机器中，网络这块很清晰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01-创建wordpress-mysql文件夹</span><br><span class="line">mkdir -p &#x2F;tmp&#x2F;wordpress-mysql</span><br><span class="line">cd &#x2F;tmp&#x2F;wordpress-mysql</span><br><span class="line"></span><br><span class="line">02-创建docker-compose.yml文件</span><br></pre></td></tr></table></figure><p><code>文件内容</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">exampleuser</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">examplepass</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">exampledb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">exampledb</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">exampleuser</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">examplepass</span></span><br><span class="line">      <span class="attr">MYSQL_RANDOM_ROOT_PASSWORD:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">  <span class="attr">db:</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">03-根据docker-compose.yml文件创建service</span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">04-访问测试</span><br><span class="line">win10浏览器ip[centos]:8080，一直下一步</span><br><span class="line"></span><br><span class="line">05-值得关注的点是网络</span><br><span class="line">docker network ls</span><br><span class="line">docker network inspect wordpress-mysql_default</span><br></pre></td></tr></table></figure><h4 id="2-2-2-Swarm中实现"><a href="#2-2-2-Swarm中实现" class="headerlink" title="2.2.2 Swarm中实现"></a>2.2.2 Swarm中实现</h4><blockquote><p>还是<code>wordpress+mysql</code>的案例，在<code>docker swarm</code>集群中怎么玩呢？</p></blockquote><blockquote><p>(1)创建一个<code>overlay</code>网络，用于<code>docker swarm</code>中多机通信</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【manager-node】</span><br><span class="line">docker network create -d overlay my-overlay-net</span><br><span class="line"></span><br><span class="line">docker network ls[此时worker node查看不到]</span><br></pre></td></tr></table></figure><blockquote><p>(2)创建<code>mysql</code>的<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【manager-node】</span><br><span class="line">01-创建service</span><br><span class="line">docker service create --name mysql --mount type&#x3D;volume,source&#x3D;v1,destination&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql --env MYSQL_ROOT_PASSWORD&#x3D;examplepass --env MYSQL_DATABASE&#x3D;db_wordpress --network my-overlay-net mysql:5.6</span><br><span class="line"></span><br><span class="line">02-查看service</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps mysql</span><br></pre></td></tr></table></figure><blockquote><p>(3)创建<code>wordpress</code>的<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">01-创建service  [注意之所以下面可以通过mysql名字访问，也是因为有DNS解析]</span><br><span class="line">docker service create --name wordpress --env WORDPRESS_DB_USER&#x3D;root --env WORDPRESS_DB_PASSWORD&#x3D;examplepass --env WORDPRESS_DB_HOST&#x3D;mysql:3306 --env WORDPRESS_DB_NAME&#x3D;db_wordpress -p 8080:80 --network my-overlay-net wordpress</span><br><span class="line"></span><br><span class="line">02-查看service</span><br><span class="line">docker service ls</span><br><span class="line">docker service ps mysql</span><br><span class="line"></span><br><span class="line">03-此时mysql和wordpress的service运行在哪个node上，这时候就能看到my-overlay-net的网络</span><br></pre></td></tr></table></figure><blockquote><p>(4)测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win浏览器访问ip[manager&#x2F;worker01&#x2F;worker02]:8080都能访问成功</span><br></pre></td></tr></table></figure><blockquote><p>(5)查看<code>my-overlay-net</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-overlay-net</span><br></pre></td></tr></table></figure><blockquote><p>(6)为什么没有用<code>etcd</code>？<code>docker swarm</code>中有自己的分布式存储机制</p></blockquote><h2 id="3-Routing-Mesh"><a href="#3-Routing-Mesh" class="headerlink" title="3 Routing Mesh"></a>3 Routing Mesh</h2><h3 id="3-1-Ingress"><a href="#3-1-Ingress" class="headerlink" title="3.1 Ingress"></a>3.1 Ingress</h3><blockquote><p>通过前面的案例我们发现，部署一个<code>wordpress</code>的<code>service</code>，映射到主机的8080端口，这时候通过<code>swarm</code>集群中的任意主机<code>ip:8080</code>都能成功访问，这是因为什么？</p><p><code>把问题简化</code>：<code>docker service create --name tomcat  -p 8080:8080 --network my-overlay-net tomcat</code></p></blockquote><blockquote><p>(1)记得使用一个自定义的<code>overlay</code>类型的网络</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--network my-overlay-net</span><br></pre></td></tr></table></figure><blockquote><p>(2)查看<code>service</code>情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br><span class="line">docker service ps tomcat</span><br></pre></td></tr></table></figure><blockquote><p>(3)访问3台机器的<code>ip:8080</code>测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现都能够访问到tomcat的欢迎页</span><br></pre></td></tr></table></figure><h3 id="4-2-Internal"><a href="#4-2-Internal" class="headerlink" title="4.2 Internal"></a>4.2 Internal</h3><blockquote><p>之前在实战<code>wordpress+mysql</code>的时候，发现<code>wordpress</code>中可以直接通过<code>mysql</code>名称访问</p><p>这样可以说明两点，第一是其中一定有<code>dns</code>解析，第二是两个<code>service</code>的<code>ip</code>是能够<code>ping</code>通的</p><p><code>思考</code>：不妨再创建一个service，也同样使用上述<code>tomcat</code>的<code>overlay</code>网络，然后来实验</p><p><code>docker service create --name whoami -p 8000:8000 --network my-overlay-net -d  jwilder/whoami</code></p></blockquote><blockquote><p>(1)查看<code>whoami</code>的情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps whoami</span><br></pre></td></tr></table></figure><blockquote><p>(2)在各自容器中互相<code>ping</code>一下彼此，也就是容器间的通信</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#tomcat容器中ping whoami</span><br><span class="line">docker exec -it 9d7d4c2b1b80 ping whoami</span><br><span class="line">64 bytes from bogon (10.0.0.8): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.050 ms</span><br><span class="line">64 bytes from bogon (10.0.0.8): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.080 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#whoami容器中ping tomcat</span><br><span class="line">docker exec -it 5c4fe39e7f60 ping tomcat</span><br><span class="line">64 bytes from bogon (10.0.0.18): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.050 ms</span><br><span class="line">64 bytes from bogon (10.0.0.18): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.080 ms</span><br></pre></td></tr></table></figure><blockquote><p>(3)将<code>whoami</code>进行扩容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service scale whoami&#x3D;3</span><br><span class="line">docker service ps whoami     #manager,worker01,worker02</span><br></pre></td></tr></table></figure><blockquote><p>(4)此时再``ping whoami service<code>，并且访问</code>whoam`i服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ping</span><br><span class="line">docker exec -it 9d7d4c2b1b80 ping whoami</span><br><span class="line">64 bytes from bogon (10.0.0.8): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.055 ms</span><br><span class="line">64 bytes from bogon (10.0.0.8): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.084 ms</span><br><span class="line"></span><br><span class="line">#访问</span><br><span class="line">docker exec -it 9d7d4c2b1b80 curl whoami:8000  [多访问几次]</span><br><span class="line">I&#39;m 09f4158c81ae</span><br><span class="line">I&#39;m aebc574dc990</span><br><span class="line">I&#39;m 7755bc7da921</span><br></pre></td></tr></table></figure><p><code>小结</code>：通过上述的实验可以发现什么？<code>whoami</code>服务对其他服务暴露的ip是不变的，但是通过<code>whoami</code>名称访问8000端口，确实访问到的是不同的<code>service</code>，就说明访问其实是像下面这张图。</p><p>也就是说<code>whoami service</code>对其他服务提供了一个统一的VIP入口，别的服务访问时会做负载均衡。</p><h2 id="5-Stack"><a href="#5-Stack" class="headerlink" title="5 Stack"></a>5 Stack</h2><blockquote><p>docker stack deploy：<a href="https://docs.docker.com/engine/reference/commandline/stack_deploy/">https://docs.docker.com/engine/reference/commandline/stack_deploy/</a></p><p>compose-file：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>有没有发现上述部署<code>service</code>很麻烦？要是能够类似于<code>docker-compose.yml</code>文件那种方式一起管理该多少？这就要涉及到<code>docker swarm</code>中的<code>Stack</code>，我们直接通过前面的<code>wordpress+mysql</code>案例看看怎么使用咯。</p></blockquote><blockquote><p>(1)新建service.yml文件</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">exampleuser</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">examplepass</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">exampledb</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ol-net</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">exampledb</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">exampleuser</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">examplepass</span></span><br><span class="line">      <span class="attr">MYSQL_RANDOM_ROOT_PASSWORD:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ol-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">ol-net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br></pre></td></tr></table></figure><blockquote><p>(2)根据<code>service.yml</code>创建<code>service</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker statck deploy -c service.yml my-service</span><br></pre></td></tr></table></figure><blockquote><p>(3)常见操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">01-查看stack具体信息</span><br><span class="line">docker stack ls</span><br><span class="line">NAME                SERVICES            ORCHESTRATOR</span><br><span class="line">my-service          2                   Swarm</span><br><span class="line"></span><br><span class="line">02-查看具体的service</span><br><span class="line">docker stack services my-service</span><br><span class="line"></span><br><span class="line">ID                  NAME                   MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">icraimlesu61        my-service_db          global              1&#x2F;1                 mysql:5.7           </span><br><span class="line">iud2g140za5c        my-service_wordpress   replicated          3&#x2F;3                 wordpress:latest    *:8080-&gt;80&#x2F;tcp</span><br><span class="line"></span><br><span class="line">03-查看某个service</span><br><span class="line">docker service inspect my-service-db</span><br><span class="line"></span><br><span class="line">&quot;Endpoint&quot;: &#123;</span><br><span class="line">            &quot;Spec&quot;: &#123;</span><br><span class="line">                &quot;Mode&quot;: &quot;vip&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;VirtualIPs&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;kz1reu3yxxpwp1lvnrraw0uq6&quot;,</span><br><span class="line">                    &quot;Addr&quot;: &quot;10.0.1.5&#x2F;24&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>(4)访问测试</p></blockquote><p>win浏览器ip[manager,worker01,worker02]:8080</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-Swarm&quot;&gt;&lt;a href=&quot;#Docker-Swarm&quot; class=&quot;headerlink&quot; title=&quot;Docker Swarm&quot;&gt;&lt;/a&gt;Docker Swarm&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;官网&lt;/code&gt;：&lt;a href=&quot;https://docs.docker.com/swarm/&quot;&gt;https://docs.docker.com/swarm/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-Install-Swarm&quot;&gt;&lt;a href=&quot;#1-Install-Swarm&quot; class=&quot;headerlink&quot; title=&quot;1 Install Swarm&quot;&gt;&lt;/a&gt;1 Install Swarm&lt;/h2&gt;&lt;h3 id=&quot;1-1-环境准备&quot;&gt;&lt;a href=&quot;#1-1-环境准备&quot; class=&quot;headerlink&quot; title=&quot;1.1 环境准备&quot;&gt;&lt;/a&gt;1.1 环境准备&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;(1)根据&lt;code&gt;Vagrantfile&lt;/code&gt;创建3台&lt;code&gt;centos&lt;/code&gt;机器&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;大家可以根据自己实际的情况准备3台centos机器，不一定要使用vagrant+virtualbox&lt;/strong&gt;]&lt;/p&gt;
&lt;p&gt;新建&lt;code&gt;swarm-docker-centos7&lt;/code&gt;文件夹，创建&lt;code&gt;Vagrantfile&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
    <category term="Go" scheme="http://luyanan.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker之网络篇(3)</title>
    <link href="http://luyanan.com/Docker%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87(3)/"/>
    <id>http://luyanan.com/Docker%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87(3)/</id>
    <published>2021-03-12T02:15:06.402Z</published>
    <updated>2021-03-12T02:15:06.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-之网络篇"><a href="#Docker-之网络篇" class="headerlink" title="Docker 之网络篇"></a><a href="https://docs.docker.com/network/">Docker 之网络</a>篇</h1><h2 id="3-1-计算机网络模型"><a href="#3-1-计算机网络模型" class="headerlink" title="3.1   计算机网络模型"></a>3.1   计算机网络模型</h2><p><img src="http://files.luyanan.com//img/20200415113128.png" alt="10"></p><p><img src="http://files.luyanan.com//img/20200415113520.png" alt="11"></p><h2 id="3-2-Linux网卡"><a href="#3-2-Linux网卡" class="headerlink" title="3.2 Linux网卡"></a>3.2 Linux网卡</h2><h3 id="3-2-1-查看网卡-网络接口"><a href="#3-2-1-查看网卡-网络接口" class="headerlink" title="3.2.1  查看网卡(网络接口)"></a>3.2.1  查看网卡(网络接口)</h3><ul><li><code>ip link show</code></li><li><code>ls /sys/class/net</code></li><li><code>ip a</code></li></ul><h3 id="3-2-2-网卡"><a href="#3-2-2-网卡" class="headerlink" title="3.2.2  网卡"></a>3.2.2  网卡</h3><h4 id="3-2-2-1-ip-a-解读"><a href="#3-2-2-1-ip-a-解读" class="headerlink" title="3.2.2.1 ip a 解读"></a>3.2.2.1 <code>ip a</code> 解读</h4><ul><li>状态：<code>UP</code>/<code>DOWN</code>/<code>UNKOWN</code>等 </li><li><code>link</code>/<code>ether</code>：<code>MAC</code>地址 </li><li><code>inet</code>：绑定的IP地址</li></ul><h4 id="3-2-2-2-配置文件"><a href="#3-2-2-2-配置文件" class="headerlink" title="3.2.2.2  配置文件"></a>3.2.2.2  配置文件</h4><p>在<code>linux</code> 中网卡对应的其实就是文件, 所以找到对应的网卡文件即可. </p><p>比如 <code>cat /etc/sysconfig/network-scripts/ifcfg-eth0</code></p><h4 id="3-2-2-3-给网卡添加ip地址"><a href="#3-2-2-3-给网卡添加ip地址" class="headerlink" title="3.2.2.3 给网卡添加ip地址"></a>3.2.2.3 给网卡添加ip地址</h4><p>当然, 这块也可以直接修改<code>ifcfg.*</code> 文件, 但是我们通过命令添加试试</p><ul><li> <code>ip addr add 192.168.0.100/24 dev eth0</code></li><li> 删除ip地址  <code>ip addr delete 192.168.0.100/24 dev eth0</code></li></ul><h4 id="3-2-2-4-网卡的启动和关闭"><a href="#3-2-2-4-网卡的启动和关闭" class="headerlink" title="3.2.2.4  网卡的启动和关闭"></a>3.2.2.4  网卡的启动和关闭</h4><p>重启网卡</p><p><code>service network restart</code> / <code>systemctl restart network</code></p><p>启动/关闭某个网卡</p><p><code>ifup/ifdown eth0 or ip link set eth0 up/down</code></p><h2 id="3-3-Network-Namespace"><a href="#3-3-Network-Namespace" class="headerlink" title="3.3  Network Namespace"></a>3.3  <code>Network Namespace</code></h2><p>在linux上,网络的隔离通过<code>network workspace</code> 来管理,不同的<code>Network Namespace</code>是相互隔离的, </p><p><code>ip netns list</code>: 可以查看机器上的<code>的network namespace</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip netns list <span class="comment">#查看</span></span><br><span class="line">ip netns add ns1 <span class="comment">#添加</span></span><br><span class="line">ip netns delete ns1 <span class="comment">#删除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-1-namespace-实战"><a href="#3-3-1-namespace-实战" class="headerlink" title="3.3.1   namespace 实战"></a>3.3.1  <code> namespace</code> 实战</h3><ol><li><p>创建一个 <code>network namespace</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns add ns1</span><br></pre></td></tr></table></figure></li><li><p>查看该<code>namespace</code> 下网卡的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ip a</span><br></pre></td></tr></table></figure></li><li><p>启动<code>ns1</code> 上的<code>lo</code> 网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ifup lo</span><br><span class="line">or</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> lo up</span><br></pre></td></tr></table></figure></li><li><p>再次查看,可以发现<code>state</code> 已经变成了<code>UNKOWN</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ip a</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>再次创建一个<code>network namespace</code></p><p><img src="http://files.luyanan.com//img/20200415140658.png" alt="12"></p></li><li><p>此时想让两个<code>namespace</code> 网络连通起来</p><p><code>veth pair</code>: <code>Virtual Ethernet Pair</code>,是一个成对的端口,可以实现上述功能. </p><p><img src="http://files.luyanan.com//img/20200415140919.png" alt="13"></p></li><li><p>创建一对<code>link</code>, 也就是接下来要通过<code>过veth pair</code> 连接的<code>link</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth-ns1 <span class="built_in">type</span> veth peer name veth-ns2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看<code>link</code> 情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link</span><br></pre></td></tr></table></figure></li><li><p>将<code>veth-ns1</code>  加入到<code>ns1</code>,将<code>veth-ns2</code> 加入到<code>ns2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> veth-ns1 netns ns1</span><br><span class="line">ip link <span class="built_in">set</span> veth-ns2 netns ns2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看宿主机和<code>ns1</code>、<code>ns2</code>的<code>link</code> 情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip link</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip link</span><br></pre></td></tr></table></figure></li><li><p>此时<code>veth-ns1</code> 和<code>veth-ns2</code> 还没有<code>ip</code>地址,显然通讯还缺少点条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ip addr add 192.168.0.11/24 dev veth-ns1</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip addr add 192.168.0.12/24 dev veth-ns2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>再次查看,发现<code>state</code> 是<code>DOWN</code>,并且还是没有<code>ip</code>地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip link</span><br></pre></td></tr></table></figure></li><li><p>启动<code>veth-ns1</code>和<code>veth-ns2</code> </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> veth-ns1 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> veth-ns2 up</span><br></pre></td></tr></table></figure></li><li><p>再次查看, 发现<code>state</code>是<code>UP</code>,同时有ip</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ip a</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ip a</span><br></pre></td></tr></table></figure></li><li><p>此时两次 <code>network namespace</code> 互相<code>ping</code> 一下,发现是可以<code>ping</code>通</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> ns1 ping 192.168.0.12</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ping 192.168.0.11</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-2-Contailer的NS"><a href="#3-3-2-Contailer的NS" class="headerlink" title="3.3.2 Contailer的NS"></a>3.3.2 <code>Contailer</code>的<code>NS</code></h3><p>按照上面的描述,实际上每一个<code>contailer</code>,都会有自己的<code>network  namespace</code>,并且是独立的,我们可以进入到容器中进行验证</p><ol><li><p>不妨创建两个<code>contailer</code> 看看? </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8081:8080 tomcat</span><br><span class="line">docker run -d --name tomcat02 -p 8082:8080 tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>进入到两个容器中, 分别查看ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it tomcat01 ip a</span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat02 ip a</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>互相<code>ping</code> 一下是可以<code>ping</code>通的</p></li></ol><p>值得我们思考的是,此时<code>tomcat01</code>和<code>tomcat02</code> 属于两个<code>network namespace</code>, 是如何能够<code>ping</code>通的, 有些小伙伴可能会想, 不就跟上面的<code>namespace</code> 实战是一样的吗? 注意这里并没有<code>veth-pair</code> 技术</p><h2 id="3-4-深入分析contailer-网络-Bridge"><a href="#3-4-深入分析contailer-网络-Bridge" class="headerlink" title="3.4 深入分析contailer 网络-Bridge"></a>3.4 深入分析<code>contailer</code> 网络-<code>Bridge</code></h2><h3 id="3-4-1-docker0-默认bridge"><a href="#3-4-1-docker0-默认bridge" class="headerlink" title="3.4.1 docker0 默认bridge"></a>3.4.1 <code>docker0</code> 默认<code>bridge</code></h3><ol><li><p>查看<code>centos</code>的网络, <code>ip a</code> , 可以发现</p><p><img src="http://files.luyanan.com//img/20200416204624.png" alt="image-20200416204611664"></p></li><li><p>查看<code>tomcat01</code>的网络, <code>docker exec -it tomcat01 ip a</code>, 可以发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker exec -it tomcat01 ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></li><li><p>在<code>centos</code> 中<code>ping</code> 一下<code>tomcat01</code>的网络, 发现可以<code>ping</code> 通</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping 172.17.0.2</span><br><span class="line">[root@bogon ~]<span class="comment"># ping 172.17.0.2</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.120 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.056 ms</span><br></pre></td></tr></table></figure></li><li><p>既然可以<code>ping</code> 通, 而且<code>centos</code> 和<code>tomcat01</code> 又属于不同的<code>netrwork namespace</code>,是怎么连接的? </p><p> 很显然,跟之前的实战是一样的, 画个图</p><p><img src="http://files.luyanan.com//img/20200416205041.png" alt="14"></p></li><li><p>也就是说,在<code>tomcat01</code> 中有一个<code>eth0</code>和<code>centos</code>的<code>docker0</code> 中有一个<code>veth3</code>是成对的,类似于之前实战中的<code>veth-ns1</code>和<code>veth-ns2</code>,不妨再通过一个命令确认一下<code>brctl</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装一下：yum install bridge-utils</span><br><span class="line">brctl show</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>那为什么<code>tomcat01</code> 和<code>tomcat02</code>是可以互通的呢? 不多说, 直接上图</p><p> <img src="http://files.luyanan.com//img/20200416205339.png" alt="15"></p></li><li><p>这种网络连接方式我们称之为<code>bridge</code>,其实也可以通过命令查看<code>docker</code> 中的网络模式,<code>docker network ls</code>. <code>bridge</code> 也是<code>docker</code> 默认的网络模式.</p></li><li><p>不妨检查一下<code>bridge</code>: <code>docker network inspect bridge</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;6ad312b32f62b48935f3c95c58ae061df710bfebbd3d721b467507b9516eeb81&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;aa9c612c79f867e874d0cae1aab45374373b61e9cdbe79925d07ae2e89a1cca0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.3/16&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:03&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;tomcat02&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;f49fc396d8e04f2b330163d91bb5d1482715202b4e2fd0c7f42833722787742a&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;c5440b063e8fc0c9c44f3f61bf68f577283417eb23cfa9a361d37973d01a8ba5&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.2/16&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;tomcat01&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>tomcat01</code> 容器中是可以访问互联网的, 顺便把这张图画一下,<code>NAT</code>是通过<code>iptable</code> 实现</p></li></ol><p><img src="http://files.luyanan.com//img/20200416210124.png" alt="16"></p><h3 id="3-4-2-创建自己的network"><a href="#3-4-2-创建自己的network" class="headerlink" title="3.4.2  创建自己的network"></a>3.4.2  创建自己的<code>network</code></h3><ol><li><p>创建自己的<code>network</code>, 类型为<code>bridge</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker network create tomcat-net</span><br><span class="line">or</span><br><span class="line">docker network create --subnet=172.18.0.0/24 tomcat-net</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看已有的<code>network</code>: <code>docker network ls</code></p><p><img src="http://files.luyanan.com//img/20200416210316.png" alt="image-20200416210313245"></p></li><li><p>查看<code>tomcat-net</code> 详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect tomcat-net</span><br></pre></td></tr></table></figure></li><li><p>创建<code>tomcat</code>的容器, 并且指定使用<code>tomcat-net</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name custom-net-tomcat --network tomcat-net tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看<code>custom-net-tomcat</code> 的网络信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it custom-net-tomcat ip a</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看网卡信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure></li><li><p>查看网卡接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brctl show</span><br><span class="line">bridge     name     bridge id     STP enabled     interfaces</span><br><span class="line">br-3012e3afd264     8000.02429780e75d     no     vethf223a4b</span><br><span class="line">docker0     8000.0242437b1bbd     no     veth3b72761</span><br><span class="line">veth9d8c470</span><br></pre></td></tr></table></figure></li><li><p>此时, 在<code>custom-net-tomcat</code> 容器中<code>ping</code> 一下<code>tomcat01</code>的<code>ip</code> 会如何? 发现无法<code>ping</code> 通</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it custom-net-tomcat ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 172.17.0.2 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3000ms</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>此时如果<code>tomcat01</code> 容器能够连接到<code>tomcat-net</code> 上应该就可以 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network connect tomcat-net tomcat01</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看<code>tomcat-net</code> 网络,可以发现<code>tomcat01</code>  这个容器也在其中</p></li><li><p>此时进入到<code>tomcat01</code> 或者<code>custom-net-tomcat</code>中, 不仅可以通过<code>ping</code> 通, 而且可以通过名字<code>ping</code>到, 这时候因为连接到了用户自定义的 <code>tomcat-net bridge</code> 上. </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it tomcat01 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@f49fc396d8e0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># ping 172.18.0.2</span></span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.048 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.040 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@f49fc396d8e0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># ping custom-net-tomcat</span></span><br><span class="line">PING custom-net-tomcat (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from custom-net-tomcat.tomcat-net (172.18.0.2): icmp_seq=1 ttl=64 time=0.030 ms</span><br><span class="line">64 bytes from custom-net-tomcat.tomcat-net (172.18.0.2): icmp_seq=2 ttl=64 time=0.264 ms</span><br></pre></td></tr></table></figure><p>但是<code>ping</code> <code>tomcat02</code> 是不通的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@f49fc396d8e0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># ping 172.17.0.3</span></span><br><span class="line">PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.045 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.066 ms</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@f49fc396d8e0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># ping tomcat02</span></span><br><span class="line">PING tomcat02 (220.250.64.26) 56(84) bytes of data.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-5-深入分析Contailer-网络-Host-amp-None"><a href="#3-5-深入分析Contailer-网络-Host-amp-None" class="headerlink" title="3.5  深入分析Contailer 网络-Host &amp; None"></a>3.5  深入分析<code>Contailer</code> 网络-<code>Host</code> &amp; <code>None</code></h2><h3 id="3-5-1-Host"><a href="#3-5-1-Host" class="headerlink" title="3.5.1 Host"></a>3.5.1 <code>Host</code></h3><ol><li><p>创建一个<code>tomcat</code> 容器,并且指定网络为<code>host</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-tomcat-host --network host tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看<code>ip</code>地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-tomcat-host ip a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现和<code>centos</code> 是一样的</p></li><li><p>检查<code>host</code> 网络</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;e1f00d47db344b6688e99c0f5b393e232309fbe1a4d9c3fc3e1ce7c107f3312d&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;f08456d9dca024cf6f911f8d32329ba2587ea89554c96b77c32698ace6998525&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;my-tomcat-host&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-5-2-None"><a href="#3-5-2-None" class="headerlink" title="3.5.2 None"></a>3.5.2 <code>None</code></h3><ol><li><p>创建一个<code>tomcat</code> 容器, 并且指定网络为<code>none</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-tomcat-none --network none tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看<code>ip</code> 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-tomcat-none ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></li><li><p>检查<code>None</code> 网络</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bb3f0db4fa76a25b5377da9c3bbf087ac7ef0de0a3f9c37a4ae959983d33105c&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;26055c08c968f9d6d03d10b3b66dfea004c35f5d2bd4067a2306566973e92f9e&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;my-tomcat-none&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-6-端口映射以及折腾"><a href="#3-6-端口映射以及折腾" class="headerlink" title="3.6 端口映射以及折腾"></a>3.6 端口映射以及折腾</h2><h3 id="3-6-1-端口映射"><a href="#3-6-1-端口映射" class="headerlink" title="3.6.1 端口映射"></a>3.6.1 端口映射</h3><ol><li><p>创建一个<code>tomcat</code> 容器,名字为<code>port-tomcat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name port-tomcat tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>思考一下要访问该<code>tomcat</code> 怎么办? 肯定是通过<code>ip:port</code>的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it port-tomcat bash</span><br><span class="line">curl localhost:8080</span><br></pre></td></tr></table></figure></li><li><p>那如果是在<code>centos7</code> 访问呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it port-tomcat ip a ----&gt;得到其ip地址，比如172.17.0.4</span><br><span class="line">curl 172.17.0.4:8080</span><br></pre></td></tr></table></figure></li></ol><p><strong>小结:</strong> 之所以能够访问成功,是因为<code>centos</code> 上的<code>docker0</code> 连接了<code>port-tomcat</code>的<code>network namespace</code></p><ol start="4"><li><p>那如果还要在<code>centos7</code>通过<code>curl localhost</code>方式访问呢? 显然要将<code>port-tomcat</code> 的8080端口映射到<code>centos</code> 上. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f port-tomcat</span><br><span class="line">docker run -d --name port-tomcat -p 8090:8080 tomcat</span><br><span class="line">curl localhost:8090</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-6-2-折腾"><a href="#3-6-2-折腾" class="headerlink" title="3.6.2  折腾"></a>3.6.2  折腾</h3><ol><li><p><code>centos7</code> 是运行在<code>win10</code> 上的虚拟机上,  如果想要在<code>win10</code> 上通过<code>ip:port</code> 方式访问呢? </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#此时需要centos和win网络在同一个网段，所以在Vagrantfile文件中</span><br><span class="line">#这种方式等同于桥接网络。也可以给该网络指定使用物理机哪一块网卡，比如</span><br><span class="line">#config.vm.network&quot;public_network&quot;,:bridge=&gt;&#x27;en1: Wi-Fi (AirPort)&#x27;</span><br><span class="line">config.vm.network&quot;public_network&quot;</span><br><span class="line">centos7: ip a ---&gt;192.168.8.118</span><br><span class="line">win10:浏览器访问 192.168.8.118:9080</span><br></pre></td></tr></table></figure></li><li><p>如果也想要把<code>centos7</code> 上的8090映射到<code>win10</code>的某个端口上呢? 然后浏览器访问<code>localhost:port</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此时需要将centos7上的端口和win10上的端口做映射</span></span><br><span class="line">config.vm.network<span class="string">&quot;forwarded_port&quot;</span>,guest:8098,host:8090</span><br><span class="line"><span class="comment">#记得vagrant reload生效一下</span></span><br><span class="line">win10：浏览器访问 localhost：8098</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-6-3-画个图强化一下"><a href="#3-6-3-画个图强化一下" class="headerlink" title="3.6.3 画个图强化一下"></a>3.6.3 画个图强化一下</h3><p><img src="http://files.luyanan.com//img/20200416213622.png" alt="image-20200416213621301"></p><h2 id="3-7-多机之间的contailer-通信"><a href="#3-7-多机之间的contailer-通信" class="headerlink" title="3.7  多机之间的contailer 通信"></a>3.7  多机之间的<code>contailer</code> 通信</h2><p>在同一台<code>centos7</code> 机器上, 发现无论怎么折腾, 我们一定有办法让两个<code>contailer</code> 通信. </p><p>那如果是在两台<code>centos7</code> 机器上的呢? </p><p><img src="http://files.luyanan.com//img/20200416213634.png" alt="image-20200416213632513"></p><ol><li><p>使得两边的<code>etho</code> 能够通信</p></li><li><p>前提要确保两边的<code>ip</code> 地址不一样</p></li><li><p>将一边的所有信息当成<code>etho</code> 传输给另外一端的信息</p></li><li><p>具体通过<code>vxlan</code> 技术实现</p><p> <a href="http://www.evoila.de/2015/11/06/what-is-vxlan-and-how-it-works">http://www.evoila.de/2015/11/06/what-is-vxlan-and-how-it-works</a></p></li><li><p>处在<code>vxlan</code>的底层:<code>underlay</code></p><p>处在<code>xxlan</code>的上层:<code>overlay</code></p></li></ol><p><img src="http://files.luyanan.com//img/20200416213645.png" alt="image-20200416213643754"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-之网络篇&quot;&gt;&lt;a href=&quot;#Docker-之网络篇&quot; class=&quot;headerlink&quot; title=&quot;Docker 之网络篇&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.docker.com/network/&quot;&gt;Docker 之网络&lt;/a&gt;篇&lt;/h1&gt;&lt;h2 id=&quot;3-1-计算机网络模型&quot;&gt;&lt;a href=&quot;#3-1-计算机网络模型&quot; class=&quot;headerlink&quot; title=&quot;3.1   计算机网络模型&quot;&gt;&lt;/a&gt;3.1   计算机网络模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20200415113128.png&quot; alt=&quot;10&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20200415113520.png&quot; alt=&quot;11&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-2-Linux网卡&quot;&gt;&lt;a href=&quot;#3-2-Linux网卡&quot; class=&quot;headerlink&quot; title=&quot;3.2 Linux网卡&quot;&gt;&lt;/a&gt;3.2 Linux网卡&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
    <category term="Go" scheme="http://luyanan.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker初介绍(1)</title>
    <link href="http://luyanan.com/Docker%E5%88%9D%E4%BB%8B%E7%BB%8D(1)/"/>
    <id>http://luyanan.com/Docker%E5%88%9D%E4%BB%8B%E7%BB%8D(1)/</id>
    <published>2021-03-12T02:15:06.401Z</published>
    <updated>2021-03-12T02:15:06.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker初介绍"><a href="#Docker初介绍" class="headerlink" title="Docker初介绍"></a>Docker初介绍</h1><h2 id="1-What-is-Docker"><a href="#1-What-is-Docker" class="headerlink" title="1. What is Docker"></a>1. What is Docker</h2><h3 id="1-1-官网首页"><a href="#1-1-官网首页" class="headerlink" title="1.1 官网首页"></a>1.1 <a href="https://www.docker.com/">官网首页</a></h3><blockquote><p>Modernize your applications, accelerate innovation Securely build, share and run modern applications anywhere</p></blockquote><h3 id="1-2-Docs"><a href="#1-2-Docs" class="headerlink" title="1.2 Docs"></a>1.2 <a href="https://docs.docker.com/get-started/">Docs</a></h3><blockquote><p>Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.</p></blockquote><h3 id="1-3-由来-演进过程"><a href="#1-3-由来-演进过程" class="headerlink" title="1.3 由来(演进过程)"></a>1.3 由来(演进过程)</h3><p>刚开始我们部署一个<code>jar</code>的时候</p><p><img src="http://files.luyanan.com//img/20200413114211.png" alt="image-20200413114147162"></p><p>问题: 成本高, 部署满,浪费资源,硬件限制,不利于迁移扩展. </p><p>接下来进入虚拟化时代</p><p><img src="http://files.luyanan.com//img/20200413122313.png" alt="01"></p><p>优点: 相对利用资源, 相对容易扩展. </p><p>缺点: 容器太重了, 一上来占用较多的物理资源,移植性差,资源利用率低. </p><p><strong>容器时代</strong></p><p><img src="http://files.luyanan.com//img/20200413122439.png" alt="02"></p><h3 id="1-4-再次理解Docker"><a href="#1-4-再次理解Docker" class="headerlink" title="1.4 再次理解Docker"></a>1.4 再次理解Docker</h3><blockquote><p>Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.</p></blockquote><p>发现还是比较容易理解的, 但是这一句<code>Containers are not new</code> ,也就是容器化技术在很早之前就出现了,比较常见的容器化技术有<code>OpenVZ</code>、<code>LXC</code>、<code>RKT</code> 等. </p><h3 id="1-5-Docker-的优势和应用场景"><a href="#1-5-Docker-的优势和应用场景" class="headerlink" title="1.5 Docker 的优势和应用场景"></a>1.5 Docker 的优势和应用场景</h3><blockquote><p><a href="http://www.docker.com/">http://www.docker.com/</a>  —&gt; <code>Solutions</code></p></blockquote><ol><li>有助于<code>Microservices</code>的落地和部署</li><li>充分利用物理机资源, 同时能够整合服务器资源</li><li>提高开发效率,测试效率,部署效率,有利于<code>DevOps</code>的落地</li><li>云原生落地, 应用能够更好的迁移. </li></ol><h2 id="2-容器-Container-和镜像-image"><a href="#2-容器-Container-和镜像-image" class="headerlink" title="2. 容器(Container)和镜像(image)"></a>2. 容器(<code>Container</code>)和镜像(<code>image</code>)</h2><h3 id="2-1-image"><a href="#2-1-image" class="headerlink" title="2.1 image"></a>2.1 <code>image</code></h3><blockquote><p>A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.</p></blockquote><h3 id="2-2-container"><a href="#2-2-container" class="headerlink" title="2.2 container"></a>2.2 <code>container</code></h3><p>Why is docker?-&gt;<a href="https://www.docker.com/resources/what-container">What is a container</a></p><blockquote><p>A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.</p></blockquote><h3 id="2-3-Relation-between-image-and-container"><a href="#2-3-Relation-between-image-and-container" class="headerlink" title="2.3  Relation between image and container"></a>2.3 <code> Relation between image and container</code></h3><blockquote><p>Container images become containers at runtime and in the case of Docker containers- images become containers when they run on Docker Engine</p></blockquote><h3 id="2-4-View-from-Docs"><a href="#2-4-View-from-Docs" class="headerlink" title="2.4  View from Docs"></a>2.4 <code> View from Docs</code></h3><p>从帮助文档的角度看: </p><p><a href="http://www.docker.com/">docker官网</a>-&gt;Resources-&gt;Docs-&gt;Get started-&gt;Get started with Docker-&gt;Orientation-&gt;Images and containers</p><blockquote><p>A container is launched by running an image. An image is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files. A container is a runtime instance of an image–what the image becomes in memory when executed (that is, an image with state, or a user process). You can see a list of your running containers with the command, docker ps, just as you would in Linux.</p></blockquote><h2 id="3-Containers-and-virtual-machines"><a href="#3-Containers-and-virtual-machines" class="headerlink" title="3. Containers and virtual machines"></a>3. Containers and virtual machines</h2><p><a href="www.docker.com">docker官网</a>-&gt;Resources-&gt;Docs-&gt;Get started-&gt;Get started with Docker- &gt;Orientation-&gt;Containers and virtual machines</p><blockquote><p>A container runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.</p><p> By contrast, a virtual machine (VM) runs a full-blown “guest” operating system with virtual access to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.</p></blockquote><p><img src="http://files.luyanan.com//img/20200413145117.png" alt="image-20200413145116672"></p><h2 id="4-Docker-Engine-and-Architecture"><a href="#4-Docker-Engine-and-Architecture" class="headerlink" title="4. Docker Engine and Architecture"></a>4. <code>Docker Engine and Architecture</code></h2><p><a href="https://docs.docker.com/engine/docker-overview/">https://docs.docker.com/engine/docker-overview/</a></p><h3 id="4-1-Docker-Engine"><a href="#4-1-Docker-Engine" class="headerlink" title="4.1 Docker Engine"></a>4.1 Docker Engine</h3><p>Docker Engine is a client-server application with these major components:</p><ul><li>A server which is a type of long-running program called a daemon process (the dockerd command). </li><li>A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do.</li><li> A command line interface (CLI)client (the docker command).</li></ul><p><img src="http://files.luyanan.com//img/20200413145258.png" alt="04"> </p><h3 id="4-2-Docker-Architecture"><a href="#4-2-Docker-Architecture" class="headerlink" title="4.2 Docker Architecture"></a>4.2 Docker Architecture</h3><blockquote><p>Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface.</p></blockquote><p><img src="http://files.luyanan.com//img/20200413145357.png" alt="05"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker初介绍&quot;&gt;&lt;a href=&quot;#Docker初介绍&quot; class=&quot;headerlink&quot; title=&quot;Docker初介绍&quot;&gt;&lt;/a&gt;Docker初介绍&lt;/h1&gt;&lt;h2 id=&quot;1-What-is-Docker&quot;&gt;&lt;a href=&quot;#1-What-is-Docker&quot; class=&quot;headerlink&quot; title=&quot;1. What is Docker&quot;&gt;&lt;/a&gt;1. What is Docker&lt;/h2&gt;&lt;h3 id=&quot;1-1-官网首页&quot;&gt;&lt;a href=&quot;#1-1-官网首页&quot; class=&quot;headerlink&quot; title=&quot;1.1 官网首页&quot;&gt;&lt;/a&gt;1.1 &lt;a href=&quot;https://www.docker.com/&quot;&gt;官网首页&lt;/a&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Modernize your applications, accelerate innovation Securely build, share and run modern applications anywhere&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-2-Docs&quot;&gt;&lt;a href=&quot;#1-2-Docs&quot; class=&quot;headerlink&quot; title=&quot;1.2 Docs&quot;&gt;&lt;/a&gt;1.2 &lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Docs&lt;/a&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker基础(二)(2)</title>
    <link href="http://luyanan.com/Docker%E5%9F%BA%E7%A1%80(%E4%BA%8C)(2)/"/>
    <id>http://luyanan.com/Docker%E5%9F%BA%E7%A1%80(%E4%BA%8C)(2)/</id>
    <published>2021-03-12T02:15:06.400Z</published>
    <updated>2021-03-12T02:15:06.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker基础-二"><a href="#Docker基础-二" class="headerlink" title="Docker基础(二)"></a>Docker基础(二)</h1><h2 id="2-1-继续探讨Image"><a href="#2-1-继续探讨Image" class="headerlink" title="2.1 继续探讨Image"></a>2.1 继续探讨<code>Image</code></h2><p>说白了.<code>image</code> 就是由一层一层的<code>layer</code>组成的. </p><h3 id="2-1-1-官方image"><a href="#2-1-1-官方image" class="headerlink" title="2.1.1 官方image"></a>2.1.1 官方<code>image</code></h3><p><a href="https://github.com/docker-library">https://github.com/docker-library</a></p><p><strong>mysql</strong></p><p><a href="https://github.com/docker-library/tomcat/blob/master/8.5/jdk8/openjdk/Dockerfile">https://github.com/docker-library/tomcat/blob/master/8.5/jdk8/openjdk/Dockerfile</a></p><h3 id="2-1-2-Dockerfile"><a href="#2-1-2-Dockerfile" class="headerlink" title="2.1.2  Dockerfile"></a>2.1.2  <code>Dockerfile</code></h3><p>不妨我们也来制作一个自己的<code>image</code>镜像, 顺便来学习一下<code>Dockerfile</code> 文件中常用的语法. </p><h4 id="2-1-2-1-FROM"><a href="#2-1-2-1-FROM" class="headerlink" title="2.1.2.1  FROM"></a>2.1.2.1  <code>FROM</code></h4><p>指定基础的镜像,比如</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-2-RUN"><a href="#2-1-2-2-RUN" class="headerlink" title="2.1.2.2 RUN"></a>2.1.2.2 <code>RUN</code></h4><p>在镜像内部执行一些命令,比如安装软件、配置环境等 换行可以使用 “”</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-3-ENV"><a href="#2-1-2-3-ENV" class="headerlink" title="2.1.2.3  ENV"></a>2.1.2.3  <code>ENV</code></h4><p>设置变量的值,<code>ENV MYSQL_MAJOR 5.7</code>,通过 <code>过docker run --e key=value</code> 修改, 后面可以直接使用<code>$&#123;MYSQL_MAJOR&#125;</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_MAJOR <span class="number">5.7</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-4-LABEL"><a href="#2-1-2-4-LABEL" class="headerlink" title="2.1.2.4  LABEL"></a>2.1.2.4  <code>LABEL</code></h4><p>设置镜像标签</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> email=<span class="string">&quot;luyanan0718@163.com&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> name=<span class="string">&quot;luyanan&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-5-VOLUME"><a href="#2-1-2-5-VOLUME" class="headerlink" title="2.1.2.5  VOLUME"></a>2.1.2.5  <code>VOLUME</code></h4><p>指定数据的挂载目录</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /var/lib/mysql</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-1-2-6-COPY"><a href="#2-1-2-6-COPY" class="headerlink" title="2.1.2.6   COPY"></a>2.1.2.6   <code>COPY</code></h4><p>将主机内的文件复制到镜像内,如果目录不存在,会自动创建所需要的目录, 注意只是复制, 不会提取和解压.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh /usr/<span class="built_in">local</span>/bin/</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-7-ADD"><a href="#2-1-2-7-ADD" class="headerlink" title="2.1.2.7 ADD"></a>2.1.2.7 <code>ADD</code></h4><p>将主机的文件复制到镜像中,和<code>COPY</code> 类似,只是<code>ADD</code> 会对压缩文件提取和解压.</p><h4 id="2-1-2-8-WORKDIR"><a href="#2-1-2-8-WORKDIR" class="headerlink" title="2.1.2.8 WORKDIR"></a>2.1.2.8 <code>WORKDIR</code></h4><p>指定镜像的工作目录, 之后的命令都是基于此目录工作,如不存在则创建. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/local</span><br><span class="line">WORKDIR tomcat</span><br><span class="line">RUN touch test.txt</span><br></pre></td></tr></table></figure><blockquote><p>会在<code>在/usr/local/tomcat</code> 下创建<code>test.txt</code> 文件</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> app.yml <span class="built_in">test</span>/</span></span><br></pre></td></tr></table></figure><blockquote><p>会在<code>/root/test</code> 下多出一个<code>app.yml</code> 文件</p></blockquote><h4 id="2-1-2-9-CMD"><a href="#2-1-2-9-CMD" class="headerlink" title="2.1.2.9 CMD"></a>2.1.2.9 <code>CMD</code></h4><p>容器启动的时候会默认执行的命令, 若有多个<code>CMD</code> 命令,则最后一个生效.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;mysqld&quot;</span>]</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> mysqld</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-10-ENTRYPOINT"><a href="#2-1-2-10-ENTRYPOINT" class="headerlink" title="2.1.2.10 ENTRYPOINT"></a>2.1.2.10 <code>ENTRYPOINT</code></h4><p>跟<code>CMD</code> 的使用类似</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>跟<code>CMD</code>的不同</p><p><code>docker run</code> 执行时, 会覆盖<code>CMD</code>的命令, 而<code>ENTRYPOINT</code> 不会</p><h4 id="2-1-2-11-EXPOSE"><a href="#2-1-2-11-EXPOSE" class="headerlink" title="2.1.2.11 EXPOSE"></a>2.1.2.11 <code>EXPOSE</code></h4><p>指定镜像要暴漏的端口， 启动镜像时,可以使用<code>-p</code>  将该端口映射给宿主机</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure><h3 id="2-1-3-Dockerfile-实战Spring-Boot-项目"><a href="#2-1-3-Dockerfile-实战Spring-Boot-项目" class="headerlink" title="2.1.3 Dockerfile 实战Spring Boot 项目"></a>2.1.3 <code>Dockerfile</code> 实战<code>Spring Boot</code> 项目</h3><h4 id="2-1-3-1-创建一个Spring-Boot-项目"><a href="#2-1-3-1-创建一个Spring-Boot-项目" class="headerlink" title="2.1.3.1 创建一个Spring Boot 项目"></a>2.1.3.1 创建一个<code>Spring Boot</code> 项目</h4><h4 id="1-2-3-2-写一个controller"><a href="#1-2-3-2-写一个controller" class="headerlink" title="1.2.3.2 写一个controller"></a>1.2.3.2 写一个controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dockerfile&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">dockerfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello docker&quot;</span> ; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-3-打包"><a href="#2-1-3-3-打包" class="headerlink" title="2.1.3.3  打包"></a>2.1.3.3  打包</h4><p><code>mvn clean package</code> 打成一个<code>jar</code> 包,在<code>target</code> 下找到<code>dockerfile-demo-0.0.1-SNAPSHOT.jar</code></p><h4 id="2-1-3-4-新建目录"><a href="#2-1-3-4-新建目录" class="headerlink" title="2.1.3.4  新建目录"></a>2.1.3.4  新建目录</h4><p>在<code>docker</code> 环境中创建一个<code>first-dockerfile</code> </p><h4 id="2-1-3-5-上传"><a href="#2-1-3-5-上传" class="headerlink" title="2.1.3.5  上传"></a>2.1.3.5  上传</h4><p>上传 <code>dockerfile-demo-0.0.1-SNAPSHOT.jar</code> 到该目录下, 并且在此目录创建<code>Dockerfile</code></p><h4 id="2-1-3-6-编写Dockerfile"><a href="#2-1-3-6-编写Dockerfile" class="headerlink" title="2.1.3.6  编写Dockerfile"></a>2.1.3.6  编写<code>Dockerfile</code></h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> luyanan0718@<span class="number">163</span>.com</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> name=<span class="string">&quot;dockerfile-demo&quot;</span> version=<span class="string">&quot;1.0&quot;</span> author=<span class="string">&quot;luyanan&quot;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dockerfile-demo-0.0.1-SNAPSHOT.jar dockerfile-image.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;dockerfile-image.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3-7-构建"><a href="#2-1-3-7-构建" class="headerlink" title="2.1.3.7 构建"></a>2.1.3.7 构建</h4><p>基于<code>Dockerfile</code> 构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test-docker-image .</span><br></pre></td></tr></table></figure><h4 id="2-1-3-8-基于image-创建contailer"><a href="#2-1-3-8-基于image-创建contailer" class="headerlink" title="2.1.3.8 基于image 创建contailer"></a>2.1.3.8 基于<code>image</code> 创建<code>contailer</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name user01 -p 6666:8080 test-docker-image</span><br></pre></td></tr></table></figure><h4 id="2-1-3-9-查看启动日志"><a href="#2-1-3-9-查看启动日志" class="headerlink" title="2.1.3.9 查看启动日志"></a>2.1.3.9 查看启动日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs user01</span><br></pre></td></tr></table></figure><h4 id="2-1-3-10-访问测试"><a href="#2-1-3-10-访问测试" class="headerlink" title="2.1.3.10  访问测试"></a>2.1.3.10  访问测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宿主机上访问curl localhost:6666/dockerfile</span><br></pre></td></tr></table></figure><p>返回 <code>hello docker</code></p><h3 id="2-1-4-镜像仓库"><a href="#2-1-4-镜像仓库" class="headerlink" title="2.1.4 镜像仓库"></a>2.1.4 镜像仓库</h3><h4 id="2-1-4-1-docker-hub"><a href="#2-1-4-1-docker-hub" class="headerlink" title="2.1.4.1 docker hub"></a>2.1.4.1 <a href="hub.docker.com">docker hub</a></h4><ol><li><p>我们在机器上登陆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>输入用户名和密码</p></li><li><p><code>docker push luyanan0718/test-docker-image</code></p><p>注意镜像名称和<code>docker id</code> 一致, 不然<code>push</code>不成功</p></li><li><p>给<code>image</code> 重命名, 并删除掉原来的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag test-docker-image luyanan0718/test-docker-image</span><br><span class="line">docker rmi -f test-docker-image</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>再次推送,刷新 <code>hub.docker.com</code> 后台,发现成功. </p></li><li><p>别人下载,并且运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull luyanan0718/test-docker-image</span><br><span class="line">docker run -d --name user01 -p 6661:8080 luyanan0718/test-docker-image</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-1-4-2-阿里云docker-hub"><a href="#2-1-4-2-阿里云docker-hub" class="headerlink" title="2.1.4.2  阿里云docker hub"></a>2.1.4.2  阿里云<code>docker hub</code></h4><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories">阿里云仓库</a></p><p><a href="https://cr.console.aliyun.com/repository/cn-hangzhou/dreamit/image-repo/details">参考手册</a></p><ol><li><p>登陆到阿里云仓库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login --username=luyanan0718@163.com registry.cnhangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure></li><li><p>输入密码</p></li><li><p>创建命名空间</p></li><li><p>给<code>image</code>打<code>tag</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/luyanan0718/testdocker-image:v1.0</span><br></pre></td></tr></table></figure></li><li><p>推送镜像到<code>docker</code> 阿里云仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push registry.cn-hangzhou.aliyuncs.com/luyanan0718/test-dockerimage:v1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>别人下载, 并且运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/luyanan0718/test-dockerimage:v1.0</span><br><span class="line">docker run -d --name user01 -p 6661:8080 registry.cnhangzhou.aliyuncs.com/luyanan0718/test-docker-image:v1.0</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-1-4-3-搭建自己的Docker-Harbor"><a href="#2-1-4-3-搭建自己的Docker-Harbor" class="headerlink" title="2.1.4.3  搭建自己的Docker Harbor"></a>2.1.4.3  搭建自己的Docker Harbor</h4><ol><li><p>访问github上的<code>harbor</code> 项目</p><p><a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p></li><li><p>下班版本,比如1.7.1 </p><p><a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p></li><li><p>找一台安装了 <code>docker-compose</code>的服务器, 上传并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf xxx.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入到 <code>harbor</code> 目录</p><p>需要<code>harbor.cfg</code> 文件,主要是ip地址修改为当前机器的ip地址</p><p>同时也可以看到<code>Harbor</code>的密码,默认是 <code>Harbor12345</code></p></li><li><p>安装<code>Harbor</code>,需要一些时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh install.sh</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问,输入ip地址, 输入用户名和密码即可. </p></li></ol><h3 id="2-1-5-image常见操作"><a href="#2-1-5-image常见操作" class="headerlink" title="2.1.5 image常见操作"></a>2.1.5 image常见操作</h3><ol><li><p>查看本地的image 列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure></li><li><p>获取远端镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dokcer pull</span><br></pre></td></tr></table></figure></li><li><p>删除镜像[注意此镜像如果正在使用,或者有关联的镜像,则需要先处理完]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image rm imageid</span><br><span class="line">docker rmi -f imageid</span><br><span class="line">docker rmi -f $(docker image ls) 删除所有镜像</span><br></pre></td></tr></table></figure></li><li><p>运行镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run image</span><br></pre></td></tr></table></figure></li><li><p>发布镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-深入探讨Contailer"><a href="#2-2-深入探讨Contailer" class="headerlink" title="2.2 深入探讨Contailer"></a>2.2 深入探讨<code>Contailer</code></h2><blockquote><p>既然<code>contailer</code> 是由<code>image</code> 运行起来的,那么是否可以理解为<code>contailer</code> 与<code>image</code>有某种关系呢?</p></blockquote><p><img src="http://files.luyanan.com//img/20200414220047.png" alt="image-20200414220020523"></p><p>理解: 其实可以理解为<code>contailer</code> 只是基于<code>image</code> 之后的<code>layer</code>  而已, 也就是可以通过<code>docker run image</code> 创建出一个<code>contailer</code></p><h3 id="2-2-1-contailer-到image"><a href="#2-2-1-contailer-到image" class="headerlink" title="2.2.1 contailer 到image"></a>2.2.1 <code>contailer</code> 到<code>image</code></h3><blockquote><p> 既然<code>contailer</code>是基于<code>image</code> 之上的,想想是否能够基于一个<code>contailer</code> 反推出一个<code>image</code> 呢？ </p><p>肯定是可以的,比如通过<code>docker run</code>运行一个<code>contailer</code>出来,这时候对<code>contailer</code>  对一些修改,然后再生成一个<code>image</code>, 这时候<code>image</code>的由来就不仅仅只能通过<code>Dockerfile</code>了. </p></blockquote><p><strong>实验:</strong></p><ol><li><p>拉取一个<code>centos image</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure></li><li><p>根据<code>centos</code>的镜像创建出一个<code>contailer</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name my-centos centos</span><br></pre></td></tr></table></figure></li><li><p>进入<code>my-centos</code>容器中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-centos bash</span><br></pre></td></tr></table></figure></li><li><p>输入<code>vim</code> 命令 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: vim: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></li><li><p>我们要做的是, 对该<code>centos</code>  进行修改,也就是安装一下<code>vim</code> 命令,然后将其生成一个新的<code>centos</code></p></li><li><p>在<code>centos</code> 的<code>contailer</code> 中安装<code>vim</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vim</span><br></pre></td></tr></table></figure></li><li><p>退出容器,将其生成一个新的<code>centos</code>, 名称为<code>vim-centos-image</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit my-centos vim-centos-image</span><br></pre></td></tr></table></figure></li><li><p>查看镜像列表,并且基于<code>vim-centos-image</code> 创建新的容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name my-vim-centos vim-centos-image</span><br></pre></td></tr></table></figure></li><li><p>进入到<code>my-vim-centos</code> 容器中, 检查<code>vim</code>  命令是否存在. </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-vim-centos bash</span><br><span class="line">vim</span><br></pre></td></tr></table></figure></li></ol><p>结论: 可以通过<code>docker commit</code> 命令基于一个<code>contailer</code> 重新生成一个<code>iimage</code>, 但是一般得到<code>image</code> 方式不建议这样做,不然<code>image</code> 怎么来的就全然不知了. </p><h3 id="2-2-2-contailer-资源限制"><a href="#2-2-2-contailer-资源限制" class="headerlink" title="2.2.2 contailer 资源限制"></a>2.2.2 <code>contailer</code> 资源限制</h3><p>如果不对<code>container</code> 的资源做限制,他就会无限制的使用物理机的资源, 这样显然是不合适的,</p><p>查看资源情况: <code>docker status</code></p><h4 id="2-2-2-1-内存限制"><a href="#2-2-2-1-内存限制" class="headerlink" title="2.2.2.1  内存限制"></a>2.2.2.1  内存限制</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--memory Memory <span class="built_in">limit</span></span><br><span class="line">如果不设置 --memory-swap，其大小和memory一样</span><br><span class="line">docker run -d --memory 100M --name tomcat1 tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-CPU限制"><a href="#2-2-2-2-CPU限制" class="headerlink" title="2.2.2.2 CPU限制"></a>2.2.2.2 CPU限制</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--cpu-shares 权重</span><br><span class="line">docker run -d --cpu-shares 10 --name tomcat2 tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-2-3-图形化资源监控"><a href="#2-2-2-3-图形化资源监控" class="headerlink" title="2.2.2.3  图形化资源监控"></a>2.2.2.3  图形化资源监控</h4><p><a href="https://github.com/weaveworks/scope">https://github.com/weaveworks/scope</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L git.io/scope -o /usr/<span class="built_in">local</span>/bin/scope</span><br><span class="line">sudo chmod a+x /usr/<span class="built_in">local</span>/bin/scope</span><br><span class="line">scope launch 39.100.39.63</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止scope</span></span><br><span class="line">scope stop</span><br><span class="line"><span class="comment"># 同时监控两台机器，在两台机器中分别执行如下命令</span></span><br><span class="line">scope launch ip1 ip2</span><br></pre></td></tr></table></figure><h3 id="2-2-3-contailer-常见操作"><a href="#2-2-3-contailer-常见操作" class="headerlink" title="2.2.3  contailer 常见操作"></a>2.2.3  <code>contailer</code> 常见操作</h3><ol><li><p>根据镜像创建容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name -p 9090:8080 my-tomcat tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看运行中的<code>contailer</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>查看所有的<code>contailer</code>(包含退出的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>删除<code>contailer</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm containerid</span><br><span class="line">docker rm -f $(docker ps -a) 删除所有container</span><br></pre></td></tr></table></figure></li><li><p>根据<code>contailer</code> 生成<code>image</code></p><p> <code>docker  commit</code></p></li><li><p>进入到一个<code>contailer</code> 中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it contailer bash</span><br></pre></td></tr></table></figure></li><li><p>查看某个<code>contailer</code>的日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs contailer</span><br></pre></td></tr></table></figure></li><li><p>查看容器资源使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker status</span><br></pre></td></tr></table></figure></li><li><p>查看容器详情信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>停止/启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop/start contailer</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-底层技术支持"><a href="#2-3-底层技术支持" class="headerlink" title="2.3  底层技术支持"></a>2.3  底层技术支持</h2><p><code>contailer</code> 是一种轻量级的虚拟化技术, 不用模拟硬件创建虚拟机</p><p><code>Docker</code> 是基于<code>Linux Kernel</code>的<code>Namespace</code>、<code>CGroups</code>、<code>UnionFileSystem</code>等技术封装成的一种自 定义容器格式，从而提供一套虚拟运行环境。</p><p><code>Namespace</code>：用来做隔离的，比如<code>pid</code>[进程]、<code>net</code>[网络]、<code>mnt</code>[挂载点]等</p><p><code>CGroups</code>: <code>Controller Groups</code>用来做资源限制，比如内存和<code>CPU</code>等</p><p><code>Union file systems</code>：用来做<code>image</code>和<code>container</code>分层</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker基础-二&quot;&gt;&lt;a href=&quot;#Docker基础-二&quot; class=&quot;headerlink&quot; title=&quot;Docker基础(二)&quot;&gt;&lt;/a&gt;Docker基础(二)&lt;/h1&gt;&lt;h2 id=&quot;2-1-继续探讨Image&quot;&gt;&lt;a href=&quot;#2-1-继续探讨Image&quot; class=&quot;headerlink&quot; title=&quot;2.1 继续探讨Image&quot;&gt;&lt;/a&gt;2.1 继续探讨&lt;code&gt;Image&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;说白了.&lt;code&gt;image&lt;/code&gt; 就是由一层一层的&lt;code&gt;layer&lt;/code&gt;组成的. &lt;/p&gt;
&lt;h3 id=&quot;2-1-1-官方image&quot;&gt;&lt;a href=&quot;#2-1-1-官方image&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 官方image&quot;&gt;&lt;/a&gt;2.1.1 官方&lt;code&gt;image&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/docker-library&quot;&gt;https://github.com/docker-library&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
    <category term="Go" scheme="http://luyanan.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker实战(5)</title>
    <link href="http://luyanan.com/Docker%E5%AE%9E%E6%88%98(5)/"/>
    <id>http://luyanan.com/Docker%E5%AE%9E%E6%88%98(5)/</id>
    <published>2021-03-12T02:15:06.399Z</published>
    <updated>2021-03-12T02:15:06.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker实战"><a href="#Docker实战" class="headerlink" title="Docker实战"></a>Docker实战</h1><h2 id="1-Mysql-高可用集群"><a href="#1-Mysql-高可用集群" class="headerlink" title="1. Mysql 高可用集群"></a>1. Mysql 高可用集群</h2><h3 id="1-拉取pxc镜像"><a href="#1-拉取pxc镜像" class="headerlink" title="1. 拉取pxc镜像"></a>1. 拉取<code>pxc</code>镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull percona/percona-xtradb-cluster:5.7.21</span><br></pre></td></tr></table></figure><h3 id="2-复制pxc-镜像-实则重命名"><a href="#2-复制pxc-镜像-实则重命名" class="headerlink" title="2. 复制pxc 镜像(实则重命名)"></a>2. 复制<code>pxc</code> 镜像(实则重命名)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag percona/percona-xtradb-cluster:5.7.21 pxc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-删除pxc-原来的镜像"><a href="#3-删除pxc-原来的镜像" class="headerlink" title="3. 删除pxc 原来的镜像"></a>3. 删除<code>pxc</code> 原来的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi percona/percona-xtradb-cluster:5.7.21</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-创建一个单独的网段-给mysql-数据库集群使用"><a href="#4-创建一个单独的网段-给mysql-数据库集群使用" class="headerlink" title="4. 创建一个单独的网段,给mysql 数据库集群使用"></a>4. 创建一个单独的网段,给<code>mysql</code> 数据库集群使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)docker network create --subnet=172.18.0.0/24 pxc-net</span><br><span class="line">(2)docket network inspect pxc-net [查看详情]</span><br><span class="line">(3)docker network rm pxc-net [删除]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-创建和删除volume"><a href="#5-创建和删除volume" class="headerlink" title="5.  创建和删除volume"></a>5.  创建和删除<code>volume</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建：docker volume create --name v1</span><br><span class="line">删除：docker volume rm v1</span><br><span class="line">查看详情：docker volume inspect v1</span><br></pre></td></tr></table></figure><h3 id="6-创建单个pxc-容器demo"><a href="#6-创建单个pxc-容器demo" class="headerlink" title="6.  创建单个pxc 容器demo"></a>6.  创建单个<code>pxc</code> 容器demo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[CLUSTER_NAME PXC集群名字]</span><br><span class="line">[XTRABACKUP_PASSWORD数据库同步需要用到的密码]</span><br><span class="line"></span><br><span class="line">docker run -d -p 3301:3306</span><br><span class="line">-v v1:/var/lib/mysql</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=jack123</span><br><span class="line">-e CLUSTER_NAME=PXC</span><br><span class="line">-e XTRABACKUP_PASSWORD=jack123</span><br><span class="line">--privileged --name=node1 --net=pxc-net --ip 172.18.0.2</span><br><span class="line">pxc</span><br></pre></td></tr></table></figure><h3 id="7-搭建pxc-集群"><a href="#7-搭建pxc-集群" class="headerlink" title="7. 搭建pxc 集群"></a>7. 搭建<code>pxc</code> 集群</h3><h4 id="7-1-准备三个数据卷"><a href="#7-1-准备三个数据卷" class="headerlink" title="7.1 准备三个数据卷"></a>7.1 准备三个数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --name v1</span><br><span class="line">docker volume create --name v2</span><br><span class="line">docker volume create --name v3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-2-运行三个pxc-容器"><a href="#7-2-运行三个pxc-容器" class="headerlink" title="7.2 运行三个pxc 容器"></a>7.2 运行三个<code>pxc</code> 容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3301:3306 -v v1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jack123 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=jack123 --privileged --name=node1 --net=pxc-net --ip 172.18.0.2 pxc</span><br><span class="line"></span><br><span class="line">[CLUSTER_JOIN将该数据库加入到某个节点上组成集群]</span><br><span class="line">docker run -d -p 3302:3306 -v v2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jack123 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=jack123 -e CLUSTER_JOIN=node1 --privileged --name=node2 --net=pxc-net --ip 172.18.0.3 pxc</span><br><span class="line"></span><br><span class="line">docker run -d -p 3303:3306 -v v3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jack123 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=jack123 -e CLUSTER_JOIN=node1 --privileged --name=node3 --net=pxc-net --ip 172.18.0.4 pxc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-3-MYSQL工具连接测试一下"><a href="#7-3-MYSQL工具连接测试一下" class="headerlink" title="7.3  MYSQL工具连接测试一下"></a>7.3  MYSQL工具连接测试一下</h4><h3 id="8-数据库的负载均衡"><a href="#8-数据库的负载均衡" class="headerlink" title="8. 数据库的负载均衡"></a>8. 数据库的负载均衡</h3><ol><li><p>拉取<code>haproxy</code>镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull haproxy</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建<code>harproxy</code> 配置文件,这里使用 <code>bind mounting</code> 的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/haproxy/haproxy.cfg</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>haproxy.cfg</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line"><span class="comment">#工作目录，这边要和创建容器指定的目录对应</span></span><br><span class="line">chroot /usr/<span class="built_in">local</span>/etc/haproxy</span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line"><span class="built_in">log</span> 127.0.0.1 local5 info</span><br><span class="line"><span class="comment">#守护进程运行</span></span><br><span class="line">daemon</span><br><span class="line">defaults</span><br><span class="line"><span class="built_in">log</span> global</span><br><span class="line">mode http</span><br><span class="line"><span class="comment">#日志格式</span></span><br><span class="line">option httplog</span><br><span class="line"><span class="comment">#日志中不记录负载均衡的心跳检测记录</span></span><br><span class="line">option dontlognull</span><br><span class="line"><span class="comment">#连接超时（毫秒）</span></span><br><span class="line">timeout connect 5000</span><br><span class="line"><span class="comment">#客户端超时（毫秒）</span></span><br><span class="line">timeout client 50000</span><br><span class="line"><span class="comment">#服务器超时（毫秒）</span></span><br><span class="line">timeout server 50000</span><br><span class="line"><span class="comment">#监控界面</span></span><br><span class="line">listen admin_stats</span><br><span class="line"><span class="comment">#监控界面的访问的IP和端口</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0:8888</span><br><span class="line"><span class="comment">#访问协议</span></span><br><span class="line">mode http</span><br><span class="line"><span class="comment">#URI相对地址</span></span><br><span class="line">stats uri /dbs_monitor</span><br><span class="line"><span class="comment">#统计报告格式</span></span><br><span class="line">stats realm Global\ statistics</span><br><span class="line"><span class="comment">#登陆帐户信息</span></span><br><span class="line">stats auth admin:admin</span><br><span class="line"><span class="comment">#数据库负载均衡</span></span><br><span class="line">listen proxy-mysql</span><br><span class="line"><span class="comment">#访问的IP和端口，haproxy开发的端口为3306</span></span><br><span class="line"><span class="comment">#假如有人访问haproxy的3306端口，则将请求转发给下面的数据库实例</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0:3306</span><br><span class="line"><span class="comment">#网络协议</span></span><br><span class="line">mode tcp</span><br><span class="line"><span class="comment">#负载均衡算法（轮询算法）</span></span><br><span class="line"><span class="comment">#轮询算法：roundrobin</span></span><br><span class="line"><span class="comment">#权重算法：static-rr</span></span><br><span class="line"><span class="comment">#最少连接算法：leastconn</span></span><br><span class="line"><span class="comment">#请求源IP算法：source</span></span><br><span class="line">balance roundrobin</span><br><span class="line"><span class="comment">#日志格式</span></span><br><span class="line">option tcplog</span><br><span class="line"><span class="comment">#在MySQL中创建一个没有权限的haproxy用户，密码为空</span></span><br><span class="line"><span class="comment">#Haproxy使用这个账户对MySQL数据库心跳检测</span></span><br><span class="line">option mysql-check user haproxy</span><br><span class="line">server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000</span><br><span class="line">server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000</span><br><span class="line">server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000</span><br><span class="line"><span class="comment">#使用keepalive检测死链</span></span><br><span class="line">option tcpka</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建<code>haproxy</code>容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p 8888:8888 -p 3306:3306 -v /tmp/haproxy:/usr/<span class="built_in">local</span>/etc/haproxy --name haproxy01 --privileged --net=pxc-net haproxy</span><br></pre></td></tr></table></figure></li><li><p>根据<code>haproxy.cfg</code> 文件启动<code>haproxy</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it haproxy01 bash</span><br><span class="line">haproxy -f /usr/<span class="built_in">local</span>/etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure></li><li><p>在MYSQL数据库上创建用户,用于心跳检测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;haproxy&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">[小技巧[如果创建失败，可以先输入一下命令]:</span><br><span class="line">drop user <span class="string">&#x27;haproxy&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line">CREATE USER <span class="string">&#x27;haproxy&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>win</code> 浏览器访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://centos_ip:8888/dbs_monitor</span><br><span class="line">用户名密码都是:admin</span><br></pre></td></tr></table></figure></li><li><p>在<code>win</code> 上的mysql 客户端连接<code>haproxy1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip:centos_ip</span><br><span class="line">port:3306</span><br><span class="line">user:root</span><br><span class="line">password:jack123</span><br></pre></td></tr></table></figure></li><li><p>在<code>haproxy</code>  连接上进行数据操作,然后查看数据库集群各个节点</p></li></ol><h2 id="2-Nginx-和Spring-Boot-项目-MYSQL"><a href="#2-Nginx-和Spring-Boot-项目-MYSQL" class="headerlink" title="2. Nginx 和Spring Boot 项目+MYSQL"></a>2. <code>Nginx</code> 和<code>Spring Boot</code> 项目+<code>MYSQL</code></h2><h3 id="2-1-网络"><a href="#2-1-网络" class="headerlink" title="2.1   网络"></a>2.1   网络</h3><h4 id="2-1-1-网络"><a href="#2-1-1-网络" class="headerlink" title="2.1.1 网络"></a>2.1.1 网络</h4><p>创建一个单独的网段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=172.18.0.0/24 pro-net</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-1-2-网络划分"><a href="#2-1-2-网络划分" class="headerlink" title="2.1.2  网络划分"></a>2.1.2  网络划分</h4><p><code>mysql</code> -&gt; <code>172.18.0.6</code></p><p><code>springboot</code>-&gt;<code>172.18.0.11/12/13</code></p><p><code>nginx</code> -&gt; <code>172.18.0.10</code></p><p><img src="http://files.luyanan.com//img/20200417200014.png" alt="image-20200417200012981"></p><h3 id="2-2-MYSQL"><a href="#2-2-MYSQL" class="headerlink" title="2.2. MYSQL"></a>2.2. MYSQL</h3><h4 id="2-2-1-创建volume"><a href="#2-2-1-创建volume" class="headerlink" title="2.2.1  创建volume"></a>2.2.1  创建<code>volume</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create v1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-2-创建mysql-容器"><a href="#2-2-2-创建mysql-容器" class="headerlink" title="2.2.2  创建mysql 容器"></a>2.2.2  创建mysql 容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-mysql -v v1:/var/lib/mysql -p 3301:3306 -e MYSQL_ROOT_PASSWORD=jack123 --net=pro-net --ip 172.18.0.6 mysql</span><br></pre></td></tr></table></figure><h4 id="2-2-3-客户端连接-执行mysql文件"><a href="#2-2-3-客户端连接-执行mysql文件" class="headerlink" title="2.2.3  客户端连接, 执行mysql文件"></a>2.2.3  客户端连接, 执行mysql文件</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name:my-mysql</span><br><span class="line">ip:centos-ip</span><br><span class="line">端口:3301</span><br><span class="line">user:root</span><br><span class="line">password:jack123</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create schema db_test_springboot collate utf8mb4_0900_ai_ci;</span><br><span class="line">use db_test_springboot;</span><br><span class="line">create table t_user</span><br><span class="line">(</span><br><span class="line">    id int not null</span><br><span class="line">    primary key,</span><br><span class="line">    username varchar(50) not null,</span><br><span class="line">    password varchar(50) not null,</span><br><span class="line">    number varchar(100) not null</span><br><span class="line">);    </span><br></pre></td></tr></table></figure><h3 id="2-3-SpringBoot-项目"><a href="#2-3-SpringBoot-项目" class="headerlink" title="2.3 SpringBoot 项目"></a>2.3 <code>SpringBoot</code> 项目</h3><blockquote><p> <code>SpringBoot</code> + <code>Mybatis</code> 实现<code>CRUD</code> 操作,名称为<code>springboot-mybatis</code></p></blockquote><ol><li>在本地测试该项目的功能</li></ol><p>主要是修改<code>application.yml</code> 文件中数据库的相关配置</p><ol start="2"><li>在项目根目录下执行<code>mvn clean package</code> 打成一个<code>jar</code> 包</li></ol><p>记得修改一下<code>application.yml</code> 文件数据库的配置</p><p><code>mvn clean  package -Dmaven.test.skip=true</code></p><p>在<code>target</code> 目录下找到<code>springboot-mybatis-0.0.1-SNAPSHOT.jar</code></p><p>3 在<code>docker</code>  环境中新建一个目录<code>springboot-mybatis</code></p><p>4 上传<code>springboot-mybatis-0.0.1-SNAPSHOT.jar</code> 到该目录下,并且在此目录下创建<code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">MAINTAINER</span> luyanan0718</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> name=<span class="string">&quot;springboot-mybatis&quot;</span> version=<span class="string">&quot;1.0&quot;</span> author=<span class="string">&quot;luyanan0718&quot;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> springboot-mybatis-0.0.1-SNAPSHOT.jar springboot-mybatis.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;springboot-mybatis.jar&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5 基于<code>Dockerfile</code> 构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t sbm-image .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6  基于<code>image</code> 创建<code>contailer</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name sb01 -p 8081:8080 --net=pro-net --ip 172.18.0.11 sbm-image</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7 查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs sb01</span><br></pre></td></tr></table></figure><p>8  验证</p><p>在浏览器中访问<code>http://192.168.8.118:8081/user/listall</code></p><h4 id="2-3-1-网络问题"><a href="#2-3-1-网络问题" class="headerlink" title="2.3.1 网络问题"></a>2.3.1 网络问题</h4><p>因为<code>sb01</code> 和<code>my-mysql</code> 在同一个<code>bridge</code> 的网段上, 所以是可以互相<code>ping</code> 通的,比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it sb01 ping 172.18.0.6</span><br><span class="line">or</span><br><span class="line">docker <span class="built_in">exec</span> -it sb01 ping my-mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>so? <code>application.yml</code> 文件不妨这样修改一下, 也就是把ip地址直接换成容器的名字</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: jdbc:mysql://my-mysql/db_test_springboot?</span><br></pre></td></tr></table></figure><h4 id="2-3-2-创建多个项目容器"><a href="#2-3-2-创建多个项目容器" class="headerlink" title="2.3.2 创建多个项目容器"></a>2.3.2 创建多个项目容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name sb01 -p 8081:8080 --net=pro-net --ip 172.18.0.11 sbm-image</span><br><span class="line">docker run -d --name sb02 -p 8082:8080 --net=pro-net --ip 172.18.0.12 sbm-image</span><br><span class="line">docker run -d --name sb03 -p 8083:8080 --net=pro-net --ip 172.18.0.13 sbm-image</span><br></pre></td></tr></table></figure><h3 id="2-4-Nginx"><a href="#2-4-Nginx" class="headerlink" title="2.4 Nginx"></a>2.4 Nginx</h3><ol><li><p>在<code>centos</code>  的<code>/tmp/nginx</code> 下新建<code>nginx.conf</code> 文件,并进行相应的配置</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span> <span class="string">nginx;</span></span><br><span class="line"><span class="attr">worker_processes</span> <span class="string">1;</span></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">worker_connections</span> <span class="string">1024;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">include</span> <span class="string">/etc/nginx/mime.types;</span></span><br><span class="line"><span class="attr">default_type</span> <span class="string">application/octet-stream;</span></span><br><span class="line"><span class="attr">sendfile</span> <span class="string">on;</span></span><br><span class="line"><span class="attr">keepalive_timeout</span> <span class="string">65;</span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line"><span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line"><span class="attr">proxy_pass</span> <span class="string">http://balance;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">balance&#123;</span></span><br><span class="line"><span class="attr">server</span> <span class="string">172.18.0.11:8080;</span></span><br><span class="line"><span class="attr">server</span> <span class="string">172.18.0.12:8080;</span></span><br><span class="line"><span class="attr">server</span> <span class="string">172.18.0.13:8080;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">include</span> <span class="string">/etc/nginx/conf.d/*.conf;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建<code>nginx</code> 容器</p><p> 注意: 先在centos7上创建/tmp/nginx目录，并且创建nginx.conf文件，写上内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-nginx -p 80:80 -v /tmp/nginx/nginx.conf:/etc/nginx/nginx.conf --network=pro-net --ip 172.18.0.10 nginx</span><br></pre></td></tr></table></figure></li><li><p>win 浏览器访问: <code>ip/user/install</code></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker实战&quot;&gt;&lt;a href=&quot;#Docker实战&quot; class=&quot;headerlink&quot; title=&quot;Docker实战&quot;&gt;&lt;/a&gt;Docker实战&lt;/h1&gt;&lt;h2 id=&quot;1-Mysql-高可用集群&quot;&gt;&lt;a href=&quot;#1-Mysql-高可用集群&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql 高可用集群&quot;&gt;&lt;/a&gt;1. Mysql 高可用集群&lt;/h2&gt;&lt;h3 id=&quot;1-拉取pxc镜像&quot;&gt;&lt;a href=&quot;#1-拉取pxc镜像&quot; class=&quot;headerlink&quot; title=&quot;1. 拉取pxc镜像&quot;&gt;&lt;/a&gt;1. 拉取&lt;code&gt;pxc&lt;/code&gt;镜像&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull percona/percona-xtradb-cluster:5.7.21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-复制pxc-镜像-实则重命名&quot;&gt;&lt;a href=&quot;#2-复制pxc-镜像-实则重命名&quot; class=&quot;headerlink&quot; title=&quot;2. 复制pxc 镜像(实则重命名)&quot;&gt;&lt;/a&gt;2. 复制&lt;code&gt;pxc&lt;/code&gt; 镜像(实则重命名)&lt;/h3&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker持久化(4)</title>
    <link href="http://luyanan.com/Docker%E6%8C%81%E4%B9%85%E5%8C%96(4)/"/>
    <id>http://luyanan.com/Docker%E6%8C%81%E4%B9%85%E5%8C%96(4)/</id>
    <published>2021-03-12T02:15:06.398Z</published>
    <updated>2021-03-12T02:15:06.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-数据持久化"><a href="#Docker-数据持久化" class="headerlink" title="Docker 数据持久化"></a>Docker 数据持久化</h1><h2 id="1-Volume"><a href="#1-Volume" class="headerlink" title="1. Volume"></a>1. <code>Volume</code></h2><ol><li><p>创建<code>mysql</code> 数据库的<code>contailer</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql01 -e MYSQL_ROOT_PASSWORD=jack123 mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看<code>volume</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li><li><p>具体查看该<code>volume</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect</span><br><span class="line">48507d0e7936f94eb984adf8177ec50fc6a7ecd8745ea0bc165ef485371589e8</span><br></pre></td></tr></table></figure></li><li><p>名字不好看,name太长, 修改一下</p><p> <code>-v mysql01_volume:/var/lib/mysql</code> 表示给上述的<code>vloume</code> 起一个能够识别的名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql01 -v mysql01_volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jack123 mysql</span><br></pre></td></tr></table></figure></li><li><p>查看<code>volume</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br><span class="line">docker volume inspect mysql01 vloume</span><br></pre></td></tr></table></figure></li><li><p>真的能够持久化保存数据吗? 不妨做个试验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql01 bash</span><br><span class="line"><span class="comment">## 登录mysql服务</span></span><br><span class="line">mysql -uroot -pjack123</span><br><span class="line"><span class="comment">## 创建测试库</span></span><br><span class="line">create database db_test</span><br><span class="line"><span class="comment">## 退出mysql, 退出`contailer`</span></span><br><span class="line"><span class="comment">## 删除mysql 容器</span></span><br><span class="line">docker rm -f mysql01</span><br><span class="line"><span class="comment">## 查看`volume`</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="comment">## 发现`volume` 还在</span></span><br><span class="line">DRIVER VOLUME NAME</span><br><span class="line"><span class="built_in">local</span> mysql01_volume</span><br><span class="line"><span class="comment"># 新建一个mysql container，并且指定使用&quot;mysql01_volume&quot;</span></span><br><span class="line">docker run -d --name test-mysql -v mysql01_volume:/var/lib/mysql -e</span><br><span class="line">MYSQL_ROOT_PASSWORD=jack123 mysql</span><br><span class="line"><span class="comment"># 进入容器,登录mysql 服务,查看数据库</span></span><br><span class="line">docker <span class="built_in">exec</span> -it test-mysql bash</span><br><span class="line">mysql -uroot -pjack123</span><br><span class="line">show database;</span><br><span class="line"><span class="comment"># 可以发现db_test仍然在</span></span><br><span class="line"> 可以发现db_test仍然在</span><br><span class="line">| information_schema |</span><br><span class="line">| db_test |</span><br><span class="line">| mysql |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-Bing-Mounting"><a href="#2-Bing-Mounting" class="headerlink" title="2. Bing Mounting"></a>2. Bing Mounting</h2><ol><li><p>创建<code>tomcat</code> 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 9090:8080 -v /tmp/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span> tomcat</span><br></pre></td></tr></table></figure></li><li><p>查看两个目录</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos：<span class="built_in">cd</span> /tmp/<span class="built_in">test</span></span><br><span class="line">tomcat容器：<span class="built_in">cd</span> /usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>centos</code>的<code>/tmp/test</code> 中新建一个<code>1.html</code>并且也有内容</p></li><li><p>在<code>centos7</code> 上访问该路径,<code>curl localhost:9090/test/1.html</code></p></li><li><p>在<code>wim</code> 浏览器上通过<code>ip</code> 访问</p><p><img src="http://files.luyanan.com//img/20200417165112.png" alt="image-20200417165051450"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-数据持久化&quot;&gt;&lt;a href=&quot;#Docker-数据持久化&quot; class=&quot;headerlink&quot; title=&quot;Docker 数据持久化&quot;&gt;&lt;/a&gt;Docker 数据持久化&lt;/h1&gt;&lt;h2 id=&quot;1-Volume&quot;&gt;&lt;a href=&quot;#1-Volume&quot; class=&quot;headerlink&quot; title=&quot;1. Volume&quot;&gt;&lt;/a&gt;1. &lt;code&gt;Volume&lt;/code&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建&lt;code&gt;mysql&lt;/code&gt; 数据库的&lt;code&gt;contailer&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name mysql01 -e MYSQL_ROOT_PASSWORD=jack123 mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看&lt;code&gt;volume&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker volume ls&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体查看该&lt;code&gt;volume&lt;/code&gt;&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker volume inspect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48507d0e7936f94eb984adf8177ec50fc6a7ecd8745ea0bc165ef485371589e8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;名字不好看,name太长, 修改一下&lt;/p&gt;
&lt;p&gt; &lt;code&gt;-v mysql01_volume:/var/lib/mysql&lt;/code&gt; 表示给上述的&lt;code&gt;vloume&lt;/code&gt; 起一个能够识别的名字&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name mysql01 -v mysql01_volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jack123 mysql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看&lt;code&gt;volume&lt;/code&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker volume ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker volume inspect mysql01 vloume&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;真的能够持久化保存数据吗? 不妨做个试验&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 进入容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker &lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt; -it mysql01 bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 登录mysql服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql -uroot -pjack123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 创建测试库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;create database db_test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 退出mysql, 退出`contailer`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 删除mysql 容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker rm -f mysql01&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 查看`volume`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker volume ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 发现`volume` 还在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DRIVER VOLUME NAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; mysql01_volume&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新建一个mysql container，并且指定使用&amp;quot;mysql01_volume&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name test-mysql -v mysql01_volume:/var/lib/mysql -e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MYSQL_ROOT_PASSWORD=jack123 mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 进入容器,登录mysql 服务,查看数据库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker &lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt; -it test-mysql bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql -uroot -pjack123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show database;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 可以发现db_test仍然在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 可以发现db_test仍然在&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| information_schema |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| db_test |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| mysql |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| performance_schema |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;





&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-Bing-Mounting&quot;&gt;&lt;a href=&quot;#2-Bing-Mounting&quot; class=&quot;headerlink&quot; title=&quot;2. Bing Mounting&quot;&gt;&lt;/a&gt;2. Bing Mounting&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建&lt;code&gt;tomcat&lt;/code&gt; 容器&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name tomcat01 -p 9090:8080 -v /tmp/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;:/usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/tomcat/webapps/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt; tomcat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看两个目录&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;centos：&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /tmp/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tomcat容器：&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/tomcat/webapps/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;centos&lt;/code&gt;的&lt;code&gt;/tmp/test&lt;/code&gt; 中新建一个&lt;code&gt;1.html&lt;/code&gt;并且也有内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;centos7&lt;/code&gt; 上访问该路径,&lt;code&gt;curl localhost:9090/test/1.html&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;wim&lt;/code&gt; 浏览器上通过&lt;code&gt;ip&lt;/code&gt; 访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.luyanan.com//img/20200417165112.png&quot; alt=&quot;image-20200417165051450&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://luyanan.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Java IO   演进之路(1)</title>
    <link href="http://luyanan.com/Java%20IO%20%20%20%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF(1)/"/>
    <id>http://luyanan.com/Java%20IO%20%20%20%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF(1)/</id>
    <published>2021-03-12T02:15:06.397Z</published>
    <updated>2021-03-12T02:15:06.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-IO-演进之路"><a href="#Java-IO-演进之路" class="headerlink" title="Java IO  演进之路"></a>Java IO  演进之路</h1><p>在此之前, 必须要了解几个概念</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="阻塞-Block-和非阻塞-Non-Block"><a href="#阻塞-Block-和非阻塞-Non-Block" class="headerlink" title="阻塞(Block) 和非阻塞(Non-Block)"></a>阻塞(Block) 和非阻塞(Non-Block)</h3><p>阻塞和非阻塞是进程在访问数据的时候,数据是否准备就绪的一种处理方式,当数据没有准备的时候</p><p><strong>阻塞:</strong> 往往需要等待缓冲区中的数据准备好了之后才处理其他的事情， 否则一直卡在那里.</p><p>**非阻塞:**当我们的进程访问我们的数据缓冲区的时候,如果数据还没有准备好就直接返回, 不会等待. 如果数据已经准备好,也直接返回。</p><h3 id="同步-Synchronization-和-异步-Asynchronous"><a href="#同步-Synchronization-和-异步-Asynchronous" class="headerlink" title="同步(Synchronization)和  异步(Asynchronous)"></a>同步(Synchronization)和  异步(Asynchronous)</h3><p>同步和异步都是基于应用程序和操作系统处于IO事件所采用的方式, 比如:</p><p><strong>同步:</strong> 是应用程序要直接参与IO读写的操作.</p><p>**异步:**所有的IO读写交给操作系统去处理,应用程序只需要等待通知。</p><p>同步方式在处理IO事件的时候，必须阻塞在某个方法上面等到我们的IO事件完成(阻塞IO事件或者通过轮询IO事件的方式),对于异步来说,所有的IO读写都交给了操作系统.  这个时候,我们就可以做其他的事情,并不需要完成真正的IO操作,当操作完成IO后, 会给我们的应用程序一个通知,</p><p>同步: 阻塞到IO事件, 阻塞到read或者write,这个时候我们就完全不能做自己的事情,让读写方法加入到线程里面, 然后阻塞线程实现, 对线程的性能开销毕竟大.</p><h2 id="BIO与NIO对比"><a href="#BIO与NIO对比" class="headerlink" title="BIO与NIO对比"></a>BIO与NIO对比</h2><p>下表总结了Java BIO(Block IO)和NIO(Non-Block IO) 之间的差异</p><table><thead><tr><th>IO模型</th><th>BIO</th><th>NIO</th></tr></thead><tbody><tr><td>通信</td><td>面向流</td><td>面向缓冲区(多路复用)</td></tr><tr><td>处理</td><td>阻塞IO(多线程)</td><td>非阻塞IO(反应堆Reactor)</td></tr><tr><td>触发</td><td>无</td><td>选择器(轮询机制)</td></tr></tbody></table><h3 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h3><p>java NIO和BIO之间第一个最大的区别是,BIO是面向流的,NIO的面向缓冲区的.Java BIO面向流意味着每次从流中读一个或者多个字节,直至读取所有字节, 他们没有被缓存在任何地方. 此外,他不能前后移动流中的数据. </p><p>如果需要前后移动从流中读取数据,需要先将他们缓存到一个缓冲区. Java NIO的缓冲导向方法略有不同, 数据读取到一个它稍后处理的缓冲区, 需要时可以在缓冲区中前后移动, 这就增加了处理过程的灵活性, 但是, 还需要检查是否该缓冲区中包含所有需要处理的数据, 而且, 需确保当更多的数据读入到缓冲区的时候, 不会覆盖缓冲区里面尚未处理的数据.</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>Java BIO的各种流是阻塞的. 这意味着,当一个线程调用 read()或者 write() 时,该线程被阻塞,直到有一些数据被读取或者数据完全写入, 该线程再次期间不能在干任何是事情了.  Java NIO的非阻塞模式,使一个线程从某通道发送请求读取数据, 但是它仅能够得到目前可用的数据, 如果目前没有数据可用时，就什么都不会获取. 而不是保持线程阻塞, 所以直至数据变的可以读取之前,该线程可以继续做其他的事情, 非阻塞写也是如此, 一个线程请求写入一些数据到某通道,但不需要等待它完全写入, 这个线程同时可以去做别的事情,线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作, 所以一个单独的线程现在可以管理多个输入和输出通道(channel)</p><h3 id="选择器的问世"><a href="#选择器的问世" class="headerlink" title="选择器的问世"></a>选择器的问世</h3><p>Java NIO 的选择器(Selector) 允许一个单独的线程来监视多个输入通道, 你可以注册多个通道使用一个选择器,然后使用一个单独的线程来选择通道, 这些通道里已经可以处理的输入,或者选择已准备写入的通道,这种选择机制,使得一个单独的线程很容易的来管理多个通道.</p><h3 id="NIO和BIO-如何影响应用程序的设计"><a href="#NIO和BIO-如何影响应用程序的设计" class="headerlink" title="NIO和BIO 如何影响应用程序的设计"></a>NIO和BIO 如何影响应用程序的设计</h3><p>无论是选择NIO还是BIO工具, 可能会响应你应用程序设计的以下几个方面:</p><ol><li>对NIO或者BIO类的AIP的调用</li><li>数据处理逻辑</li><li>用来处理数据的线程数</li></ol><h4 id="1-API调用"><a href="#1-API调用" class="headerlink" title="1. API调用"></a>1. API调用</h4><p>当然,使用NIO掉的调用时看起来与使用BIO时有所不同,但这并不意外，以为并不是仅从一个InputStream 逐字节读取,而是数据必须先读取缓冲区再处理、。</p><h4 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2. 数据处理"></a>2. 数据处理</h4><p>使用纯粹的NIO 设计相较BIO设计,数据处理也收到影响</p><p>在BIO设计中, 我们从 inputstream 或者Reader 逐字节读取数据, 假设你正在处理一基于行的文本数据流,例如有如下一段文本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name:Tom</span><br><span class="line">Age:18 </span><br><span class="line">Email: tom@qq.com </span><br><span class="line">Phone:13888888888</span><br></pre></td></tr></table></figure><p>该文本行的流可以这样处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:/info.txt&quot;</span>);</span><br><span class="line">  BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">  String nameLine = reader.readLine();</span><br><span class="line">  String ageLine = reader.readLine();</span><br><span class="line">  String emailLine = reader.readLine();</span><br><span class="line">  String phoneLine = reader.readLine();</span><br></pre></td></tr></table></figure><p>请注意处理状态 由程序执行多久决定. 换句话来说,一旦readLine() 方法返回,你就知道肯定文本行已经读完了, readline() 阻塞直到整行读完, 这就是原因. 你也知道此行包含名称; 同样,第二个readline() 调用返回的时候, 你知道这行包含年龄. 正如你可以看到.该处理程序仅在有新数据读取的时候运行, 并知道每步的数据是什么. 一旦正在运行的线程已处理过读取的某些数据, 该线程不会再回退数据(大多如此). 下图也说明了这条原则:</p><p><img src="http://files.luyanan.com//img/20190909103147.png"></p><p>(java BIO:  从一个阻塞的流中读取数据),而NIO的实现会有所不同,下面是一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br></pre></td></tr></table></figure><p>注意 第二行,从通道读取字节到ByteBuffer . 当这个方法调用返回时,你不知道你所需的所有数据是否在缓冲区. 你所知道的是, 该缓冲区包含一些字节, 这使得处理有点困难.</p><p>假设第一次 read(buffer) 调用后, 读取缓冲区的数据只有半行,例如 “Name:An”, 你能处理吗? 显然不能, 需要等到. 直到整行数据读取缓存, 在此之前, 对数据的任何处理毫无意义.</p><p>所以, 你怎么知道是否该缓冲区中包含了足够的数据可以处理了呢? 好了, 你不知道, 发现的方法只能查看缓冲区中的数据. 其结果是,在你知道所有数据都在缓冲区里之前,你必须检查几次缓冲区的数据, 这不仅效率低下,而且可能使得线程设计方案杂乱不堪。 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer); </span><br><span class="line"><span class="keyword">while</span>(!bufferFull(bytesRead)) &#123;</span><br><span class="line">    bytesRead = inChannel.read(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bufferFull() 方法必须跟踪有多少数据读入缓冲区, 并返回真或者假, 这取决于缓冲区是否已满。 换句话来说, 如果缓冲区准备好被处理了,那么表示缓冲区满了.</p><p>bufferFull(） 方法扫描缓冲区, 但必须保持在bufferFull() 方法被调用之前状态相同，如果没有, 下一个读取缓冲区的数据可能无法读取到正确的位置, 这是不可能的  这确实需要注意的又一问题.</p><p>如果缓冲区已满, 他可以被处理,如果它不满, 并且在你的实际案例中有意义. 你或者能处理其中的部分数据, 但是许多情况下,并非如此. 下图展示了”缓冲区数据循环就绪“</p><p><img src="http://files.luyanan.com//img/20190909105442.png"></p><h4 id="3-设置处理线程数"><a href="#3-设置处理线程数" class="headerlink" title="3. 设置处理线程数"></a>3. 设置处理线程数</h4><p>NIO 可让你只使用一个(或几个)单线程管理多个通道(网络连接或文件), 但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p><p>如果需要管理同时打开的成千上万的连接, 这些连接每次只是发送少量的数据, 例如聊天服务器, 实现NIO的服务器可能是一个优势. 同样, 如果你需要维持许多打开的连接到其他计算机上, 如P2P网络中, 使用一个单独的线程来管理你所有出站连接, 可能是一个优势, 一个线程多个连接的设计方案如:</p><p><img src="http://files.luyanan.com//img/20190909110834.png"></p><p>Java NIO: 单线程管理多个连接。</p><p>如果你有少量的连接使用非常高的带宽, 一次发送大量的数据, 必须典型的IO 服务器实现非常契合. 下图说明了一个典型的IO服务器设计:</p><p> <img src="http://files.luyanan.com//img/20190909111038.png"></p><p>Java BIO: 一个典型的IO服务器设计- 一个连接通过一个线程处理.，</p><h3 id="NIO-服务端代码示例"><a href="#NIO-服务端代码示例" class="headerlink" title="NIO 服务端代码示例"></a>NIO 服务端代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.notes.io.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;NIO 服务端&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;轮询器&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/9/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;缓冲区&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2019/9/9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOServerDemo</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="comment">// 绑定ip/端口号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// BIO  升级版本NIO。 为了兼容BIO,NIO模型默认是采用阻塞</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;listen on :&quot;</span> + <span class="keyword">this</span>.port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  轮询主线程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">//  不断的迭代,就叫轮询</span></span><br><span class="line">            <span class="comment">// 同步体现在这里, 因为每次只能拿到一个Key, 每次只能处理一种状态</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                process(key);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对每一种状态给一个反应</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//  这个方法体现非阻塞, 不管你数据有没有准备好, 你都要给我一个状态和反馈</span></span><br><span class="line">            SocketChannel channel = server.accept();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 当数据准备就绪的时候, 将状态设置为可读</span></span><br><span class="line">            key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">int</span> len = socketChannel.read(buffer);</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                String content = <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len);</span><br><span class="line">                key = socketChannel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                key.attach(content);</span><br><span class="line">                System.out.println(<span class="string">&quot;读取内容:&quot;</span> + content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">            String content = (String) key.attachment();</span><br><span class="line">            channel.write(ByteBuffer.wrap((<span class="string">&quot;输出:&quot;</span> + content).getBytes()));</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> NIOServerDemo(<span class="number">8080</span>).listen();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java-AIO-详解"><a href="#Java-AIO-详解" class="headerlink" title="Java AIO 详解"></a>Java AIO 详解</h2><p>JDK1.7(NIO2) 才是实现真正的异步AIO, 把IO读写操作完全交给了操作系统, </p><h3 id="1-AIO-Asynchronout-IO-基本原理"><a href="#1-AIO-Asynchronout-IO-基本原理" class="headerlink" title="1. AIO(Asynchronout IO) 基本原理"></a>1. AIO(Asynchronout IO) 基本原理</h3><p>服务端:AsynchronousServerSocketChannel</p><p>客户端: AsynchronousSocketChannel</p><p>用户处理器: CompletionHandler 接口, 这个接口实现应用程序向操作系统发起IO请求, 当完成后处理具体逻辑,否则做自己该做的事情.</p><p>“真正”的异步IO 需要操作系统更强的支持,在IO多路复用模型中 事件循环将文件句柄的状态事件通知给用户线程, 由用户线程自行读取数据、处理数据 . 而在异步IO模型中， 当用户线程收到通知时, 数据已经被内核读取完毕了, 并放在了用户线程指定的缓冲区内, 内核在IO完成后通知用户线程直接使用即可. 异步IO模型使用了Proactor 设计模式实现了这一机制, 如下图所示：</p><p><img src="http://files.luyanan.com//img/20190909112008.png"></p><h3 id="2-AOP-初体验"><a href="#2-AOP-初体验" class="headerlink" title="2. AOP 初体验"></a>2. AOP 初体验</h3><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.notes.io.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;AIO 服务端&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AIOServer(<span class="number">8080</span>).listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">            AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withCachedThreadPool(executorService, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//  工作线程, 用于监听回调的, 事件响应的时候需要回调.</span></span><br><span class="line">            AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open(channelGroup);</span><br><span class="line">            <span class="comment">// 设置端口号</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.port));</span><br><span class="line">            System.out.println(<span class="string">&quot;服务已经启动, 端口号为:&quot;</span> + <span class="keyword">this</span>.port);</span><br><span class="line">            serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">                <span class="comment">//   实现 completed 方法来回调</span></span><br><span class="line">                <span class="comment">// 由操作系统出发, 回调有两个状态, 成功/ 失败</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;IO操作开始, 开始获取数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        result.read(buffer).get();</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        result.write(buffer);</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            result.close();</span><br><span class="line">                            serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;操作完成&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;操作失败:&quot;</span> + exc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.notes.io.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;AIO 客户端&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asynchronousSocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        asynchronousSocketChannel = AsynchronousSocketChannel.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        asynchronousSocketChannel.connect(<span class="keyword">new</span> InetSocketAddress(host, port), <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Void, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    asynchronousSocketChannel.write(ByteBuffer.wrap(<span class="string">&quot;这是一条测试数据&quot;</span>.getBytes())).get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        asynchronousSocketChannel.read(bb, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class