<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员报社</title>
  
  <subtitle>程序员报社</subtitle>
  <link href="http://luyanan.com/atom.xml" rel="self"/>
  
  <link href="http://luyanan.com/"/>
  <updated>2021-03-12T02:17:43.965Z</updated>
  <id>http://luyanan.com/</id>
  
  <author>
    <name>luyanan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载器</title>
    <link href="http://luyanan.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://luyanan.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2021-03-12T02:17:43.965Z</published>
    <updated>2021-03-12T02:17:43.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="1-Java类加载器"><a href="#1-Java类加载器" class="headerlink" title="1. Java类加载器"></a>1. Java类加载器</h2><ul><li>Java源代码.java文件通过编译成字节码.class文件后，需要被加载到Java虚拟机的内存空间中使用，这个过程就是类加载。类加载依靠的是Java类加载器</li><li>Java类加载器是Java运行时环境的一部分，负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载的，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件的位置与文件系统。</li></ul><h2 id="2-JVM的3个默认类加载器"><a href="#2-JVM的3个默认类加载器" class="headerlink" title="2. JVM的3个默认类加载器"></a>2. JVM的3个默认类加载器</h2><ol><li>引导（Bootstrap）类加载器。由原生代码C语言编写，不继承java.lang.ClassLoader。负责加载核心Java库，存储在<JAVA_HOME>/jre/lib目录中。</li><li>扩展（Extensions）类加载器。用来在指明的目录中加载Java的扩展类。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载Java类。该类由sun.misc.Launcher$ExtClassLoader实现。</li><li>Apps类加载器（也称系统类加载器）。根据Java应用程序的类路径来加载Java类。一般来说，Java应用程序的类都是由它来完成加载的，可以通过ClassLoader.getSystemClassLoader()来获取它。该类由sun.misc.Launcher$AppClassLoader来实现。</li></ol><ul><li>每一个类加载器都有一个父装载器（parent class loader）。</li></ul><h2 id="3-如何保证一个类被加载一次"><a href="#3-如何保证一个类被加载一次" class="headerlink" title="3. 如何保证一个类被加载一次"></a>3. 如何保证一个类被加载一次</h2><ul><li>全盘负责委托机制</li><li>解释：当一个ClassLoader加载一个Class的时候，这个Class所依赖的和引用的其他Class通常也是由这个classloader负责载入的。例如加载一个普通的Demo类，Apps类加载器首先拿到这个类的class文件，先让parent（父）类加载器也就是扩展（Extensions）类加载器处理。扩展（Extensions）类加载器拿到class文件后同样先让parent（父）类加载器处理，也就是引导（Bootstrap）类加载器会先处理属于它应该加载的部分。引导类加载器处理完成后，把剩下的给扩展类加载器。扩展类加载器处理属于它的内容，将剩下的部分交给Apps类加载器，Apps类加载器会加载剩下的全部内容。</li><li>每个类加载器只会加载自己负责的部分。</li><li>这样每个类只会被加载一次。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;类加载器&quot;&gt;&lt;a href=&quot;#类加载器&quot; class=&quot;headerlink&quot; title=&quot;类加载器&quot;&gt;&lt;/a&gt;类加载器&lt;/h1&gt;&lt;h2 id=&quot;1-Java类加载器&quot;&gt;&lt;a href=&quot;#1-Java类加载器&quot; class=&quot;headerlink&quot; title=&quot;1. Java类加载器&quot;&gt;&lt;/a&gt;1. Java类加载器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java源代码.java文件通过编译成字节码.class文件后，需要被加载到Java虚拟机的内存空间中使用，这个过程就是类加载。类加载依靠的是Java类加载器&lt;/li&gt;
&lt;li&gt;Java类加载器是Java运行时环境的一部分，负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载的，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件的位置与文件系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-JVM的3个默认类加载器&quot;&gt;&lt;a href=&quot;#2-JVM的3个默认类加载器&quot; class=&quot;headerlink&quot; title=&quot;2. JVM的3个默认类加载器&quot;&gt;&lt;/a&gt;2. JVM的3个默认类加载器&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;引导（Bootstrap）类加载器。由原生代码C语言编写，不继承java.lang.ClassLoader。负责加载核心Java库，存储在&lt;java_home&gt;/jre/lib目录中。&lt;/java_home&gt;&lt;/li&gt;
&lt;li&gt;扩展（Extensions）类加载器。用来在指明的目录中加载Java的扩展类。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载Java类。该类由sun.misc.Launcher$ExtClassLoader实现。&lt;/li&gt;
&lt;li&gt;Apps类加载器（也称系统类加载器）。根据Java应用程序的类路径来加载Java类。一般来说，Java应用程序的类都是由它来完成加载的，可以通过ClassLoader.getSystemClassLoader()来获取它。该类由sun.misc.Launcher$AppClassLoader来实现。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池与ThreadPoolExecutor类浅析</title>
    <link href="http://luyanan.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8EThreadPoolExecutor%E7%B1%BB%E6%B5%85%E6%9E%90/"/>
    <id>http://luyanan.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8EThreadPoolExecutor%E7%B1%BB%E6%B5%85%E6%9E%90/</id>
    <published>2021-03-12T02:17:43.965Z</published>
    <updated>2021-03-12T02:17:43.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池与ThreadPoolExecutor类浅析"><a href="#线程池与ThreadPoolExecutor类浅析" class="headerlink" title="线程池与ThreadPoolExecutor类浅析"></a>线程池与ThreadPoolExecutor类浅析</h1><h2 id="一、Thread直接创建线程的弊端"><a href="#一、Thread直接创建线程的弊端" class="headerlink" title="一、Thread直接创建线程的弊端"></a>一、Thread直接创建线程的弊端</h2><p>（1）每次new Thread新建对象，性能差。<br>（2）线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM。<br>（3）缺少更多的功能，如更多执行、定期执行、线程中断。<br>（4）其他弊端，大家自行脑补，多动脑，没坏处，哈哈。</p><h2 id="二、线程池的好处"><a href="#二、线程池的好处" class="headerlink" title="二、线程池的好处"></a>二、线程池的好处</h2><p>（1）重用存在的线程，减少对象创建、消亡的开销，性能佳。<br>（2）可以有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。<br>（3）提供定时执行、定期执行、单线程、并发数控制等功能。<br>（4）提供支持线程池监控的方法，可对线程池的资源进行实时监控。<br>（5）其他好处，大家自行脑补，多动脑，没坏处，哈哈。</p><h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><h4 id="1-线程池类结构关系"><a href="#1-线程池类结构关系" class="headerlink" title="1.线程池类结构关系"></a>1.线程池类结构关系</h4><p>线程池中的一些接口和类的结构关系如下图所示。</p><p><img src="https://image-static.segmentfault.com/419/951/4199516322-5e527b8f1f2e1_articlex" alt="file"></p><p>后文会死磕这些接口和类的底层原理和源码。</p><h4 id="2-创建线程池常用的类——Executors"><a href="#2-创建线程池常用的类——Executors" class="headerlink" title="2.创建线程池常用的类——Executors"></a>2.创建线程池常用的类——Executors</h4><ul><li>Executors.newCachedThreadPool：创建一个可缓存的线程池，如果线程池的大小超过了需要，可以灵活回收空闲线程，如果没有可回收线程，则新建线程</li><li>Executors.newFixedThreadPool：创建一个定长的线程池，可以控制线程的最大并发数，超出的线程会在队列中等待</li><li>Executors.newScheduledThreadPool：创建一个定长的线程池，支持定时、周期性的任务执行</li><li>Executors.newSingleThreadExecutor: 创建一个单线程化的线程池，使用一个唯一的工作线程执行任务，保证所有任务按照指定顺序（先入先出或者优先级）执行</li><li>Executors.newSingleThreadScheduledExecutor:创建一个单线程化的线程池，支持定时、周期性的任务执行</li><li>Executors.newWorkStealingPool：创建一个具有并行级别的work-stealing线程池</li></ul><h4 id="3-线程池实例的几种状态"><a href="#3-线程池实例的几种状态" class="headerlink" title="3.线程池实例的几种状态"></a>3.线程池实例的几种状态</h4><ul><li>Running:运行状态，能接收新提交的任务，并且也能处理阻塞队列中的任务</li><li>Shutdown: 关闭状态，不能再接收新提交的任务，但是可以处理阻塞队列中已经保存的任务，当线程池处于Running状态时，调用shutdown()方法会使线程池进入该状态</li><li>Stop: 不能接收新任务，也不能处理阻塞队列中已经保存的任务，会中断正在处理任务的线程，如果线程池处于Running或Shutdown状态，调用shutdownNow()方法，会使线程池进入该状态</li><li>Tidying: 如果所有的任务都已经终止，有效线程数为0（阻塞队列为空，线程池中的工作线程数量为0），线程池就会进入该状态。</li><li>Terminated: 处于Tidying状态的线程池调用terminated()方法，会使用线程池进入该状态</li></ul><p>注意：不需要对线程池的状态做特殊的处理，线程池的状态是线程池内部根据方法自行定义和处理的。</p><h4 id="4-合理配置线程的一些建议"><a href="#4-合理配置线程的一些建议" class="headerlink" title="4.合理配置线程的一些建议"></a>4.合理配置线程的一些建议</h4><p>（1）CPU密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1(CPU的数量加1)。<br>（2）IO密集型任务，参考值可以设置为2*NCPU（CPU数量乘以2）</p><h2 id="四、线程池最核心的类之一——ThreadPoolExecutor"><a href="#四、线程池最核心的类之一——ThreadPoolExecutor" class="headerlink" title="四、线程池最核心的类之一——ThreadPoolExecutor"></a>四、线程池最核心的类之一——ThreadPoolExecutor</h2><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><p>ThreadPoolExecutor参数最多的构造方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler rejectHandler) </span><br></pre></td></tr></table></figure><p>其他的构造方法都是调用的这个构造方法来实例化对象，可以说，我们直接分析这个方法之后，其他的构造方法我们也明白是怎么回事了！接下来，就对此构造方法进行详细的分析。</p><p>注意：为了更加深入的分析ThreadPoolExecutor类的构造方法，会适当调整参数的顺序进行解析，以便于大家更能深入的理解ThreadPoolExecutor构造方法中每个参数的作用。</p><p>上述构造方法接收如下参数进行初始化：</p><p>（1）corePoolSize：核心线程数量。</p><p>（2）maximumPoolSize：最大线程数。</p><p>（3）workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响。</p><p>其中，上述三个参数的关系如下所示：</p><ul><li>如果运行的线程数小于corePoolSize，直接创建新线程处理任务，即使线程池中的其他线程是空闲的。</li><li>如果运行的线程数大于等于corePoolSize，并且小于maximumPoolSize，此时，只有当workQueue满时，才会创建新的线程处理任务。</li><li>如果设置的corePoolSize与maximumPoolSize相同，那么创建的线程池大小是固定的，此时，如果有新任务提交，并且workQueue没有满时，就把请求放入到workQueue中，等待空闲的线程，从workQueue中取出任务进行处理。</li><li>如果运行的线程数量大于maximumPoolSize，同时，workQueue已经满了，会通过拒绝策略参数rejectHandler来指定处理策略。</li></ul><p>根据上述三个参数的配置，线程池会对任务进行如下处理方式：</p><p>当提交一个新的任务到线程池时，线程池会根据当前线程池中正在运行的线程数量来决定该任务的处理方式。处理方式总共有三种：直接切换、使用无限队列、使用有界队列。</p><ul><li>直接切换常用的队列就是SynchronousQueue。</li><li>使用无限队列就是使用基于链表的队列，比如：LinkedBlockingQueue，如果使用这种方式，线程池中创建的最大线程数就是corePoolSize，此时maximumPoolSize不会起作用。当线程池中所有的核心线程都是运行状态时，提交新任务，就会放入等待队列中。</li><li>使用有界队列使用的是ArrayBlockingQueue，使用这种方式可以将线程池的最大线程数量限制为maximumPoolSize，可以降低资源的消耗。但是，这种方式使得线程池对线程的调度更困难，因为线程池和队列的容量都是有限的了。</li></ul><p>根据上面三个参数，我们可以简单得出如何降低系统资源消耗的一些措施：</p><ul><li>如果想降低系统资源的消耗，包括CPU使用率，操作系统资源的消耗，上下文环境切换的开销等，可以设置一个较大的队列容量和较小的线程池容量。这样，会降低线程处理任务的吞吐量。</li><li>如果提交的任务经常发生阻塞，可以考虑调用设置最大线程数的方法，重新设置线程池最大线程数。如果队列的容量设置的较小，通常需要将线程池的容量设置的大一些，这样，CPU的使用率会高些。如果线程池的容量设置的过大，并发量就会增加，则需要考虑线程调度的问题，反而可能会降低处理任务的吞吐量。</li></ul><p>接下来，我们继续看ThreadPoolExecutor的构造方法的参数。</p><p>（4）keepAliveTime：线程没有任务执行时最多保持多久时间终止<br>当线程池中的线程数量大于corePoolSize时，如果此时没有新的任务提交，核心线程外的线程不会立即销毁，需要等待，直到等待的时间超过了keepAliveTime就会终止。</p><p>（5）unit：keepAliveTime的时间单位</p><p>（6）threadFactory：线程工厂，用来创建线程<br>默认会提供一个默认的工厂来创建线程，当使用默认的工厂来创建线程时，会使新创建的线程具有相同的优先级，并且是非守护的线程，同时也设置了线程的名称</p><p>（7）rejectHandler：拒绝处理任务时的策略</p><p>如果workQueue阻塞队列满了，并且没有空闲的线程池，此时，继续提交任务，需要采取一种策略来处理这个任务。<br>线程池总共提供了四种策略：</p><ul><li>直接抛出异常，这也是默认的策略。实现类为AbortPolicy。</li><li>用调用者所在的线程来执行任务。实现类为CallerRunsPolicy。</li><li>丢弃队列中最靠前的任务并执行当前任务。实现类为DiscardOldestPolicy。</li><li>直接丢弃当前任务。实现类为DiscardPolicy。</li></ul><h4 id="2-ThreadPoolExecutor提供的启动和停止任务的方法"><a href="#2-ThreadPoolExecutor提供的启动和停止任务的方法" class="headerlink" title="2.ThreadPoolExecutor提供的启动和停止任务的方法"></a>2.ThreadPoolExecutor提供的启动和停止任务的方法</h4><p>（1）execute():提交任务，交给线程池执行<br>（2）submit():提交任务，能够返回执行结果 execute+Future<br>（3）shutdown():关闭线程池，等待任务都执行完<br>（4）shutdownNow():立即关闭线程池，不等待任务执行完</p><h4 id="3-ThreadPoolExecutor提供的适用于监控的方法"><a href="#3-ThreadPoolExecutor提供的适用于监控的方法" class="headerlink" title="3.ThreadPoolExecutor提供的适用于监控的方法"></a>3.ThreadPoolExecutor提供的适用于监控的方法</h4><p>（1）getTaskCount()：线程池已执行和未执行的任务总数<br>（2）getCompletedTaskCount()：已完成的任务数量<br>（3）getPoolSize()：线程池当前的线程数量<br>（4）getCorePoolSize()：线程池核心线程数<br>（5）getActiveCount():当前线程池中正在执行任务的线程数量</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程池与ThreadPoolExecutor类浅析&quot;&gt;&lt;a href=&quot;#线程池与ThreadPoolExecutor类浅析&quot; class=&quot;headerlink&quot; title=&quot;线程池与ThreadPoolExecutor类浅析&quot;&gt;&lt;/a&gt;线程池与ThreadPoolExecutor类浅析&lt;/h1&gt;&lt;h2 id=&quot;一、Thread直接创建线程的弊端&quot;&gt;&lt;a href=&quot;#一、Thread直接创建线程的弊端&quot; class=&quot;headerlink&quot; title=&quot;一、Thread直接创建线程的弊端&quot;&gt;&lt;/a&gt;一、Thread直接创建线程的弊端&lt;/h2&gt;&lt;p&gt;（1）每次new Thread新建对象，性能差。&lt;br&gt;（2）线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM。&lt;br&gt;（3）缺少更多的功能，如更多执行、定期执行、线程中断。&lt;br&gt;（4）其他弊端，大家自行脑补，多动脑，没坏处，哈哈。&lt;/p&gt;
&lt;h2 id=&quot;二、线程池的好处&quot;&gt;&lt;a href=&quot;#二、线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;二、线程池的好处&quot;&gt;&lt;/a&gt;二、线程池的好处&lt;/h2&gt;&lt;p&gt;（1）重用存在的线程，减少对象创建、消亡的开销，性能佳。&lt;br&gt;（2）可以有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。&lt;br&gt;（3）提供定时执行、定期执行、单线程、并发数控制等功能。&lt;br&gt;（4）提供支持线程池监控的方法，可对线程池的资源进行实时监控。&lt;br&gt;（5）其他好处，大家自行脑补，多动脑，没坏处，哈哈。&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="http://luyanan.com/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://luyanan.com/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2021-03-12T02:17:43.964Z</published>
    <updated>2021-03-12T02:17:43.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>在数据库操作过程中，为了避免两个或多个用户同时对一条数据操作，通常采用锁的机制来来解决数据冲突问题。<br>同样，在程序流程中为了避免对多线程共享的资源的修改冲突，也采用锁的机制来避免修改冲突</p><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h2 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h2><p>所谓乐观锁，就是相信大部分场景下，不会产生数据修改冲突，所以在读取数据进行修改的时候，不对数据进行加锁，而是在最终提交修改的时候，通过version或CAS机制，检查对数据的修改是否发生了冲突。<br>乐观锁的适用于读多写少的场景，能提供系统的处理能力，如果在冲突比较概率高的场景使用乐观锁，反而会降低系统的处理能力。</p><h2 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h2><p>所谓悲观锁，就是认为对数据修改发生冲突的概率比较大，所以在读取数据进行修改的时候，先用“排他写锁”锁住数据，Block其他人的操作，等修改完成后，再释放锁。<br>此模式比较适用于数据修改冲突发生概率高的场景，但会一定程度降低系统的处理能力。</p><h1 id="数据库场景"><a href="#数据库场景" class="headerlink" title="数据库场景"></a>数据库场景</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>数据的行锁、表锁、读锁、写锁都属于悲观锁，典型的就是<code>select * from xxx where id=n for update</code>命令。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="CAS机制（compare-and-swap）"><a href="#CAS机制（compare-and-swap）" class="headerlink" title="CAS机制（compare and swap）"></a>CAS机制（compare and swap）</h3><p>假设有一条订单（order）数据，ID为1，订单状态（status）是已付款，这个时候，商家打开订单列表，准备进行发货；在商家打开订单后，这时候用户在APP端取消了订单，但是商家不知道；商家执行发货的时候；这时候商家操作发货，如果只根据ID进行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update order set status&#x3D;&#39;已发货&#39; where id&#x3D;1</span><br></pre></td></tr></table></figure><p>则会导致取消的订单被发货，此时，使用CAS机制，在更新数据的时候检查订单状态是否正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update order set status&#x3D;&#39;已发货&#39; where id&#x3D;1 and status&#x3D;&#39;已付款&#39;</span><br></pre></td></tr></table></figure><p>并通过检查update语句发返回值，可以确认时数据更新是否成功。</p><h3 id="Version机制"><a href="#Version机制" class="headerlink" title="Version机制"></a>Version机制</h3><p>Version机制，是在order表中增加一个数字型的version字段，每次查下数据的时候，都带上version字段。更新数据是，把version字段加1。以上述订单为例，比如：</p><ol><li>订单创建后version为1；</li><li>付款后version为2；</li><li>此时商家准备发货，读到的version为2；</li><li>用户取消订单后，version为3；</li><li>商家发货是，更新订单状态是，发现version不是读取时的2，说明订单已经被更新，系统驳回商家的修改，并提升商家。</li></ol><h1 id="JAVA锁场景"><a href="#JAVA锁场景" class="headerlink" title="JAVA锁场景"></a>JAVA锁场景</h1><p>Java中， <code>java.util.concurrent.atomic</code>包下的原子变量属于使用CAS计算的乐观锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123; </span><br><span class="line">  private volatile int value; </span><br><span class="line"> </span><br><span class="line">  public final int get() &#123; </span><br><span class="line">    return value; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  public final int getAndIncrement() &#123; </span><br><span class="line">    for (;;) &#123; </span><br><span class="line">      int current &#x3D; get(); </span><br><span class="line">      int next &#x3D; current + 1; </span><br><span class="line">      if (compareAndSet(current, next)) </span><br><span class="line">        return current; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  public final boolean compareAndSet(int expect, int update) &#123; </span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAndIncrement 采用了CAS机制，每次从内存中读取数据，然后将此数据和 +1 后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。<br>compareAndSet 利用JNI来完成CPU指令的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;  </span><br><span class="line">  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)逻辑类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (this &#x3D;&#x3D; expect) &#123;</span><br><span class="line">   this &#x3D; update</span><br><span class="line">   return true;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而<code>synchronized</code>关键字属于悲观锁。</p><h1 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>如线程1读取了一个变量的值为A；这时候线程2修改变量的值B；线程3有把变量值改回为A；此时，线程1再去更新此变量，会认为此变量未被其他人更新过，但其实变量已经被更新了多次。<br>所以CAS是适用于对象子包含单个共享变量的原子操作，对于对象中包含多个共享变量的情况无法保证原子性。</p><h2 id="锁开销"><a href="#锁开销" class="headerlink" title="锁开销"></a>锁开销</h2><p>对于资源竞争比较激烈的情况，CAS自旋的概率较大，会导致CPU开销增大，效率会低于<code>synchronized</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;锁机制&quot;&gt;&lt;a href=&quot;#锁机制&quot; class=&quot;headerlink&quot; title=&quot;锁机制&quot;&gt;&lt;/a&gt;锁机制&lt;/h1&gt;&lt;p&gt;在数据库操作过程中，为了避免两个或多个用户同时对一条数据操作，通常采用锁的机制来来解决数据冲突问题。&lt;br&gt;同样，在程序流程中为了避免对多线程共享的资源的修改冲突，也采用锁的机制来避免修改冲突&lt;/p&gt;
&lt;h1 id=&quot;锁的分类&quot;&gt;&lt;a href=&quot;#锁的分类&quot; class=&quot;headerlink&quot; title=&quot;锁的分类&quot;&gt;&lt;/a&gt;锁的分类&lt;/h1&gt;&lt;h2 id=&quot;乐观锁（Optimistic-Lock）&quot;&gt;&lt;a href=&quot;#乐观锁（Optimistic-Lock）&quot; class=&quot;headerlink&quot; title=&quot;乐观锁（Optimistic Lock）&quot;&gt;&lt;/a&gt;乐观锁（Optimistic Lock）&lt;/h2&gt;&lt;p&gt;所谓乐观锁，就是相信大部分场景下，不会产生数据修改冲突，所以在读取数据进行修改的时候，不对数据进行加锁，而是在最终提交修改的时候，通过version或CAS机制，检查对数据的修改是否发生了冲突。&lt;br&gt;乐观锁的适用于读多写少的场景，能提供系统的处理能力，如果在冲突比较概率高的场景使用乐观锁，反而会降低系统的处理能力。&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>常见多线程面试题</title>
    <link href="http://luyanan.com/%E5%B8%B8%E8%A7%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://luyanan.com/%E5%B8%B8%E8%A7%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-12T02:17:43.964Z</published>
    <updated>2021-03-12T02:17:43.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-启动一个线程是调用-run-方法还是-start-方法？"><a href="#1-启动一个线程是调用-run-方法还是-start-方法？" class="headerlink" title="1.启动一个线程是调用 run() 方法还是 start() 方法？"></a>1.启动一个线程是调用 run() 方法还是 start() 方法？</h2><p>启动一个线程调用的是start()方法，使线程进入到就绪状态，这就意味着它可以由JVM调度并执行，这并不意味着线程就会立马执行；run()方法是线程启动后线程要进行回调的方法。</p><h2 id="2-请说出同步线程及线程调度相关的方法？"><a href="#2-请说出同步线程及线程调度相关的方法？" class="headerlink" title="2. 请说出同步线程及线程调度相关的方法？"></a>2. 请说出同步线程及线程调度相关的方法？</h2><ul><li><p>wait():使一个线程处于阻塞状态，并且释放所持有的对象锁；</p></li><li><p>sleep():使一个线程休眠一段时间，当时间过后线程又会恢复到以前的状态，并且在休眠状态不会释放对象锁；</p></li><li><p>notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p></li><li><p>notifyAll():唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p></li></ul><h2 id="3-线程和进程的区别？"><a href="#3-线程和进程的区别？" class="headerlink" title="3.线程和进程的区别？"></a>3.线程和进程的区别？</h2><ul><li><p>进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位。</p></li><li><p>线程：是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。</p></li></ul><p>特点：线程的划分尺度小于进程，这使多线程程序拥有高并发性，进程在运行时各自内存单元相互独立，线程之间内存共享，这使多线程编程可以拥有更好的性能和用户体验</p><h2 id="4-Java-中多线程间的通信怎么实现"><a href="#4-Java-中多线程间的通信怎么实现" class="headerlink" title="4.Java 中多线程间的通信怎么实现 ?"></a>4.Java 中多线程间的通信怎么实现 ?</h2><p>1.共享变量：线程间通信可以通过发送信号，发送信号的一个简单方式是在共享对象的变量里设置信号值’;</p><p>2.wait/notify 机制:以资源为例，生产者生产一个资源，通知消费者就消费掉一个资源，生产者继续生产资源，消费者消费资源，以此循环;</p><h2 id="5-什么情况下导致线程死锁，遇到线程死锁该怎么解决？"><a href="#5-什么情况下导致线程死锁，遇到线程死锁该怎么解决？" class="headerlink" title="5.什么情况下导致线程死锁，遇到线程死锁该怎么解决？"></a>5.什么情况下导致线程死锁，遇到线程死锁该怎么解决？</h2><p>死锁的定义：所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进</p><p>死锁产生的原因:系统资源的竞争,进程运行推进顺序不合适</p><p><strong>如何避免死锁</strong>:</p><ol><li><p>加锁顺序（线程按照一定的顺序加锁）</p></li><li><p>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</p></li></ol><p>同一个类中的 2 个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗？</p><p>这个问题需要考虑到Lock与synchronized 两种实现锁的不同情形。因为这种情况下使用Lock 和synchronized会有截然不同的结果。Lock 可以让等待锁的线程响应中断，Lock 获取锁，之后需要释放锁。而 synchronized 却不行，使用 synchronized 时，当我们访问同一个类对象的时候，是同一把锁，所以可以访问该对象的其他 synchronized 方法。</p><h2 id="7-请叙述一下您对线程池的理解？"><a href="#7-请叙述一下您对线程池的理解？" class="headerlink" title="7.请叙述一下您对线程池的理解？"></a>7.请叙述一下您对线程池的理解？</h2><ul><li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="8-常用的线程池有哪些？"><a href="#8-常用的线程池有哪些？" class="headerlink" title="8.常用的线程池有哪些？"></a>8.常用的线程池有哪些？</h2><ul><li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li><li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li><li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li></ul><h2 id="9-在-java-中-wait-和-和-sleep-方法的不同？"><a href="#9-在-java-中-wait-和-和-sleep-方法的不同？" class="headerlink" title="9.在 java 中 wait 和 和 sleep 方法的不同？"></a>9.在 java 中 wait 和 和 sleep 方法的不同？</h2><p>最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。</p><h2 id="10-多线程的常见创建方式？"><a href="#10-多线程的常见创建方式？" class="headerlink" title="10.多线程的常见创建方式？"></a>10.多线程的常见创建方式？</h2><p>一种是继承thread类，一种是实现runnable接口；</p><h2 id="11-synchronized和lock的区别？"><a href="#11-synchronized和lock的区别？" class="headerlink" title="11.synchronized和lock的区别？"></a>11.synchronized和lock的区别？</h2><ol><li><p>synchronized是一个关键字，lock是一个接口</p></li><li><p>在代码出现异常的时候，synchronized会自动的释放锁资源，lock要调用unlock方法才能释放锁资源；</p></li><li><p>lock可以中断其他等待锁对象的线程，synchronized不行，线程会一直等待下去；</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-启动一个线程是调用-run-方法还是-start-方法？&quot;&gt;&lt;a href=&quot;#1-启动一个线程是调用-run-方法还是-start-方法？&quot; class=&quot;headerlink&quot; title=&quot;1.启动一个线程是调用 run() 方法还是 start() 方法？&quot;&gt;&lt;/a&gt;1.启动一个线程是调用 run() 方法还是 start() 方法？&lt;/h2&gt;&lt;p&gt;启动一个线程调用的是start()方法，使线程进入到就绪状态，这就意味着它可以由JVM调度并执行，这并不意味着线程就会立马执行；run()方法是线程启动后线程要进行回调的方法。&lt;/p&gt;
&lt;h2 id=&quot;2-请说出同步线程及线程调度相关的方法？&quot;&gt;&lt;a href=&quot;#2-请说出同步线程及线程调度相关的方法？&quot; class=&quot;headerlink&quot; title=&quot;2. 请说出同步线程及线程调度相关的方法？&quot;&gt;&lt;/a&gt;2. 请说出同步线程及线程调度相关的方法？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;wait():使一个线程处于阻塞状态，并且释放所持有的对象锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sleep():使一个线程休眠一段时间，当时间过后线程又会恢复到以前的状态，并且在休眠状态不会释放对象锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;notifyAll():唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-线程和进程的区别？&quot;&gt;&lt;a href=&quot;#3-线程和进程的区别？&quot; class=&quot;headerlink&quot; title=&quot;3.线程和进程的区别？&quot;&gt;&lt;/a&gt;3.线程和进程的区别？&lt;/h2&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>待解决面试题</title>
    <link href="http://luyanan.com/%E5%BE%85%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://luyanan.com/%E5%BE%85%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-12T02:17:43.964Z</published>
    <updated>2021-03-12T02:17:43.964Z</updated>
    
    <content type="html"><![CDATA[<p>hash 碰撞<br>jvm内存模型<br>秒杀系统设计<br>rpc设计</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hash 碰撞&lt;br&gt;jvm内存模型&lt;br&gt;秒杀系统设计&lt;br&gt;rpc设计&lt;/p&gt;
</summary>
      
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>spring的事务隔离级别和事务传播行为</title>
    <link href="http://luyanan.com/spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
    <id>http://luyanan.com/spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</id>
    <published>2021-03-12T02:17:43.963Z</published>
    <updated>2021-03-12T02:17:43.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring的事务隔离级别和事务传播行为"><a href="#spring的事务隔离级别和事务传播行为" class="headerlink" title="spring的事务隔离级别和事务传播行为"></a>spring的事务隔离级别和事务传播行为</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li><p>DEFAULT </p><blockquote><p>使用底层数据库默认的隔离级别,大部分数据库默认的隔离级别都是<code>READ_COMMITED</code></p></blockquote></li><li><p>READ_UNCOMMITED </p><blockquote><p>允许事务读取未被其他事务提交的修改、可能会出现脏读、幻读、不可重复读</p></blockquote></li><li><p>READ_COMMITED </p><blockquote><p>只允许事务读取已经被事务提交的更改,可以避免脏读.但不可重复读和幻读问题仍然可能出现. </p></blockquote></li><li><p>REPEATABLE_READ</p><blockquote><p>确保事务可以多次从一个字段中读取相同的值,在这个事务持续期间, 禁止其他事务对这个字段进行更新,可以避免脏读和不可重复读, 但是幻读问题仍然存在. </p></blockquote></li><li><p>SERIALIZABLE </p><blockquote><p>确保事务可以从一个表中读取相同的行, 在这个事务持续期间, 禁止其他事务对该表执行插入、更新、删除. 所有的并发问题都能避免, 但是性能较低. </p></blockquote><p>事务的隔离级别需要底层数据库引擎的支持,而不是应用程序或者框架的支持. </p></li></ul><ol><li>Oracle 支持2种事务隔离级别: <code>READ_COMMITED</code>，<code>SERIALIZABLE</code>. 默认是 <code>READ_COMMITED</code></li><li>Mysql 支持4种事务隔离级别, 默认是<code>REPEATABLE_READ</code> . </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">msyql 查看隔离级别：</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">设置隔离级别：</span><br><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><h3 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h3><p>​    事务方法被另一个事务方法调用的时候, 必须指定事务应该如何传播.例如方法可能继续在现有事务中运行, 也可能开启一个新的事务, 并在自己的事务运行. spring中的事务传播行为可以由传播属性指定. Spring指定了7种传播行为. </p><table><thead><tr><th>REQUIRED</th><th>如何有事务在运行, 当前的方法就在这个事务中运行, 否则就重新开一个新的事务,默认传播行为.</th></tr></thead><tbody><tr><td>REQUIRED_NEW</td><td>当前方法必须启动新的事务, 并在自己的事务中运行, 如果有事务在运行, 则将它挂起.</td></tr><tr><td>SUPPORTS</td><td>如果有事务在运行, 当前的方法就是在这个事务中运行, 否则可以不运行在事务中.</td></tr><tr><td>NOT_SUPPORTED</td><td>表示该方法不应该运行在事务中, 如果存在当前事务,在该方法运行期间, 当前事务将被挂起.</td></tr><tr><td>MANDATORY</td><td>当前的方法必须运行在事务内部,如果没有正在运行的事务,将会抛出异常.</td></tr><tr><td>NEVER</td><td>当前方法不应该运行在事务中, 如果有运行的事务, 就抛出异常.</td></tr><tr><td>NESTED</td><td>如果有事务在运行, 当前的方法就应该在这个事务的嵌套事务内运行. 嵌套的事务可以独立于当前事务进行单独的提交或者回滚. 如果当前事务不存在, 那么其行为与<code>PROPAGATION_REQUIRED</code>一样.</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;spring的事务隔离级别和事务传播行为&quot;&gt;&lt;a href=&quot;#spring的事务隔离级别和事务传播行为&quot; class=&quot;headerlink&quot; title=&quot;spring的事务隔离级别和事务传播行为&quot;&gt;&lt;/a&gt;spring的事务隔离级别和事务传播行为&lt;/h2&gt;&lt;h3 id=&quot;事务隔离级别&quot;&gt;&lt;a href=&quot;#事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别&quot;&gt;&lt;/a&gt;事务隔离级别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DEFAULT &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用底层数据库默认的隔离级别,大部分数据库默认的隔离级别都是&lt;code&gt;READ_COMMITED&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;READ_UNCOMMITED &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;允许事务读取未被其他事务提交的修改、可能会出现脏读、幻读、不可重复读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;READ_COMMITED &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只允许事务读取已经被事务提交的更改,可以避免脏读.但不可重复读和幻读问题仍然可能出现. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;REPEATABLE_READ&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;确保事务可以多次从一个字段中读取相同的值,在这个事务持续期间, 禁止其他事务对这个字段进行更新,可以避免脏读和不可重复读, 但是幻读问题仍然存在. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SERIALIZABLE &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;确保事务可以从一个表中读取相同的行, 在这个事务持续期间, 禁止其他事务对该表执行插入、更新、删除. 所有的并发问题都能避免, 但是性能较低. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务的隔离级别需要底层数据库引擎的支持,而不是应用程序或者框架的支持. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Oracle 支持2种事务隔离级别: &lt;code&gt;READ_COMMITED&lt;/code&gt;，&lt;code&gt;SERIALIZABLE&lt;/code&gt;. 默认是 &lt;code&gt;READ_COMMITED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Mysql 支持4种事务隔离级别, 默认是&lt;code&gt;REPEATABLE_READ&lt;/code&gt; . &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msyql 查看隔离级别：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select @@tx_isolation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置隔离级别：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set session transaction isolation level serializable;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【Redis】缓存穿透，缓存雪崩，缓存击穿</title>
    <link href="http://luyanan.com/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <id>http://luyanan.com/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</id>
    <published>2021-03-12T02:17:43.963Z</published>
    <updated>2021-03-12T02:17:43.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-缓存穿透，缓存雪崩，缓存击穿"><a href="#Redis-缓存穿透，缓存雪崩，缓存击穿" class="headerlink" title="[Redis]缓存穿透，缓存雪崩，缓存击穿"></a>[Redis]缓存穿透，缓存雪崩，缓存击穿</h1><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p>第一次看到这个名字，会觉得是一个很高深的名词。但是和其他许多概念一样，它只是描述了一个很容易理解的现象：请求了不存在的数据。造成大量的请求没有命中缓存场景之一：数据库使用了id为正整数作为键，但是黑客使用负整数向服务器发起请求，这时所有的请求都没有在缓存中命中，从而导致大量请求数据库，如果超过了数据库的承载能力，会导致数据库服务器宏机。</p><p>解决缓存穿透的方案主要有两种：<br>1，当查询不存在时，也将结果保存在缓存中。但是这可能会存在一种问题：大量没有查询结果的请求保存在缓存中，这时我们就可以将这些请求的key设置得更短一些。</p><p>2，提前过滤掉不合法的请求，Redis实现了布隆过滤器，我们可以使用它来达到这个目的。布隆过滤器很好理解，可以参考<a href="https://www.cnblogs.com/cpselvis/p/6265825.html">布隆过滤器(Bloom Filter)的原理和实现</a>。</p><p><img src="https://segmentfault.com/img/bVbwJea" alt="图片描述"></p><p>如上图所示是合法的请求与布隆过滤器的过滤的请求的关系，合法的请求在布隆过滤器中一定可以经过，但是布隆过滤器并不能完全拦截所有非法的请求。应用在缓存上，我们能够拦截绝大部分请求即可。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>缓存雪崩是指缓存大量失效，导致大量的请求都直接向数据库获取数据，造成数据库的压力。缓存大量失效的原因可能是缓存服务器宏机，或者大量Redis的键设置的过期时间相同。</p><p>解决缓存雪崩我们也有两种解决方案：<br>1，在设置Redis键的过期时间时，加上一个随机数，这样可以避免。<br>2，部署分布式的Redis服务，当一个Redis服务器挂掉了之后，进行故障转移。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h3><p>缓存击穿又是一个听起来很晦涩的概念。它指的是在缓存过期的后一秒，有大量的请求并发的请求过期的键，这是因为缓存已经过期了，所有的请求都发送到数据库中了。</p><p>解决缓存击穿的方法与解决缓存穿透的方法一样。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis-缓存穿透，缓存雪崩，缓存击穿&quot;&gt;&lt;a href=&quot;#Redis-缓存穿透，缓存雪崩，缓存击穿&quot; class=&quot;headerlink&quot; title=&quot;[Redis]缓存穿透，缓存雪崩，缓存击穿&quot;&gt;&lt;/a&gt;[Redis]缓存穿透，缓存雪崩，缓存击穿&lt;/h1&gt;&lt;h3 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;第一次看到这个名字，会觉得是一个很高深的名词。但是和其他许多概念一样，它只是描述了一个很容易理解的现象：请求了不存在的数据。造成大量的请求没有命中缓存场景之一：数据库使用了id为正整数作为键，但是黑客使用负整数向服务器发起请求，这时所有的请求都没有在缓存中命中，从而导致大量请求数据库，如果超过了数据库的承载能力，会导致数据库服务器宏机。&lt;/p&gt;
&lt;p&gt;解决缓存穿透的方案主要有两种：&lt;br&gt;1，当查询不存在时，也将结果保存在缓存中。但是这可能会存在一种问题：大量没有查询结果的请求保存在缓存中，这时我们就可以将这些请求的key设置得更短一些。&lt;/p&gt;
&lt;p&gt;2，提前过滤掉不合法的请求，Redis实现了布隆过滤器，我们可以使用它来达到这个目的。布隆过滤器很好理解，可以参考&lt;a href=&quot;https://www.cnblogs.com/cpselvis/p/6265825.html&quot;&gt;布隆过滤器(Bloom Filter)的原理和实现&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql查询性能优化</title>
    <link href="http://luyanan.com/MySql%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://luyanan.com/MySql%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-03-12T02:17:43.962Z</published>
    <updated>2021-03-12T02:17:43.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySql查询性能优化"><a href="#MySql查询性能优化" class="headerlink" title="MySql查询性能优化"></a>MySql查询性能优化</h1><h2 id="避免向数据库请求不需要的数据"><a href="#避免向数据库请求不需要的数据" class="headerlink" title="避免向数据库请求不需要的数据"></a>避免向数据库请求不需要的数据</h2><p>在访问数据库时，应该只请求需要的行和列。请求多余的行和列会消耗MySql服务器的CPU和内存资源，并增加网络开销。<br>例如在处理分页时，应该使用LIMIT限制MySql只返回一页的数据，而不是向应用程序返回全部数据后，再由应用程序过滤不需要的行。<br>当一行数据被多次使用时可以考虑将数据行缓存起来，避免每次使用都要到MySql查询。<br>避免使用SELECT *这种方式进行查询，应该只返回需要的列。</p><h2 id="查询数据的方式"><a href="#查询数据的方式" class="headerlink" title="查询数据的方式"></a>查询数据的方式</h2><p>查询数据的方式有全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等。这些查询方式，速度从慢到快，扫描的行数也是从多到少。可以通过EXPLAIN语句中的type列反应查询采用的是哪种方式。<br>通常可以通过添加合适的索引改善查询数据的方式，使其尽可能减少扫描的数据行，加快查询速度。<br>例如，当发现查询需要扫描大量的数据行但只返回少数的行，那么可以考虑使用覆盖索引，即把所有需要用到的列都放到索引中。这样存储引擎无须回表获取对应行就可以返回结果了。</p><h2 id="分解大的查询"><a href="#分解大的查询" class="headerlink" title="分解大的查询"></a>分解大的查询</h2><p>可以将一个大查询切分成多个小查询执行，每个小查询只完成整个查询任务的一小部分，每次只返回一小部分结果<br>删除旧的数据是一个很好的例子。如果只用一条语句一次性执行一个大的删除操作，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但重要的查询。将一个大的删除操作分解成多个较小的删除操作可以将服务器上原本一次性的压力分散到多次操作上，尽可能小地影响MySql性能，减少删除时锁的等待时间。同时也减少了MySql主从复制的延迟。<br>另一个例子是分解关联查询，即对每个要关联的表进行单表查询，然后将结果在应用程序中进行关联。下面的这个查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">    JOIN tag_post ON tag_post.tag_id&#x3D;tag.id</span><br><span class="line">    JOIN post ON tag_post.post_id&#x3D;post.id</span><br><span class="line">WHERE tag.tag &#x3D; &#39;mysql&#39;;</span><br></pre></td></tr></table></figure><p>可以分解成下面这些查询来代替：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag WHERE tag &#x3D; &#39;mysql&#39;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id &#x3D; 1234;</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure><p>将一个关联查询拆解成多个单表查询有如下有点：</p><ol><li>让缓存的效率更高。如果缓存的是关联查询的结果，那么其中的一个表发生变化，整个缓存就失效了。而拆分后，如果只是某个表很少的改动，并不会破坏所有的缓存。</li><li>可以减少锁的竞争</li><li>更容易对数据库进行拆分，更容易做到高性能和可扩展。</li><li>查询本身的效率也有可能会有所提升。例如上面用IN()代替关联查询比随机的关联更加高效。</li></ol><h2 id="优化MIN-和MAX"><a href="#优化MIN-和MAX" class="headerlink" title="优化MIN()和MAX()"></a>优化MIN()和MAX()</h2><p>添加索引可以优化MIN()和MAX()表达式。例如，要找到某一列的最小值，只需要查询对应B-Tree索引的最左端的记录即可。类似的，如果要查询列中的最大值，也只需要读取B-Tree索引的最后一条记录。对于这种查询，EXPLAIN中可以看到”Select tables optimized away”,表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。</p><h2 id="用IN-取代OR"><a href="#用IN-取代OR" class="headerlink" title="用IN()取代OR"></a>用IN()取代OR</h2><p>在MySql中，IN()先将自己列表中的数据进行排序，然后通过二分查找的方式确定列的值是否在IN()的列表中，这个时间复杂度是O(logn)。如果换成OR操作，则时间复杂度是O(n)。所以，对于IN()的列表中有大量取值的时候，用IN()替换OR操作将会更快。</p><h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><p>在MySql中，任何一个查询都可以看成是一个关联查询，即使只有一个表的查询也是如此。<br>MySql对任何关联都执行嵌套循环的关联操作，例如对于下面的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tbl1.col1,tbl2.col2</span><br><span class="line">FROM tbl1 INNER JOIN tbl2 USING(col3)</span><br><span class="line">WHERE tbl1.col1 IN(5,6);</span><br></pre></td></tr></table></figure><p>下面的伪代码表示MySql将如何执行这个查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先从第一个表中取出符合条件的所有行</span><br><span class="line">out_iter &#x3D; iterator over tbl1 where col1 IN(5,6)</span><br><span class="line">outer_row &#x3D; out_iter.next</span><br><span class="line">&#x2F;&#x2F;在while循环中遍历第一个表结果集的每一行</span><br><span class="line">while outer_row</span><br><span class="line">    &#x2F;&#x2F;对于第一个表结果集中的每一行，在第二个表中找出符合条件的所有行</span><br><span class="line">    inner_iter &#x3D; iterator over tbl2 where col3 &#x3D; outer_row.col3</span><br><span class="line">    inner_row &#x3D; inner_iter.next</span><br><span class="line">    while inner_row</span><br><span class="line">        &#x2F;&#x2F;将第一个表的结果列和第二个表的结果列拼装在一起作为结果输出</span><br><span class="line">        output[outer_row.col1, inner_row.col2]</span><br><span class="line">        inner_row &#x3D; inner_iter.next</span><br><span class="line">    end</span><br><span class="line">    &#x2F;&#x2F;回溯，再根据第一个表结果集的下一行，继续上面的过程</span><br><span class="line">    outer_row &#x3D; outer_iter.next</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>对于单表查询，那么只需要完成上面外层的基本操作。<br>优化关联查询，要确保ON或者USING子句中的列上有索引，并且在建立索引时需要考虑到关联的顺序。通常来说，只需要在关联顺序中的第二个表的相应列上创建索引。例如，当表A和表B用列c关联的时候，假设关联的顺序是B、A，那么就不需要在B表的c列上建立索引。没有用到的索引只会带来额外的负担。<br>此外，确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样才能使用索引来优化这个过程。</p><h2 id="临时表的概念"><a href="#临时表的概念" class="headerlink" title="临时表的概念"></a>临时表的概念</h2><p>上面提到在MySql中，任何一个查询实质上都是一个关联查询。那么对于子查询或UNION查询是如何实现关联操作的呢。<br>对于UNION查询，MySql先将每一个单表查询结果放到一个临时表中，然后再重新读出临时表数据来完成UNION查询。MySql读取结果临时表和普通表一样，也是采用的关联方式。<br>当遇到子查询时，先执行子查询并将结果放到一个临时表中，然后再将这个临时表当做一个普通表对待。<br>MySql的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点。<br>临时表也叫派生表。</p><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>应该尽量让MySql使用索引进行排序。当不能使用索引生成排序结果的时候，MySql需要自己进行排序。如果数据量小于“排序缓冲区”的大小，则MySql使用内存进行“快速排序”操作。如果数据量太大超过“排序缓冲区”的大小，那么MySql只能采用文件排序，而文件排序的算法非常复杂，会消耗很多资源。<br>无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序。所以让MySql根据索引构造排序结果非常的重要。</p><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><p>MySql的子查询实现的非常糟糕。最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。<br>应该尽可能用关联替换子查询，可以提高查询效率。</p><h2 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h2><p>COUNT()有两个不同的作用：</p><ol><li>统计某个列值的数量，即统计某列值不为NULL的个数。</li><li>统计行数。</li></ol><p>当使用COUNT(*)时，统计的是行数，它会忽略所有的列而直接统计所有的行数。而在括号中指定了一个列的话，则统计的是这个列上值不为NULL的个数。<br>可以考虑使用索引覆盖扫描或增加汇总表对COUNT()进行优化。</p><h2 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h2><p>处理分页会使用到LIMIT，当翻页到非常靠后的页面的时候，偏移量会非常大，这时LIMIT的效率会非常差。例如对于*<strong>LIMIT 10000，20*</strong>这样的查询，MySql需要查询10020条记录，将前面10000条记录抛弃，只返回最后的20条。这样的代价非常高，如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。<br>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要与原表做一次关联操作返回所需的列。对于偏移量很大的时候，这样的效率会提升非常大。考虑下面的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;</span><br></pre></td></tr></table></figure><p>如果这个表非常大，那么这个查询最好改写成下面的这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT film.film_id, film.description FROM sakila.film</span><br><span class="line">INNER JOIN </span><br><span class="line">(SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5) AS lim</span><br><span class="line">USING(film_id);</span><br></pre></td></tr></table></figure><p>注意优化中关联的子查询，因为只查询film_id一个列，数据量小，使得一个内存页可以容纳更多的数据，这让MySQL扫描尽可能少的页面。在获取到所需要的所有行之后再与原表进行关联以获得需要的全部列。<br>LIMIT的优化问题，其实是OFFSET的问题，它会导致MySql扫描大量不需要的行然后再抛弃掉。可以借助书签的思想记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就避免了使用OFFSET。可以把主键当做书签使用，例如下面的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;</span><br></pre></td></tr></table></figure><p>假设上面的查询返回的是主键为16049到16030的租借记录，那么下一页查询就可以直接从16030这个点开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM sakila.rental WHERE rental_id &lt; 16030</span><br><span class="line">ORDER BY rental_id DESC LIMIT 20;</span><br></pre></td></tr></table></figure><p>该技术的好处是无论翻页到多么后面，其性能都会很好。<br>此外，也可以用关联到一个冗余表的方式提高LIMIT的性能，冗余表只包含主键列和需要做排序的数据列。</p><h2 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h2><p>除非确实需要服务器消除重复的行，否则一定要使用UNION ALL。如果没有ALL关键字，MySql会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySql查询性能优化&quot;&gt;&lt;a href=&quot;#MySql查询性能优化&quot; class=&quot;headerlink&quot; title=&quot;MySql查询性能优化&quot;&gt;&lt;/a&gt;MySql查询性能优化&lt;/h1&gt;&lt;h2 id=&quot;避免向数据库请求不需要的数据&quot;&gt;&lt;a href=&quot;#避免向数据库请求不需要的数据&quot; class=&quot;headerlink&quot; title=&quot;避免向数据库请求不需要的数据&quot;&gt;&lt;/a&gt;避免向数据库请求不需要的数据&lt;/h2&gt;&lt;p&gt;在访问数据库时，应该只请求需要的行和列。请求多余的行和列会消耗MySql服务器的CPU和内存资源，并增加网络开销。&lt;br&gt;例如在处理分页时，应该使用LIMIT限制MySql只返回一页的数据，而不是向应用程序返回全部数据后，再由应用程序过滤不需要的行。&lt;br&gt;当一行数据被多次使用时可以考虑将数据行缓存起来，避免每次使用都要到MySql查询。&lt;br&gt;避免使用SELECT *这种方式进行查询，应该只返回需要的列。&lt;/p&gt;
&lt;h2 id=&quot;查询数据的方式&quot;&gt;&lt;a href=&quot;#查询数据的方式&quot; class=&quot;headerlink&quot; title=&quot;查询数据的方式&quot;&gt;&lt;/a&gt;查询数据的方式&lt;/h2&gt;&lt;p&gt;查询数据的方式有全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等。这些查询方式，速度从慢到快，扫描的行数也是从多到少。可以通过EXPLAIN语句中的type列反应查询采用的是哪种方式。&lt;br&gt;通常可以通过添加合适的索引改善查询数据的方式，使其尽可能减少扫描的数据行，加快查询速度。&lt;br&gt;例如，当发现查询需要扫描大量的数据行但只返回少数的行，那么可以考虑使用覆盖索引，即把所有需要用到的列都放到索引中。这样存储引擎无须回表获取对应行就可以返回结果了。&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>String、StringBuffer和StringBuilder的区别</title>
    <link href="http://luyanan.com/String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luyanan.com/String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-03-12T02:17:43.962Z</published>
    <updated>2021-03-12T02:17:43.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h1><h6 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a><strong>可变性</strong></h6><ul><li>String是不可变的，它使用final关键词修饰–</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    &#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">    private final char value[];</span><br><span class="line">...................</span><br></pre></td></tr></table></figure><ul><li>StringBuffer和StringBuilder两者都是继承自AbstractStringBuilder,AbstractStringBuilder也是用字符数组保存char value[]当时没有用final修饰，所以这两种对象是可变的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line"></span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The value is used for character storage.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    char[] value;</span><br></pre></td></tr></table></figure><h6 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h6><ul><li>String的对象不可变，也就是常量，所以线程安全</li><li>StringBuffer重写了AbstractStringBuilder的方法，比如append、insert等并且加了同步锁，所以是线程安全的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public synchronized int length() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized int capacity() &#123;</span><br><span class="line">        return value.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void ensureCapacity(int minimumCapacity) &#123;</span><br><span class="line">        super.ensureCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>而StringBuilder就没加同步锁，所以是非线程安全的</li></ul><h6 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h6><p>每次修改String的值都会重新生成一个新的String对象，然后再将指针指向新的String对象，StringBuffer和StringBuilder每次都是对象本身进行操作，而不是生成新的对象。StringBuilder的性能会比StringBuffer好一点，不过却要冒多线程不安全的风险</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h6><ul><li>数据量将多用String</li><li>单线程操作大量数据用StringBuilder</li><li>多线程操作大量数据用StringBuffer</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;String、StringBuffer和StringBuilder的区别&quot;&gt;&lt;a href=&quot;#String、StringBuffer和StringBuilder的区别&quot; class=&quot;headerlink&quot; title=&quot;String、StringBuffer和StringBuilder的区别&quot;&gt;&lt;/a&gt;String、StringBuffer和StringBuilder的区别&lt;/h1&gt;&lt;h6 id=&quot;可变性&quot;&gt;&lt;a href=&quot;#可变性&quot; class=&quot;headerlink&quot; title=&quot;可变性&quot;&gt;&lt;/a&gt;&lt;strong&gt;可变性&lt;/strong&gt;&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;String是不可变的，它使用final关键词修饰–&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public final class String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;** The value is used for character storage. *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private final char value[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...................&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;StringBuffer和StringBuilder两者都是继承自AbstractStringBuilder,AbstractStringBuilder也是用字符数组保存char value[]当时没有用final修饰，所以这两种对象是可变的&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql主从实现原理</title>
    <link href="http://luyanan.com/mysql%E4%B8%BB%E4%BB%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://luyanan.com/mysql%E4%B8%BB%E4%BB%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-03-12T02:17:43.962Z</published>
    <updated>2021-03-12T02:17:43.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql主从实现原理"><a href="#mysql主从实现原理" class="headerlink" title="mysql主从实现原理"></a>mysql主从实现原理</h1><h2 id="1、什么是mysql主从同步？"><a href="#1、什么是mysql主从同步？" class="headerlink" title="1、什么是mysql主从同步？"></a>1、什么是mysql主从同步？</h2><p>当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。</p><hr><h2 id="2、主从同步有什么好处？"><a href="#2、主从同步有什么好处？" class="headerlink" title="2、主从同步有什么好处？"></a>2、主从同步有什么好处？</h2><ul><li>水平扩展数据库的负载能力。</li><li>容错，高可用。Failover(失败切换)/High Availability</li><li>数据备份。</li></ul><hr><h2 id="3、主从同步的原理是什么？"><a href="#3、主从同步的原理是什么？" class="headerlink" title="3、主从同步的原理是什么？"></a>3、主从同步的原理是什么？</h2><p>首先我们来了解<strong>master-slave</strong>的体系结构。</p><p>如下图：<br><img src="https://segmentfault.com/img/remote/1460000008663004?w=601&h=152" alt="image_1bb0gkf461ram981c3r1fcpvia1g.png-42.4kB"></p><p>不管是delete、update、insert，还是创建函数、存储过程，所有的操作都在master上。<br>当master有操作的时候,slave会快速的接收到这些操作，从而做同步。</p><p>但是，这个机制是怎么实现的呢？</p><blockquote><p>在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);<br>在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。</p></blockquote><p>如此，就实现了主从同步了！</p><p>下面我们来详细的了解。</p><hr><h3 id="3-1主从同步事件有哪些"><a href="#3-1主从同步事件有哪些" class="headerlink" title="3.1主从同步事件有哪些"></a>3.1主从同步事件有哪些</h3><p>上面说到：</p><blockquote><p>在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);</p></blockquote><p>主从同步事件有3种形式:statement、row、mixed。</p><ul><li>statement：会将对数据库操作的sql语句写入到binlog中。</li><li>row：会将每一条数据的变化写入到binlog中。</li><li>mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。</li></ul><h3 id="3-2在master机器上的操作"><a href="#3-2在master机器上的操作" class="headerlink" title="3.2在master机器上的操作"></a>3.2在master机器上的操作</h3><p>当master上的数据发生改变的时候，该事件(insert、update、delete)变化会按照顺序写入到binlog中。</p><h4 id="binlog-dump线程"><a href="#binlog-dump线程" class="headerlink" title="binlog dump线程"></a>binlog dump线程</h4><p>当slave连接到master的时候，master机器会为slave开启binlog dump线程。<br>当master 的 binlog发生变化的时候，binlog dump线程会通知slave，并将相应的binlog内容发送给slave。</p><h3 id="3-3在slave机器上的操作"><a href="#3-3在slave机器上的操作" class="headerlink" title="3.3在slave机器上的操作"></a>3.3在slave机器上的操作</h3><p>当主从同步开启的时候，slave上会创建2个线程。</p><ul><li>I/O线程。该线程连接到master机器，master机器上的<strong>binlog dump线程</strong>会将binlog的内容发送给该<strong>I/O线程</strong>。该<strong>I/O线程</strong>接收到binlog内容后，再将内容写入到本地的relay log。</li><li>SQL线程。该线程读取I/O线程写入的relay log。并且根据relay log的内容对slave数据库做相应的操作。</li></ul><h3 id="3-4如何在master、slave上查看上述的线程？"><a href="#3-4如何在master、slave上查看上述的线程？" class="headerlink" title="3.4如何在master、slave上查看上述的线程？"></a>3.4如何在master、slave上查看上述的线程？</h3><p>使用<code>SHOW PROCESSLIST</code>命令可以查看。</p><p>如图，在master机器上查看binlog dump线程。<br><img src="https://segmentfault.com/img/remote/1460000008663005?w=604&h=448" alt="image_1bb0nlnmf1g1t18hi1m6colk8rb2h.png-44.7kB"></p><p>如图，在slave机器上查看I/O、SQL线程。<br><img src="https://segmentfault.com/img/remote/1460000008663006?w=626&h=592" alt="image_1bb0nraek1mtr1o2r1ivr11cj1jq72u.png-57.6kB"></p><h3 id="4、讲了这么多，一图以蔽之"><a href="#4、讲了这么多，一图以蔽之" class="headerlink" title="4、讲了这么多，一图以蔽之"></a>4、讲了这么多，一图以蔽之</h3><p><img src="https://segmentfault.com/img/remote/1460000008663007?w=630&h=568" alt="image_1bb0n61khccb11s91nd1r8v19d724.png-118.5kB"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql主从实现原理&quot;&gt;&lt;a href=&quot;#mysql主从实现原理&quot; class=&quot;headerlink&quot; title=&quot;mysql主从实现原理&quot;&gt;&lt;/a&gt;mysql主从实现原理&lt;/h1&gt;&lt;h2 id=&quot;1、什么是mysql主从同步？&quot;&gt;&lt;a href=&quot;#1、什么是mysql主从同步？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是mysql主从同步？&quot;&gt;&lt;/a&gt;1、什么是mysql主从同步？&lt;/h2&gt;&lt;p&gt;当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2、主从同步有什么好处？&quot;&gt;&lt;a href=&quot;#2、主从同步有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;2、主从同步有什么好处？&quot;&gt;&lt;/a&gt;2、主从同步有什么好处？&lt;/h2&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap跟Hashtable有什么区别</title>
    <link href="http://luyanan.com/HashMap%E8%B7%9FHashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://luyanan.com/HashMap%E8%B7%9FHashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2021-03-12T02:17:43.961Z</published>
    <updated>2021-03-12T02:17:43.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap跟Hashtable有什么区别"><a href="#HashMap跟Hashtable有什么区别" class="headerlink" title="HashMap跟Hashtable有什么区别?"></a>HashMap跟Hashtable有什么区别?</h1><p>HashMap和HashTable都是基于哈希表来实现键值映射的工具类,从公开的方法上来看，这两个类提供的，是一样的功能。都提供键值映射的服务，可以增、删、查、改键值对，可以对键、值、键值对提供遍历视图。支持浅拷贝，支持序列化。</p><ul><li>从数据结构上看 :<br> HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。可以说，有多少个键值对，就有多少个Entry对象.<br> 得出结论，HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry对象唯一表示一个键值对，有四个属性：</span><br><span class="line">-K key 键对象</span><br><span class="line">-V <span class="keyword">value</span> 值对象</span><br><span class="line">-<span class="built_in">int</span> hash 键对象的hash值</span><br><span class="line">-Entry entry 指向链表中下一个Entry对象，可为<span class="literal">null</span>，表示当前Entry对象在链表尾部</span><br></pre></td></tr></table></figure><ul><li><p>从继承体系上看 :<br> 虽然都实现了Map、Cloneable、Serializable三个接口。但是HashMap继承自抽象类AbstractMap，而HashTable继承自抽象类Dictionary。其中Dictionary类是一个已经被废弃的类.</p></li><li><p>从公共方法上看 :<br> HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p></li><li><p>从算法上看 :<br> HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。如果在创建时给定了初始化大小，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。<br> 因为哈希表的大小为素数时，简单的取模哈希的结果会更加均匀.这样设计可以减少哈希值冲突.<br> 但是在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。hash计算的效率HashMap更胜一筹.HashMap由于使用了2的幂次方，所以在取模运算时不需要做除法，只需要位的与运算就可以了。但是由于引入的hash冲突加剧问题，HashMap在调用了对象的hashCode方法之后，又做了一些位运算在打散数据。</p></li><li><p>从线程安全上看 :<br> Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步.<br> HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。使用HashMap时就必须要自己增加同步处理.HashMap进行同步： <code>Map m = Collections.synchronizeMap(hashMap);</code><br> 虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p></li><li><p>从遍历方式上看 :<br> Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 .</p><p>HashMap和jdk1.8以后的HashTable迭代器使用fast-fail机制 , 当有其它线程改变了HashMap的结构（增加，删除，修改元素），将会抛出ConcurrentModificationException。不过，通过Iterator的remove()方法移除元素则不会抛出ConcurrentModificationException异常。</p><p><img src="https://upload-images.jianshu.io/upload_images/8884551-9c116a6102a410b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688/format/webp" alt="img"></p><p>每次在发生增删改的时候都会出现modCount++的动作。而modcount可以理解为是当前hashtable的状态。每发生一次操作，状态就向前走一步。设置这个状态，主要是由于hashtable等容器类在迭代时，判断数据是否过时时使用的。尽管hashtable采用了原生的同步锁来保护数据安全。但是在出现迭代数据的时候，则无法保证边迭代，边正确操作。于是使用这个值来标记状态。一旦在迭代的过程中状态发生了改变，则会快速抛出一个异常，终止迭代行为。</p></li><li><p>从使用角度上看 :<br> 如果不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。HashTable已经被淘汰了，不要在新的代码中再使用它。<br> 每一版本的JDK，都会对HashMap和HashTable的内部实现做优化，比如JDK 1.8的红黑树优化。所以尽可能的使用新版本的JDK，会有性能上有提升。<br> 为什么HashTable已经淘汰了，还要优化它？因为有老的代码还在使用它，所以优化了它之后，这些老的代码也能获得性能提升。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HashMap跟Hashtable有什么区别&quot;&gt;&lt;a href=&quot;#HashMap跟Hashtable有什么区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap跟Hashtable有什么区别?&quot;&gt;&lt;/a&gt;HashMap跟Hashtable有什么区别?&lt;/h1&gt;&lt;p&gt;HashMap和HashTable都是基于哈希表来实现键值映射的工具类,从公开的方法上来看，这两个类提供的，是一样的功能。都提供键值映射的服务，可以增、删、查、改键值对，可以对键、值、键值对提供遍历视图。支持浅拷贝，支持序列化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从数据结构上看 :&lt;br&gt; HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。可以说，有多少个键值对，就有多少个Entry对象.&lt;br&gt; 得出结论，HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Entry对象唯一表示一个键值对，有四个属性：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-K key 键对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-V &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; 值对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; hash 键对象的hash值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Entry entry 指向链表中下一个Entry对象，可为&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;，表示当前Entry对象在链表尾部&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从继承体系上看 :&lt;br&gt; 虽然都实现了Map、Cloneable、Serializable三个接口。但是HashMap继承自抽象类AbstractMap，而HashTable继承自抽象类Dictionary。其中Dictionary类是一个已经被废弃的类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从公共方法上看 :&lt;br&gt; HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从算法上看 :&lt;br&gt; HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。如果在创建时给定了初始化大小，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。&lt;br&gt; 因为哈希表的大小为素数时，简单的取模哈希的结果会更加均匀.这样设计可以减少哈希值冲突.&lt;br&gt; 但是在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。hash计算的效率HashMap更胜一筹.HashMap由于使用了2的幂次方，所以在取模运算时不需要做除法，只需要位的与运算就可以了。但是由于引入的hash冲突加剧问题，HashMap在调用了对象的hashCode方法之后，又做了一些位运算在打散数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从线程安全上看 :&lt;br&gt; Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步.&lt;br&gt; HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。使用HashMap时就必须要自己增加同步处理.HashMap进行同步： &lt;code&gt;Map m = Collections.synchronizeMap(hashMap);&lt;/code&gt;&lt;br&gt; 虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从遍历方式上看 :&lt;br&gt; Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 .&lt;/p&gt;
&lt;p&gt;HashMap和jdk1.8以后的HashTable迭代器使用fast-fail机制 , 当有其它线程改变了HashMap的结构（增加，删除，修改元素），将会抛出ConcurrentModificationException。不过，通过Iterator的remove()方法移除元素则不会抛出ConcurrentModificationException异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8884551-9c116a6102a410b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688/format/webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;每次在发生增删改的时候都会出现modCount++的动作。而modcount可以理解为是当前hashtable的状态。每发生一次操作，状态就向前走一步。设置这个状态，主要是由于hashtable等容器类在迭代时，判断数据是否过时时使用的。尽管hashtable采用了原生的同步锁来保护数据安全。但是在出现迭代数据的时候，则无法保证边迭代，边正确操作。于是使用这个值来标记状态。一旦在迭代的过程中状态发生了改变，则会快速抛出一个异常，终止迭代行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从使用角度上看 :&lt;br&gt; 如果不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。HashTable已经被淘汰了，不要在新的代码中再使用它。&lt;br&gt; 每一版本的JDK，都会对HashMap和HashTable的内部实现做优化，比如JDK 1.8的红黑树优化。所以尽可能的使用新版本的JDK，会有性能上有提升。&lt;br&gt; 为什么HashTable已经淘汰了，还要优化它？因为有老的代码还在使用它，所以优化了它之后，这些老的代码也能获得性能提升。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引原理和实现</title>
    <link href="http://luyanan.com/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://luyanan.com/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-03-12T02:17:43.961Z</published>
    <updated>2021-03-12T02:17:43.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL索引原理和实现"><a href="#MySQL索引原理和实现" class="headerlink" title="MySQL索引原理和实现"></a>MySQL索引原理和实现</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL索引原理和实现&quot;&gt;&lt;a href=&quot;#MySQL索引原理和实现&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引原理和实现&quot;&gt;&lt;/a&gt;MySQL索引原理和实现&lt;/h2&gt;</summary>
      
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Java之synchronized和Lock的区别</title>
    <link href="http://luyanan.com/Java%E4%B9%8Bsynchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luyanan.com/Java%E4%B9%8Bsynchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-03-12T02:17:43.961Z</published>
    <updated>2021-03-12T02:17:43.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java之synchronized和Lock的区别"><a href="#Java之synchronized和Lock的区别" class="headerlink" title="Java之synchronized和Lock的区别"></a>Java之synchronized和Lock的区别</h1><ol><li>Lock是java的一个interface接口，而synchronized是Java中的关键字，synchronized是由JDK实现的，不需要程序员编写代码去控制加锁和释放；Lock的接口如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>synchronized修饰的代码在执行异常时，jdk会自动释放线程占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生；但是，当Lock发生异常时，如果程序没有通过unLock()去释放锁，则很可能造成死锁现象，因此Lock一般都是在finally块中释放锁；格式如下：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> LockImpl; <span class="comment">// new 一个Lock的实现类</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();  <span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">     <span class="comment">// todo</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Lock可以让等待锁的线程响应中断处理，如tryLock(long time, TimeUnit unit)，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够中断，程序员无法控制；</li><li> synchronized是非公平锁，Lock可以设置是否公平锁，默认是非公平锁；</li><li>Lock的实现类ReentrantReadWriteLock提供了readLock()和writeLock()用来获取读锁和写锁的两个方法，这样多个线程可以进行同时读操作；</li><li>Lock锁的范围有局限性，仅适用于代码块范围，而synchronized可以锁住代码块、对象实例、类；</li><li>Lock可以绑定条件，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java之synchronized和Lock的区别&quot;&gt;&lt;a href=&quot;#Java之synchronized和Lock的区别&quot; class=&quot;headerlink&quot; title=&quot;Java之synchronized和Lock的区别&quot;&gt;&lt;/a&gt;Java之synchronized和Lock的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Lock是java的一个interface接口，而synchronized是Java中的关键字，synchronized是由JDK实现的，不需要程序员编写代码去控制加锁和释放；Lock的接口如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Lock&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lockInterruptibly&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; time, TimeUnit unit)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Condition &lt;span class=&quot;title&quot;&gt;newCondition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;synchronized修饰的代码在执行异常时，jdk会自动释放线程占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生；但是，当Lock发生异常时，如果程序没有通过unLock()去释放锁，则很可能造成死锁现象，因此Lock一般都是在finally块中释放锁；格式如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Lock &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LockImpl; &lt;span class=&quot;comment&quot;&gt;// new 一个Lock的实现类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;();  &lt;span class=&quot;comment&quot;&gt;// 加锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//todo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;catch(Exception ex)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// todo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;.unlock();   &lt;span class=&quot;comment&quot;&gt;//释放锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://luyanan.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式简介</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</id>
    <published>2021-03-12T02:17:43.960Z</published>
    <updated>2021-03-12T02:17:43.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><h2 id="1-设计模式简介"><a href="#1-设计模式简介" class="headerlink" title="1. 设计模式简介"></a>1. 设计模式简介</h2><p> 设计模式是一套被反复使用的,多数人只晓得,经过分类编写的,代码设计经验的总结.使用设计模式是为了重用代码,让代码更容易被他们理解,保证代码的可靠性.</p><h2 id="2-设计模式的设计原则"><a href="#2-设计模式的设计原则" class="headerlink" title="2. 设计模式的设计原则"></a>2. 设计模式的设计原则</h2><ul><li> 对接口编程而不是对实现编程</li><li> 优先使用对象组合而不是继承<h2 id="3-设计模式的类型"><a href="#3-设计模式的类型" class="headerlink" title="3.设计模式的类型"></a>3.设计模式的类型</h2><h3 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式 "></a>1. 创建型模式 <br></h3></li></ul><h4 id="1-1-描述"><a href="#1-1-描述" class="headerlink" title="1.1  描述"></a>1.1  描述</h4><p>这些设计模式提供了一种在创建对象的同时隐藏逻辑的方法,而不是使用new 运算符直接实例化对象.这使得程序在判断针对某个给定实例需要创建那些对象时更加灵活</p><h4 id="1-2-包括"><a href="#1-2-包括" class="headerlink" title="1.2 包括"></a>1.2 包括</h4><ul><li>  工厂模式(Factory Pattern)</li><li>  抽象工厂模式(Abstract Factory Pattren)</li><li>  单例模式(Singleton Pattren)</li><li>  建造者模式(Builder Pattren)</li><li>  原型模式(Prototype Pattren)</li></ul><h3 id="2-结构性模式"><a href="#2-结构性模式" class="headerlink" title="2. 结构性模式"></a>2. 结构性模式</h3><h4 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h4><p>这些设计模式关注类和对象的组合.继承的概念被用来组合接口和定义组合对象获得新功能的方式</p><h4 id="2-2-包括"><a href="#2-2-包括" class="headerlink" title="2.2 包括"></a>2.2 包括</h4><ul><li>适配器模式(Adapter Pattren)</li><li>桥接模式(Bridge Pattren)</li><li>过滤器模式(Filter,Criteria Pattren)</li><li>组合模式(Composite Pattren)</li><li>装饰器模式(Decorator Pattren)</li><li>外观模式(Facade Pattren)</li><li>享元模式(Flyweight Pattren)</li><li>代理模式(Proxy Pattren)<h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h3><h4 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h4>这些设计模式特别关注对象之间的通信<h4 id="3-2-包括"><a href="#3-2-包括" class="headerlink" title="3.2 包括"></a>3.2 包括</h4></li><li>责任链模式(Chain of Responblity Pattren)</li><li>命令模式(Command Pattren)</li><li>解释器模式(Interpreter Pattren)</li><li>迭代器模式(Iterator Pattren)</li><li>中介者模式(Mediator Pattren)</li><li>备忘录模式(Memento Pattren)</li><li>观察者模式(Observer Pattren)</li><li>状态模式(State Pattren)</li><li>空对象模式(Null Object Pattren)</li><li>策略模式(Strategy Pattren)</li><li>模板模式(Template Pattren)</li><li>访问者模式(Visitor Pattren)<h3 id="4-J2EE-模式"><a href="#4-J2EE-模式" class="headerlink" title="4. J2EE 模式"></a>4. J2EE 模式</h3><h4 id="4-1-描述"><a href="#4-1-描述" class="headerlink" title="4.1 描述"></a>4.1 描述</h4>这些设计模式特别关注表示层,这些模式是由Sun Java Center 鉴定的<h4 id="4-2-包括"><a href="#4-2-包括" class="headerlink" title="4.2 包括"></a>4.2 包括</h4></li><li>MVC 模式(MVC Pattren)</li><li>业务代表模式(Business Deledate Pattren)</li><li>组合实体模式(Composite Entity Pattren)</li><li>数据访问对象模式(Data Access Object Pattren)</li><li>前端控制器模式(Front Controller Pattren)</li><li>拦截过滤器模式(Interception Filter Pattren)</li><li>服务定位器模式(Service Locator Pattren)</li><li>传输对象模式(Transfer Object Pattren)<h2 id="4-设计模式的六大原则"><a href="#4-设计模式的六大原则" class="headerlink" title="4. 设计模式的六大原则"></a>4. 设计模式的六大原则</h2></li></ul><ol><li><strong>开闭原则</strong><br><br>开闭原则的意思是:对扩展开放,对修改关闭.在程序需要进行拓展的时候,不能去修改原有的代码,实现一个热插拔的效果.简言之,是为了使程序的扩展性好,易与维护和升级.想达到这样的效果,我们就需要使用接口和抽象类</li><li><strong>里氏代换原则</strong><br><br> 里氏代换原则是面向对象设计的基本原则之一.里氏原则中说,任何基类可以出现的地方,子类一定可以出现.LSP 是继承复用的基石,只有当派生类可以替换掉基类,且软件单位的功能不受到影响时,基类才能真正被复用,而派生类也能够在基类的基础上增加新的行为.里氏代换原则是对开闭原则的补充.实现开闭原则的关键步骤就是抽象化,而基类与子类的继承关系就是抽象化的具体实现,所以里氏代换原则是对实现抽象化的具体步骤的规范</li><li><strong>依赖倒置原则</strong><br><br>这个原则是开闭原则的基础,具体内容:针对接口编程,依赖与抽象而不依赖与具体</li><li><strong>接口隔离原则</strong><br><br>这个原则的意思是:使用多个隔离的接口,比使用单个接口要好.它还有另外一个意思是:降低类之间的耦合度.由此可见,其实设计模式就是从大型软件架构出发,便于维护和升级的软件设计思想,它强调降低依赖,降低耦合</li><li><strong>迪米特法则,又称最少知道原则</strong><br><br> 最少知道原则是指: 一个实体应当尽量减少与其他实体之间发生相互作用,使得系统功能模块相对独立</li><li><strong>合成复用原则</strong> <br><br> 合成复用原则是指:尽量使用合成/聚合的方式,而不是使用继承</li><li><strong>单一职责原则</strong><br><br>单一职责原则是指不要存在多于一个导致类变更的原因.假设我们有一个Class负责两个职责,一旦发生需求变更,修改其中一个职责的逻辑代码,有可能会导致另一个职责的功能发生故障,这样一来,这个Class存在两个导致类变更的原因 。  如何解决这个问题呢?我们就要給这两个职责分别以两个Class实现进行解耦.后期需求变更维护互不影响.这样的设计,可以降低类的复杂度,提高类的可读性,提高系统的可维护性,降低变更引起的风险.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;h2 id=&quot;1-设计模式简介&quot;&gt;&lt;a href=&quot;#1-设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;1. 设计模式简介&quot;&gt;&lt;/a&gt;1. 设计模式简介&lt;/h2&gt;&lt;p&gt; 设计模式是一套被反复使用的,多数人只晓得,经过分类编写的,代码设计经验的总结.使用设计模式是为了重用代码,让代码更容易被他们理解,保证代码的可靠性.&lt;/p&gt;
&lt;h2 id=&quot;2-设计模式的设计原则&quot;&gt;&lt;a href=&quot;#2-设计模式的设计原则&quot; class=&quot;headerlink&quot; title=&quot;2. 设计模式的设计原则&quot;&gt;&lt;/a&gt;2. 设计模式的设计原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt; 对接口编程而不是对实现编程&lt;/li&gt;
&lt;li&gt; 优先使用对象组合而不是继承&lt;h2 id=&quot;3-设计模式的类型&quot;&gt;&lt;a href=&quot;#3-设计模式的类型&quot; class=&quot;headerlink&quot; title=&quot;3.设计模式的类型&quot;&gt;&lt;/a&gt;3.设计模式的类型&lt;/h2&gt;&lt;h3 id=&quot;1-创建型模式&quot;&gt;&lt;a href=&quot;#1-创建型模式&quot; class=&quot;headerlink&quot; title=&quot;1. 创建型模式 &quot;&gt;&lt;/a&gt;1. 创建型模式 &lt;br&gt;&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之过滤器模式(9)</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F(9)/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F(9)/</id>
    <published>2021-03-12T02:17:43.959Z</published>
    <updated>2021-03-12T02:17:43.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-设计模式之过滤器模式-Filter-Pattren"><a href="#9-设计模式之过滤器模式-Filter-Pattren" class="headerlink" title="9. 设计模式之过滤器模式(Filter Pattren)"></a>9. 设计模式之过滤器模式(Filter Pattren)</h1><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>过滤器模式或标准模式是一种设计模式,这种模式允许开发人员使用不同的标准来过滤一组对象,通过逻辑运算以解耦的方式把他们链接起来.这种类型的设计模式属于结构性模式.它组合多个标准来获得单一标准.</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><p>定义一个实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义一个过滤器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 定义一个过滤器接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> personList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">filer</span><span class="params">(List&lt;Person&gt; personList)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>男性过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 男性过滤器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">filer</span><span class="params">(List&lt;Person&gt; personList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personList</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(persion -&gt; (persion.getSex().equals(<span class="string">&quot;男&quot;</span>)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>女性过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 女性过滤器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">filer</span><span class="params">(List&lt;Person&gt; personList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personList</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(person -&gt; person.getSex().equals(<span class="string">&quot;女&quot;</span>))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>年轻人过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 年轻人的过滤器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">filer</span><span class="params">(List&lt;Person&gt; personList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personList.stream().filter(person -&gt; person.getAge() &lt;= <span class="number">18</span>).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(Person.builder().name(<span class="string">&quot;张三&quot;</span>).sex(<span class="string">&quot;男&quot;</span>).age(<span class="number">18</span>).build());</span><br><span class="line">        personList.add(Person.builder().name(<span class="string">&quot;李四&quot;</span>).sex(<span class="string">&quot;男&quot;</span>).age(<span class="number">28</span>).build());</span><br><span class="line">        personList.add(Person.builder().name(<span class="string">&quot;王红&quot;</span>).sex(<span class="string">&quot;女&quot;</span>).age(<span class="number">18</span>).build());</span><br><span class="line">        personList.add(Person.builder().name(<span class="string">&quot;佳琪&quot;</span>).sex(<span class="string">&quot;女&quot;</span>).age(<span class="number">28</span>).build());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 筛选男人</span></span><br><span class="line">        Filter male = <span class="keyword">new</span> MaleFilter();</span><br><span class="line">        print(male.getClass().getSimpleName(), male.filer(personList));</span><br><span class="line">        <span class="comment">// 筛选女人</span></span><br><span class="line">        Filter female = <span class="keyword">new</span> FemaleFilter();</span><br><span class="line">        print(female.getClass().getSimpleName(), female.filer(personList));</span><br><span class="line">        <span class="comment">//  筛选年轻人</span></span><br><span class="line">        Filter young = <span class="keyword">new</span> YoungFilter();</span><br><span class="line">        print(young.getClass().getSimpleName(), young.filer(personList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String filterName, List&lt;Person&gt; personList)</span> </span>&#123;</span><br><span class="line">        personList.stream().forEach(person -&gt; &#123;</span><br><span class="line">            System.out.println(filterName + <span class="string">&quot;----&quot;</span> + person.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MaleFilter----Person(name=张三, age=<span class="number">18</span>, sex=男)</span><br><span class="line">MaleFilter----Person(name=李四, age=<span class="number">28</span>, sex=男)</span><br><span class="line">FemaleFilter----Person(name=王红, age=<span class="number">18</span>, sex=女)</span><br><span class="line">FemaleFilter----Person(name=佳琪, age=<span class="number">28</span>, sex=女)</span><br><span class="line">YoungFilter----Person(name=张三, age=<span class="number">18</span>, sex=男)</span><br><span class="line">YoungFilter----Person(name=王红, age=<span class="number">18</span>, sex=女)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;9-设计模式之过滤器模式-Filter-Pattren&quot;&gt;&lt;a href=&quot;#9-设计模式之过滤器模式-Filter-Pattren&quot; class=&quot;headerlink&quot; title=&quot;9. 设计模式之过滤器模式(Filter Pattren)&quot;&gt;&lt;/a&gt;9. 设计模式之过滤器模式(Filter Pattren)&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h3&gt;&lt;p&gt;过滤器模式或标准模式是一种设计模式,这种模式允许开发人员使用不同的标准来过滤一组对象,通过逻辑运算以解耦的方式把他们链接起来.这种类型的设计模式属于结构性模式.它组合多个标准来获得单一标准.&lt;/p&gt;
&lt;h3 id=&quot;2-代码&quot;&gt;&lt;a href=&quot;#2-代码&quot; class=&quot;headerlink&quot; title=&quot;2. 代码&quot;&gt;&lt;/a&gt;2. 代码&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式(18)</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F(18)/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F(18)/</id>
    <published>2021-03-12T02:17:43.959Z</published>
    <updated>2021-03-12T02:17:43.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="18-设计模式之迭代器模式-Iterator-Pattern"><a href="#18-设计模式之迭代器模式-Iterator-Pattern" class="headerlink" title="18.   设计模式之迭代器模式(Iterator Pattern)"></a>18.   设计模式之迭代器模式(Iterator Pattern)</h2><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>Iterator模式是行为模式的一种,它把容器中包含的内部对象的访问委让给外部类,使用iterator(遍历)按顺序进行遍历访问的设计模式</p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>&nbsp;&nbsp;&nbsp; Iterator模式就是为了搞笑的处理按顺序进行遍历访问的一种设计模式,简单的说,Iterator模式提供一种有效的方法,可以屏蔽聚合对象的容器类的实现细节而能对容器内包含的元素按顺序进行有效的遍历访问.<br><br>所有,Iterator模式的应用场景可以归纳为满足以下几个条件:</p><ul><li>访问容器内包含的内部对象</li><li>按顺序访问<h3 id="3-不使用迭代器模式的应用"><a href="#3-不使用迭代器模式的应用" class="headerlink" title="3. 不使用迭代器模式的应用"></a>3. 不使用迭代器模式的应用</h3>在应用Iterator模式之前,首先应该明白Iterator模式主要用来解决什么问题或者说,如果不使用Iterator模式,会存在什么问题.</li></ul><ol><li><p>由容器自己实现顺序遍历.直接在容器类直接添加顺序遍历方法</p></li><li><p>让访问者自己实现遍历.直接暴露数据细节给外部 </p><h3 id="4-不使用迭代模式的缺点"><a href="#4-不使用迭代模式的缺点" class="headerlink" title="4. 不使用迭代模式的缺点"></a>4. 不使用迭代模式的缺点</h3><p>以上方法1与方法2都可以实现对象遍历,但是这样有什么问题呢？</p></li><li><p>容器类承担了太多的功能:一方面需要提供添加删除等本身应有的功能;一方面还要提供遍历访问功能</p></li><li><p>往往容器在实现遍历的过程中,需要保存遍历状态,当根元素的添加删除等功能夹杂在一起后,很容易引起混乱和程序运行错误等</p><h3 id="5-迭代模式的角色和职责"><a href="#5-迭代模式的角色和职责" class="headerlink" title="5. 迭代模式的角色和职责"></a>5. 迭代模式的角色和职责</h3></li></ol><ul><li><strong>Iterator(迭代器接口)</strong> :该接口必须定义实现迭代功能的最小定义方法集.比如提供hasNext()和next()方法.</li><li><strong>ConcreteIterator(迭代器实现类)</strong>:迭代器接口Iterator的实现类,可以根据具体情况加以实现</li><li><strong>Aggregate(容器接口)</strong>:定义基本功能以及提供类似Iterator iterator()的方法</li><li><strong>ConcreateAggregate(容器实现类)</strong>:容器接口的实现类,必须实现Iterator iterator()方法<h3 id="6-优缺点"><a href="#6-优缺点" class="headerlink" title="6. 优缺点"></a>6. 优缺点</h3><h4 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点:"></a>6.1 优点:</h4></li></ul><ol><li>实现功能分离,简化容器接口.让容器只实现本身的基本功能,把迭代功能委让给外部实现,复合类的设计原则.</li><li>隐藏容器的实现细节</li><li>为容器或其子容器提供了一个统一的接口,一方面方便调用,另一外面使得调用者不必关注迭代器的实现细节</li><li>可以为容器或其自容器实现不同的迭代方法或者多个迭代方法<h4 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h4>由于迭代器迷失将存储数据和遍历数据的职责分离,增加新的聚合类需要对用增加新的迭代器类,类的个数成对增加,这在一定程度上增加的系统的复杂性.<h3 id="7-代码示例"><a href="#7-代码示例" class="headerlink" title="7. 代码示例"></a>7. 代码示例</h3>迭代器接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 迭代器接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>容器接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 容器接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>迭代器实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 迭代器具体实现</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContreateInterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Aggregate list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContreateInterator</span><span class="params">(Aggregate list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= list.getSize()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = list.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>容器实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 容器实现类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        list[index++] = object;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContreateInterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            aggregate.add(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator iterator = aggregate.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;18-设计模式之迭代器模式-Iterator-Pattern&quot;&gt;&lt;a href=&quot;#18-设计模式之迭代器模式-Iterator-Pattern&quot; class=&quot;headerlink&quot; title=&quot;18.   设计模式之迭代器模式(Iterator Pattern)&quot;&gt;&lt;/a&gt;18.   设计模式之迭代器模式(Iterator Pattern)&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;Iterator模式是行为模式的一种,它把容器中包含的内部对象的访问委让给外部类,使用iterator(遍历)按顺序进行遍历访问的设计模式&lt;/p&gt;
&lt;h3 id=&quot;2-应用场景&quot;&gt;&lt;a href=&quot;#2-应用场景&quot; class=&quot;headerlink&quot; title=&quot;2. 应用场景&quot;&gt;&lt;/a&gt;2. 应用场景&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式(7)</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F(7)/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F(7)/</id>
    <published>2021-03-12T02:17:43.959Z</published>
    <updated>2021-03-12T02:17:43.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-设计模式之适配器模式-Adapter-Pattren"><a href="#7-设计模式之适配器模式-Adapter-Pattren" class="headerlink" title="7. 设计模式之适配器模式(Adapter Pattren)"></a>7. 设计模式之适配器模式(Adapter Pattren)</h1><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>Adapter 模式也叫适配器模式,是构造性模式的一种,通过Adapter模式可以改变已有类(或外部类)的接口形式.将一个类的接口转换成客户希望的另外一个接口.Apadter 模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作.</p><h3 id="2-角色及其职责"><a href="#2-角色及其职责" class="headerlink" title="2. 角色及其职责"></a>2. 角色及其职责</h3><ul><li>Traget：Client 所使用的目标接口,可以是接口或者抽象类</li><li>Adaptee:需要适配的类接口</li><li>Adapter: 适配器,负责Adaptee的接口与Traget的接口进行适配</li><li>Client：与复合Traget接口的对象协调的类<h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><h4 id="3-1-类适配器模式"><a href="#3-1-类适配器模式" class="headerlink" title="3.1 类适配器模式"></a>3.1 类适配器模式</h4>原理: 通过继承来实现适配器功能<br><br>&nbsp;&nbsp;Adapter 类继承Adaptee(被适配类),同时实现Traget接口(因为java不支持多继承,所以这里只能通过接口来实现多继承),在Client类中我们可以根据需要选择并创建任一符合需求的子类,来实现具体的功能<br>被适配的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 220v的电压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v220</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;220v的电压&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>适配器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v28</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        v220();</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配成了18V的电压&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  类适配器</span></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.v28();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>测试结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">220v的电压</span><br><span class="line">被适配成了18V的电压</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-对象适配器-委托方式"><a href="#3-2-对象适配器-委托方式" class="headerlink" title="3.2 对象适配器(委托方式)"></a>3.2 对象适配器(委托方式)</h4><p>不使用多继承或者继承的方式,而使用直接关联</p><p>被适配的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 220v的电压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v220</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;220v的电压&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter2</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v18</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.v220();</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配成了18V的电压&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//  对象适配器</span></span><br><span class="line">        Adapter2 adapter2 = <span class="keyword">new</span> Adapter2(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        adapter2.v18();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">220v的电压</span><br><span class="line">被适配成了18V的电压</span><br></pre></td></tr></table></figure><h4 id="3-3-区别"><a href="#3-3-区别" class="headerlink" title="3.3 区别"></a>3.3 区别</h4><p>类适配器的重点在于类,是通过构造一个继承Adaptee类来实现适配器功能的</p><p>对象适配器的重点在于对象,是通过在直接包含Adaptee类来实现的.当需要调用特殊功能的时候直接调用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可</p><h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><h4 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点:"></a>4.1 优点:</h4><p><strong>更好的复用性</strong>:系统需要使用现用的类,而此类的接口不符合系统的需要.那么使用适配器模式就可以让这些功能得到更好的复用</p><p><strong>更好的扩展性</strong>:在实现适配器功能的时候,可以调用自己开发的功能,从而自然的扩展系统的功能</p><h4 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h4><p>过多的使用适配器,会让系统非常的凌乱,不易整体进行把握.比如,明明看到调用的是A接口,其实内部被适配成了B接口的实现,一个系统如果太多的出现这种情况,无异于异常灾难.因为如果不是很有必要,可以不使用适配器模式,而是直接对系统进行重构.</p><h3 id="5-适配器模式在源码中的体现"><a href="#5-适配器模式在源码中的体现" class="headerlink" title="5. 适配器模式在源码中的体现"></a>5. 适配器模式在源码中的体现</h3><p>Spring中适配器模式也应用的非常广泛,例如SpringAOP中的AdvisorAdapter,他有三个实现类 AfterReturningAdviceAdapter,MethodBeforeAdviceAdapter,ThrowsAdviceAdapter,我们先看顶层接口AdvisorAdapter的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看 ThrowsAdviceAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.aop.Advice;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Advisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.ThrowsAdvice;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThrowsAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ThrowsAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice <span class="keyword">instanceof</span> ThrowsAdvice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThrowsAdviceInterceptor(advisor.getAdvice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MethodBeforeAdviceAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.aop.Advice;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Advisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    MethodBeforeAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice <span class="keyword">instanceof</span> MethodBeforeAdvice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.aop.Advice;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Advisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    AfterReturningAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice <span class="keyword">instanceof</span> AfterReturningAdvice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">        AfterReturningAdvice advice = (AfterReturningAdvice)advisor.getAdvice();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AfterReturningAdviceInterceptor(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring会根据不同的AOP配置来确定使用对应的Advice,跟策略模式不同的一个方法可以同时拥有多个Advice<br>接下来看一个Spirng MVC的HandlerAdapter,他也有多个子类<br>AbstractHandlerMethodAdapter,HttpRequestHandlerAdapter,RequestMappingHandlerAdapter,SimpleControllerHandlerAdapter,SimpleServletHandlerAdapter.其适配调用的关键代码是在 DispatcherServlet的doDispatch 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest processedRequest = request;</span><br><span class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">                Object dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">                    multipartRequestParsed = processedRequest != request;</span><br><span class="line">                    mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br><span class="line">                    <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    String method = request.getMethod();</span><br><span class="line">                    <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">                    <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                        <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Last-Modified value for [&quot;</span> + getRequestUri(request) + <span class="string">&quot;] is: &quot;</span> + lastModified);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                    dispatchException = var20;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                    dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 doDispatch()方法中调用了getHandlerAdapter()方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = <span class="keyword">this</span>.handlerAdapters.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                HandlerAdapter ha = (HandlerAdapter)var2.next();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Testing handler adapter [&quot;</span> + ha + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ha;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;No adapter for handler [&quot;</span> + handler + <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在getHandlerAdapter()方法中循环调用了supports()方法判断是否兼容,循环迭代集合中的Adapter又是在初始化的时候早已赋值.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;7-设计模式之适配器模式-Adapter-Pattren&quot;&gt;&lt;a href=&quot;#7-设计模式之适配器模式-Adapter-Pattren&quot; class=&quot;headerlink&quot; title=&quot;7. 设计模式之适配器模式(Adapter Pattren)&quot;&gt;&lt;/a&gt;7. 设计模式之适配器模式(Adapter Pattren)&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;Adapter 模式也叫适配器模式,是构造性模式的一种,通过Adapter模式可以改变已有类(或外部类)的接口形式.将一个类的接口转换成客户希望的另外一个接口.Apadter 模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作.&lt;/p&gt;
&lt;h3 id=&quot;2-角色及其职责&quot;&gt;&lt;a href=&quot;#2-角色及其职责&quot; class=&quot;headerlink&quot; title=&quot;2. 角色及其职责&quot;&gt;&lt;/a&gt;2. 角色及其职责&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之解释器模式(17)</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F(17)/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F(17)/</id>
    <published>2021-03-12T02:17:43.958Z</published>
    <updated>2021-03-12T02:17:43.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="17-设计模式之解释器模式-Interpreter-Pattern"><a href="#17-设计模式之解释器模式-Interpreter-Pattern" class="headerlink" title="17. 设计模式之解释器模式(Interpreter Pattern)"></a>17. 设计模式之解释器模式(Interpreter Pattern)</h2><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>解释器模式是行为模式的一种,通过建立一个解释器,对于特定的计算机程序设计语言,用来解释预先定义的文法.简单的说,Interpreter 模式是一种简单的语法解释器构架</p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><ol><li>可以将一个需要解释执行的语言中的句子表达为一个抽象语法树</li><li>一些重复出现问题可以用一种简单的语言来进行表达</li><li>文法较为简单<h3 id="3-角色与职责"><a href="#3-角色与职责" class="headerlink" title="3. 角色与职责"></a>3. 角色与职责</h3></li><li><strong>Context</strong>: 解释器上下文环境类,用来存储解释器的上下文环境,比如需要解释的文法等</li><li><strong>AbstractExpression</strong>: 解释器抽象类</li><li><strong>ConcreteExoression</strong>: 解释器具体实现类<h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><h4 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点:"></a>4.1 优点:</h4></li><li>可扩展性比较好,灵活</li><li>增加了新的解释表达式的方式</li><li>易于实现文法<h4 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点:"></a>4.2 缺点:</h4></li><li>执行效率比较低,可利用场景比较少</li><li>对于负责的文法比较难维护<h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h3>解释器上下文环境<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> input;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> output;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>抽象类解释器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 解释器抽象类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>解释器具体实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecreaseExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;递减&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> input = context.getInput();</span><br><span class="line">        input--;</span><br><span class="line">        context.setInput(input);</span><br><span class="line">        context.setOutput(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreaseExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;递增&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> input = context.getInput();</span><br><span class="line">        input++;</span><br><span class="line">        context.setInput(input);</span><br><span class="line">        context.setOutput(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = Context.builder().input(<span class="number">15</span>).build();</span><br><span class="line"></span><br><span class="line">        AbstractExpression expression1 = <span class="keyword">new</span> IncreaseExpression();</span><br><span class="line">        expression1.interpret(context);</span><br><span class="line">        System.out.println(context.toString());</span><br><span class="line">        AbstractExpression expression2 = <span class="keyword">new</span> DecreaseExpression();</span><br><span class="line">        expression2.interpret(context);</span><br><span class="line">        System.out.println(context.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">递增</span><br><span class="line">Context(input=<span class="number">16</span>, output=<span class="number">16</span>)</span><br><span class="line">递减</span><br><span class="line">Context(input=<span class="number">15</span>, output=<span class="number">15</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;17-设计模式之解释器模式-Interpreter-Pattern&quot;&gt;&lt;a href=&quot;#17-设计模式之解释器模式-Interpreter-Pattern&quot; class=&quot;headerlink&quot; title=&quot;17. 设计模式之解释器模式(Interpreter Pattern)&quot;&gt;&lt;/a&gt;17. 设计模式之解释器模式(Interpreter Pattern)&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;解释器模式是行为模式的一种,通过建立一个解释器,对于特定的计算机程序设计语言,用来解释预先定义的文法.简单的说,Interpreter 模式是一种简单的语法解释器构架&lt;/p&gt;
&lt;h3 id=&quot;2-应用场景&quot;&gt;&lt;a href=&quot;#2-应用场景&quot; class=&quot;headerlink&quot; title=&quot;2. 应用场景&quot;&gt;&lt;/a&gt;2. 应用场景&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式(26)</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F(26)/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F(26)/</id>
    <published>2021-03-12T02:17:43.958Z</published>
    <updated>2021-03-12T02:17:43.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-设计模式之访问者模式-Visitor-Pattern"><a href="#26-设计模式之访问者模式-Visitor-Pattern" class="headerlink" title="26. 设计模式之访问者模式(Visitor Pattern)"></a>26. 设计模式之访问者模式(Visitor Pattern)</h2><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>访问者模式是行为模式的一种,它分离对象的数据和行为,使用Visitor模式可以不修改已有类的情况下,增加新的操作.</p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><ul><li>对象结构比较稳定,但经常需要在此对象结构上定义新的操作.</li><li>需要对一个对象结构中的对象进行很多不同的且不相关的操作,而需要避免这些操作”污染”这些对象的类,也不希望在增加新的操作时修改这些类.<h3 id="3-角色与职责"><a href="#3-角色与职责" class="headerlink" title="3. 角色与职责"></a>3. 角色与职责</h3></li><li>访问者角色(Visitor):为该对象结构中具体元素角色声明一个访问操作接口.该操作接口的名称和参数标识了发送访问请求给具体访问者的具体元素角色.这样访问者就可以通过该元素角色的特定接口直接访问它.</li><li>具体访问者角色(Concrete  Vistitor):实现每个由访问者角色(Visitor)声明的操作.</li><li>元素角色(Element):定义一个Accept操作,它以一个访问者为参数.</li><li>具体元素角色(Concrete Element):实现由元素角色提供的Accept角色</li><li>对象结构角色(Object Structure):这是使用访问者模式必备的角色.它要具备以下特征:能枚举它的元素,可以提供一个高层的接口以允许该访问者访问它的元素;可以是一个复合(组合模式)或是一个集合,如一个列表或一个无序集合.<h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><h4 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点:"></a>4.1 优点:</h4></li><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活性<h4 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点:"></a>4.2 缺点:</h4></li><li>具体元素对访问者公布细节,违反了迪米特原则.</li><li>具体元素变更比较困难,</li><li>违反了依赖倒置原则,依赖了具体类,没有依赖抽象.<h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 单个单子的接口(Element)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bill</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer accountBookViewer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBill</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 消费的单子</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeBill</span> <span class="keyword">extends</span> <span class="title">AbstractBill</span> <span class="keyword">implements</span> <span class="title">Bill</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumeBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(amount, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer accountBookViewer)</span> </span>&#123;</span><br><span class="line">        accountBookViewer.view(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 收入的单子</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomeBill</span> <span class="keyword">extends</span> <span class="title">AbstractBill</span> <span class="keyword">implements</span> <span class="title">Bill</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncomeBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(amount, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer accountBookViewer)</span> </span>&#123;</span><br><span class="line">        accountBookViewer.view(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 账单查看者接口(相当于Visitor)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountBookViewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看消费的单子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumeBill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill consumeBill)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看收入的单子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> incomeBill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill incomeBill)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 老板类, 查看账本的类之一</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">AccountBookViewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalIncome;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalConsume;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill consumeBill)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        totalConsume += consumeBill.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill incomeBill)</span> </span>&#123;</span><br><span class="line">        totalIncome += incomeBill.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老板查看一共多少收入,数目是:&quot;</span> + totalIncome);</span><br><span class="line">        <span class="keyword">return</span> totalIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalConsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老板查看一共多少花费,数目是:&quot;</span> + totalConsume);</span><br><span class="line">        <span class="keyword">return</span> totalConsume;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 注册会计师, 查看账号的类之一</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPA</span> <span class="keyword">implements</span> <span class="title">AccountBookViewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会计在查看账本时,如果是支出,且支出是工资, 则要看是否交税</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumeBill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill consumeBill)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (consumeBill.getItem().equals(<span class="string">&quot;工资&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注会查看账本时，如果单子的消费目的是发工资，则注会会查看有没有交个人所得税。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是收入，则所有的收入都要交税</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> incomeBill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill incomeBill)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注会查看账本时，只要是收入，注会都要查看公司交税了没。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 账本类(相当于ObjectStruture)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountBook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单子列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Bill&gt; billList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加单子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Bill bill)</span> </span>&#123;</span><br><span class="line">        billList.add(bill);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供账本的查看者查看账本</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountBookViewer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(AccountBookViewer accountBookViewer)</span> </span>&#123;</span><br><span class="line">        billList.stream().forEach(bill -&gt; &#123;</span><br><span class="line">            bill.accept(accountBookViewer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 编写一个财务的例子</span></span><br><span class="line">        AccountBook accountBook = <span class="keyword">new</span> AccountBook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加两条收入</span></span><br><span class="line">        accountBook.add(<span class="keyword">new</span> IncomeBill(<span class="number">20000</span>, <span class="string">&quot;卖广告位&quot;</span>));</span><br><span class="line">        accountBook.add(<span class="keyword">new</span> IncomeBill(<span class="number">10000</span>, <span class="string">&quot;卖商品&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加两条支出</span></span><br><span class="line">        accountBook.add(<span class="keyword">new</span> ConsumeBill(<span class="number">5000</span>, <span class="string">&quot;工资&quot;</span>));</span><br><span class="line">        accountBook.add(<span class="keyword">new</span> ConsumeBill(<span class="number">7000</span>, <span class="string">&quot;卖材料&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个访问者</span></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss();</span><br><span class="line">        accountBook.show(boss);</span><br><span class="line">        boss.getTotalConsume();</span><br><span class="line">        boss.getTotalIncome();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CPA cpa = <span class="keyword">new</span> CPA();</span><br><span class="line">        accountBook.show(cpa);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">老板查看一共多少花费,数目是:<span class="number">12000.0</span></span><br><span class="line">老板查看一共多少收入,数目是:<span class="number">30000.0</span></span><br><span class="line">注会查看账本时，只要是收入，注会都要查看公司交税了没。</span><br><span class="line">注会查看账本时，只要是收入，注会都要查看公司交税了没。</span><br><span class="line">注会查看账本时，如果单子的消费目的是发工资，则注会会查看有没有交个人所得税。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;26-设计模式之访问者模式-Visitor-Pattern&quot;&gt;&lt;a href=&quot;#26-设计模式之访问者模式-Visitor-Pattern&quot; class=&quot;headerlink&quot; title=&quot;26. 设计模式之访问者模式(Visitor Pattern)&quot;&gt;&lt;/a&gt;26. 设计模式之访问者模式(Visitor Pattern)&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;访问者模式是行为模式的一种,它分离对象的数据和行为,使用Visitor模式可以不修改已有类的情况下,增加新的操作.&lt;/p&gt;
&lt;h3 id=&quot;2-使用场景&quot;&gt;&lt;a href=&quot;#2-使用场景&quot; class=&quot;headerlink&quot; title=&quot;2. 使用场景&quot;&gt;&lt;/a&gt;2. 使用场景&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式(15)</title>
    <link href="http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F(15)/"/>
    <id>http://luyanan.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F(15)/</id>
    <published>2021-03-12T02:17:43.958Z</published>
    <updated>2021-03-12T02:17:43.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-责任链模式-Chain-of-Responsibility-COR"><a href="#15-责任链模式-Chain-of-Responsibility-COR" class="headerlink" title="15. 责任链模式(Chain of Responsibility )(COR)"></a>15. 责任链模式(Chain of Responsibility )(COR)</h2><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>Chain of Responsibility(COR) 模式也叫作职责链模式或者责任连锁模式,是行为模式之一.该模式构造一系列分别担当不同职责的类的对象来共同完成一个任务,这些类的对象之间像链条一样紧密相连,所以被称作职责链模式</p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>例1:比如客户Client 要完成一个任务,这个任务包括a,b,c,d四个部分.<br><br>首先 客户Client 需要把任务交给A，A完成a部分后,把任务交给B，B完成b部分,….，直到D 完成D部分.<br><br>例2: 比如政府部分的某项工作,县政府先完成自己能处理的部分,不能处理的部分交给省政府 ,省政府再完成自己职责范围内的部分,不能处理的部分交给中央政府,中央政府最后完成该项工作.<br><br>例3:软件窗口的消息传播<br><br>例4:Servlet容器的过滤器(Filter)框架实现</p><h3 id="3-职责链模式的基本条件"><a href="#3-职责链模式的基本条件" class="headerlink" title="3. 职责链模式的基本条件"></a>3. 职责链模式的基本条件</h3><p>要实现COR 模式.需要满足该模式的基本条件:</p><ol><li>对象链的组织,需要将某些任务的所有职责执行对象以链的形式加以组织</li><li>消息或请求的传递,将消息或请求沿着对象链传递,以让处于对象链中的对象得到处理机会</li><li>处于对象链中的对象的职责分配,不同的对象完成不同的职责.</li><li>任务的完成.处于对象链的末尾的对象结束任务并停止消息或请求的继续传递<h3 id="4-角色和职责"><a href="#4-角色和职责" class="headerlink" title="4. 角色和职责"></a>4. 角色和职责</h3></li></ol><ul><li><strong>Handler</strong>:处理类的抽象父类</li><li><strong>ConcreteHandler</strong>:具体的处理类<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点:"></a>5. 优缺点:</h3></li><li><strong>优点</strong>:</li></ul><ol><li>责任的分担.每个类只需要处理自己该处理的工作(不该处理的传递给下一个对象),明确各类的责任范围,符合类的最小封装原则.</li><li>可以根据需要自由组合工作流程.如果工作流程发生变化,可以通过重新分配对象链便可适应新的工作流程.</li><li>类与类之间可以以松耦合的形式加以组织</li></ol><ul><li><strong>缺点</strong>:<br>因为处理时以链的形式在对象间传递消息,根据实现方式不同,有可能会影响处理的速度<h3 id="6-代码实例"><a href="#6-代码实例" class="headerlink" title="6. 代码实例:"></a>6. 代码实例:</h3>抽象父类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.cor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 抽象过滤</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFilterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AbstractFilterHandler nextFilterHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">filter</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractFilterHandler <span class="title">addFilter</span><span class="params">(AbstractFilterHandler filterHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextFilterHandler = filterHandler;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nextFilterHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>具体的处理类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.cor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> html 过滤,将字符串中出现的&quot;&lt;&gt;&quot;符号替换成&quot;[]&quot;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">extends</span> <span class="title">AbstractFilterHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String replaceAll = str.replaceAll(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;]&quot;</span>).replaceAll(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nextFilterHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextFilterHandler.filter(replaceAll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaceAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.cor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 敏感词过滤 处理字符串中的敏感信息，将被就业和谐成就业</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">extends</span> <span class="title">AbstractFilterHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String replaceAll = str.replaceAll(<span class="string">&quot;被就业&quot;</span>, <span class="string">&quot;就业&quot;</span>).replaceAll(<span class="string">&quot;敏感&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextFilterHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextFilterHandler.filter(replaceAll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaceAll;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.cor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span> 表情过滤   //将字符串中出现的&quot;:):&quot;转换成&quot;^V^&quot;;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceFilter</span> <span class="keyword">extends</span> <span class="title">AbstractFilterHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String replaceAll = str.replaceAll(<span class="string">&quot;:\\):&quot;</span>, <span class="string">&quot;^V^&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextFilterHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextFilterHandler.filter(replaceAll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaceAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.formula.design.cor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:luyanan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>:luyanan0718@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;:):,&lt;script&gt;,敏感,被就业,网络授课&quot;</span>;</span><br><span class="line">        <span class="comment">//不使用责任链模式</span></span><br><span class="line">        AbstractFilterHandler htmlFilter = <span class="keyword">new</span> HTMLFilter();</span><br><span class="line">        AbstractFilterHandler sensitiveFilter = <span class="keyword">new</span> SensitiveFilter();</span><br><span class="line">        AbstractFilterHandler faceFilter = <span class="keyword">new</span> FaceFilter();</span><br><span class="line">        htmlFilter.addFilter(sensitiveFilter)</span><br><span class="line">                .addFilter(faceFilter);</span><br><span class="line">        System.out.println(htmlFilter.filter(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^V^,[script],,就业,网络授课</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;15-责任链模式-Chain-of-Responsibility-COR&quot;&gt;&lt;a href=&quot;#15-责任链模式-Chain-of-Responsibility-COR&quot; class=&quot;headerlink&quot; title=&quot;15. 责任链模式(Chain of Responsibility )(COR)&quot;&gt;&lt;/a&gt;15. 责任链模式(Chain of Responsibility )(COR)&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;Chain of Responsibility(COR) 模式也叫作职责链模式或者责任连锁模式,是行为模式之一.该模式构造一系列分别担当不同职责的类的对象来共同完成一个任务,这些类的对象之间像链条一样紧密相连,所以被称作职责链模式&lt;/p&gt;
&lt;h3 id=&quot;2-应用场景&quot;&gt;&lt;a href=&quot;#2-应用场景&quot; class=&quot;headerlink&quot; title=&quot;2. 应用场景&quot;&gt;&lt;/a&gt;2. 应用场景&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://luyanan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
