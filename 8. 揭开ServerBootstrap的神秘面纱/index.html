<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="揭开ServerBootstrap 的神秘面纱1. 简介我们首先来看一下 ServerBootstrap 服务端的启动代码 1234567891011121314151617181920212223242526272829public void start(int port) &amp;#123;       EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员报社">
<meta property="og:url" content="http://luyanan.com/8.%20%E6%8F%AD%E5%BC%80ServerBootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="揭开ServerBootstrap 的神秘面纱1. 简介我们首先来看一下 ServerBootstrap 服务端的启动代码 1234567891011121314151617181920212223242526272829public void start(int port) &amp;#123;       EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20190927173532.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190927205854.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190928164210.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190928164435.png">
<meta property="og:image" content="http://files.luyanan.com//img/20190928165400.png">
<meta property="article:published_time" content="2021-03-01T09:46:51.239Z">
<meta property="article:modified_time" content="2020-12-24T09:34:49.986Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Python, Rust, C++, Go, 爬虫, 深度学习, 服务研发, 对象存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20190927173532.png">

<link rel="canonical" href="http://luyanan.com/8.%20%E6%8F%AD%E5%BC%80ServerBootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/8.%20%E6%8F%AD%E5%BC%80ServerBootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 17:46:51" itemprop="dateCreated datePublished" datetime="2021-03-01T17:46:51+08:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-24 17:34:49" itemprop="dateModified" datetime="2020-12-24T17:34:49+08:00">2020-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="揭开ServerBootstrap-的神秘面纱"><a href="#揭开ServerBootstrap-的神秘面纱" class="headerlink" title="揭开ServerBootstrap 的神秘面纱"></a>揭开ServerBootstrap 的神秘面纱</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>我们首先来看一下 ServerBootstrap 服务端的启动代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">       EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">       EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">           bootstrap.channel(NioServerSocketChannel.class)</span><br><span class="line">                   .group(bossGroup, workerGroup)</span><br><span class="line">                   .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;)</span><br><span class="line">                   .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                   .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">           <span class="comment">// 绑定端口, 开始接受进来的请求</span></span><br><span class="line">           ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">           future.channel().closeFuture().sync();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           bossGroup.shutdownGracefully();</span><br><span class="line">           workerGroup.shutdownGracefully();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> NIOChatServer().start(<span class="number">8080</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>服务端基本写法和客户端的代码相比, 没有很大的差别, 基本上也是进行了如下几个部分的初始化：</p>
<ol>
<li>EventLoopGroup: 不论是服务端代码还是客户端, 都必须指定 EventLoopGroup. 在上面的代码中, 指定了NioEventLoopGroup, 表示一个 NIO的EventLoopGroup, 不过服务端需要指定两个 <code>EventLoopGroup</code>, 一个是bossGroup, 用于处理客户端的连接请求， 另一个是 workGroup, 用于处理与各个客户端连接的IO操作</li>
<li>ChannalType: 指定channel的类型, 因为是服务器端, 因此用到了NioServerSocketChannel </li>
<li>handler :  设置数据处理器</li>
</ol>
<h2 id="2-NioServerSocketChannel-的创建"><a href="#2-NioServerSocketChannel-的创建" class="headerlink" title="2. NioServerSocketChannel 的创建"></a>2. NioServerSocketChannel 的创建</h2><p>我们在分析客户端channel 初始化过程已经提到, Channal 是对Java 底层Socket 连接的抽象, 并且知道了客户端Channel 的具体类型是 NioServerSocketChannel . 那么, 自然的服务端的Channel 类型就是NioServerSocketChannel . 那么接下来我们按照分析客户端的流程对服务端的代码也同样的分析一遍, 通过前面的分析, 我们已经知道了, Chanel的类型的指定是在初始化时 , 通过Bootstrap 的channel 方法设置的, 服务端也是同样的方式.</p>
<p>再看服务端代码, 我们调用了 ServerBootystrap 的channel(NioSocketChannel.class)  方法, 传的参数是 NioSocketChannel 对象 如此， 按照客户端代码同样的流程, 我们可以确定 NioSocketChannel的实例化也是通过 ReflectiveChannelFactory 来创建的., 而ReflectiveChannelFactory 中的clazz 字段被 赋值为  NioServerSocketChannel.class, 因此当调用 NioServerSocketChannel 的 newChannel  方法, 就能获取到一个 NioServerSocketChannel的 实例. newChannel() 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后, 我们来总结一下:</p>
<ol>
<li> ServerBootstrap 中 的channelFactory 的实现类是ReflectiveChannelFactory类</li>
<li>创建的Channel 具体类型是NioServerSocketChannel</li>
</ol>
<p>channel 实例化过程, 其实就是调用chanellFactory 的 newChannel()   方法， 而实例化的Channel 具体类型就是初始化 ServerBootstrap  时传给 chanel()  方法的实参, 因此, 上面代码案例中的服务端 ServerBootstrap , 创建的 Channel 实例就是 NioServerSocketChannel  的实例。</p>
<h2 id="3-服务端Channel-的初始化"><a href="#3-服务端Channel-的初始化" class="headerlink" title="3. 服务端Channel 的初始化"></a>3. 服务端Channel 的初始化</h2><p>接下来我们来分析一下  NioServerSocketChannel   的实例化过程, 先看一下 NioServerSocketChannel   的 类层次结构图:</p>
<p><img src="http://files.luyanan.com//img/20190927173532.png"></p>
<p>首先, 我们来追踪一下  NioServerSocketChannel    的默认构造, 和 NioSocketChannel  类似, 构造器都是调用 newSocket() 来打来一个Java 的NIO Socket. 不过需要注意的是, 客户端的 newSocket 方法调用的是openSocketChannel()，而 服务端的 newSocket()  调用的是 openServerSocketChannel(). 顾名思义, 一个是客户端是 java SocketChannel,  一个是服务端的 Java ServerSocketChannel,  来看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *  Use the &#123;<span class="doctag">@link</span> SelectorProvider&#125; to open &#123;<span class="doctag">@link</span> SocketChannel&#125; and so remove condition in</span></span><br><span class="line"><span class="comment">            *  &#123;<span class="doctag">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *  See &lt;a href=&quot;https://github.com/netty/netty/issues/2308&quot;&gt;#2308&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                   <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new instance</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来会调用重载的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">      config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个构造方法中, 调用父类构造方法时传入的参数是 <code>SelectionKey.OP_ACCEPT</code>.  作为对比, 我们回复一下, 在 客户端的Channel 初始化的时候, 传入的参数为 SelectionKey.OP_READ。在服务启动后需要监听客户端的连接请求, 因此这里我们设置为 SelectionKey.OP_ACCEPT, 也就是通知 selector 对客户端的连接请求感兴趣.</p>
<p>接着和客户端对比分析一下, 会逐层的调用父类的构造器 NioServerSocketChannel -&gt; AbstractNioMessageChannel -&gt; AbstractNioChannel -&gt; AbstractChannel。同样在 AbstractChannel 中实例化一个unsafe 和 pipeline.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 不过, 这里需要注意的是, 客户端的unsafe 是 AbstractNioByteChannel#NioByteUnsafe 的实例, 而服务端的unsafe 的实例是  AbstractNioMessageChannel.AbstractNioUnsafe 的实例。 因为 AbstractNioMessageChannel 重写了 newUnsafe()   方法, 其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractNioUnsafe <span class="title">newUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioMessageUnsafe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再总结一下 NioServerSocketChannel 实例化过程的执行逻辑</p>
<ol>
<li><p>调用 NioServerSocketChannel.newSocket(DEFAULT_SELECTOR_PROVIDER) 方法打开一个新的 Java Nio ServerSocketChannel </p>
</li>
<li><p>AbstractChannel 初始化被赋值的属性:</p>
<ul>
<li>parent: 设置为 null</li>
<li>unsafe: 通过 newUnsafe()  实例化 一个 unsafe  对象, 类型是 AbstractNioMessageChannel#AbstractNioUnsafe</li>
<li>pipeline :  DefaultChannelPipeline 实例</li>
</ul>
</li>
<li><p>AbstractNioChannel  中被赋值的属性:</p>
<ul>
<li>ch: 赋值为 Java Nio  的ServerSocketChannel, 调用NioSocketChannel 的 newSocket()  获取</li>
<li>readInterstOp: 默认赋值为 <code>SelectionKey.OP_ACCEPT</code></li>
<li>ch: 设置为非阻塞, 调用 ch.configureBlocking(false)方法</li>
</ul>
</li>
<li><p>NioServerSocketChannel:</p>
<p>  config: new NioServerSocketChannelConfig(this, javaChannel().socket());</p>
</li>
</ol>
<h2 id="4-ChannelPipeline-初始化"><a href="#4-ChannelPipeline-初始化" class="headerlink" title="4. ChannelPipeline 初始化"></a>4. ChannelPipeline 初始化</h2><p>服务端ChannelPipeline 的初始化跟 客户端的一样</p>
<h2 id="5-服务端Channel-注册到Selector"><a href="#5-服务端Channel-注册到Selector" class="headerlink" title="5. 服务端Channel 注册到Selector"></a>5. 服务端Channel 注册到Selector</h2><p>服务端Channel 的注册过程跟客户端的一样</p>
<h2 id="6-bossGroup-和workGroup"><a href="#6-bossGroup-和workGroup" class="headerlink" title="6. bossGroup 和workGroup"></a>6. bossGroup 和workGroup</h2><p>在客户端的时候,我们初始化了一个 EventLoopGroup 对象, 而在服务端初始化时, 我们设置了两个EventLoopGroup. 一个是 bossGroup, 一个是  workGroup, 那么这两个 EventLoopGroup 都是干什么的呢? 接下来我们来详细探究一下. 其实 , bossGroup 只用于服务端的 accept,  也就是用于处理客户端新连接接入请求, 我们可以将Netty 比喻为一个餐馆, bossGroup 就像一个大堂经理, 当客户来到餐馆吃饭的时候, 大堂经理就会引导顾客就坐, 为顾客端茶送水等. 而workGroup 就是实际上干活的厨师. 他们负责客户端连接通道的IO操作, 当大堂尽力接待顾客后, 就可以稍作休息, 而此时厨师们(workGroup) 就开始忙碌的准备饭菜 ，    关于bossGroup和workerGroup 的关系, 我们可以用下图来表示, </p>
<p><img src="http://files.luyanan.com//img/20190927205854.png"></p>
<p>首先, 服务端的 bossGroup 不断监听是否有客户端的连接, 当发现有新的客户端连接到来时 , bossGroup 就会为此连接初始化各种资源, 然后从 workerGroup 中选出一个EventLoop 绑定到此客户端连接中, 那么接下来服务器和客户端的交互过程就全在此分配的 EventLoop 中完成, </p>
<p>首先在ServerBootstrap  初始化时, 调用了 bootstrap.group(bossGroup,workGroup)  设置了两个EventLoop,    我们跟踪进去就会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然, 这个方法初始化了两个字段, 一个是 group = parentGroup, 它是在 super.group(parentGroup); 中完成初始化的, 另一个是 this.childGroup = childGroup;  接着从 应用程序的启动代码来看调用了  bootstrap.bind()  方法来监听一个本地端口,  bing()  方法会触发如下调用链</p>
<blockquote>
<p> AbstractBootstrap.bind() -&gt; AbstractBootstrap.doBind() -&gt; AbstractBootstrap.initAndRegister()</p>
</blockquote>
<p>源码看到这里为止，我们发现 AbstractBootstrap 的 initAndRegister()方法已经分析过了, 再来回顾一下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里 group()  方法返回的是上面我们提到的 bossGroup,  而这里的channel 其实就是 NioServerSocketChannel. 的实例， 因此我们可以猜测到 group().register(channel)  将 bossGroup 和NioSocketChannel 就关联起来了, 那么 workerGroup  具体是在哪里与 NioSocketChannel  关联起来的呢 ? 我们继续往下看 init(channel ) 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">       <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">           channel.config().setOptions(options);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">       <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">               channel.attr(key).set(e.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">       <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">       <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">       <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">       <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">           currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">           currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">               ChannelHandler handler = config.handler();</span><br><span class="line">               <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pipeline.addLast(handler);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// We add this handler via the EventLoop as the user may have used a ChannelInitializer as handler.</span></span><br><span class="line">               <span class="comment">// In this case the initChannel(...) method will only be called after this method returns. Because</span></span><br><span class="line">               <span class="comment">// of this we need to ensure we add our handler in a delayed fashion so all the users handler are</span></span><br><span class="line">               <span class="comment">// placed in front of the ServerBootstrapAcceptor.</span></span><br><span class="line">               ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                               currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p> 实际上init()  方法在ServerBootstrap 被重写了, 从上面的代码来看, 它为pipeline  添加了一个 ChannelInitializer, 而这个 ChannelInitializer 中添加了一个非常关键的 ServerBootstrapAcceptor 的 handler,  在ServerBootstrapAcceptor 中 重写了channelRead()  方法 . 其主要代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">         child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</span><br><span class="line">                     logger.warn(<span class="string">&quot;Unknown channel option: &quot;</span> + e);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 logger.warn(<span class="string">&quot;Failed to set a channel option: &quot;</span> + child, t);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">             child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                         forceClose(child, future.cause());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             forceClose(child, t);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>ServerBootstrapAcceptor 中的 childGroup 是构造此对象 传入的currentChildGroup,   也就是 workerGroup, 而这里的 channel 是NioSocketChannel 的实例.  因此这里的 childGroup 的 regster()  方法就是将 workerGroup 中的某个EventLoop 和NioSocketChannel 关联上了 . 既然这样, 那么现在的问题是 ServerBootstrapAcceptor 的channelRead()  是在哪里被调用的呢?  其实, 当一个client 连接到server 的时候,  Java 底层Nio ServerSocketChannel 就会有一个 SelectionKey.OP_ACCEPT 事件就绪 , 接着会调用到 NioServerSocketChannel 的 doReadMessages()</p>
<p>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      SocketChannel ch = javaChannel().accept();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">              buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          logger.warn(<span class="string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ch.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">              logger.warn(<span class="string">&quot;Failed to close a socket.&quot;</span>, t2);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 doReadMessages() 方法中, 通过调用 JavaChannel().accept() 方法获取到 客户端新连接的 SocketChannel 对象, 紧接着就实例化一个 NioSocketChannal,并且传入NioServerSocketChannel 对象 , 即this. 由此可知, 我们创建的这个NioSocketChannel 的父类 channel  就是 NioServerSocketChnanel 的实例. 接下来就经由 Netty的Pipelint 机制将读取事件逐个发送到各个handler 中, 于是就会触发我们前面提到的ServerBootstrapAcceptor 的 channelRead()<br>方法。</p>
<h2 id="7-服务端Selector-事件轮询"><a href="#7-服务端Selector-事件轮询" class="headerlink" title="7. 服务端Selector 事件轮询"></a>7. 服务端Selector 事件轮询</h2><p>再回到服务端的 ServerBootstrap 的启动代码,是从bind()  方法开始的, ServerBootstrap 的bind()  方法实际上就是其父类的 AbstractBootstrap的  bind() 方法, 来看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       validate();</span><br><span class="line">       SocketAddress localAddress = <span class="keyword">this</span>.localAddress;</span><br><span class="line">       <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;localAddress not set&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">       <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">       <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> regFuture;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">           <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">           ChannelPromise promise = channel.newPromise();</span><br><span class="line">           doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">           <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">           regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   Throwable cause = future.cause();</span><br><span class="line">                   <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                       <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                       promise.setFailure(cause);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                       <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                       promise.registered();</span><br><span class="line"></span><br><span class="line">                       doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class="line">       <span class="comment">// the pipeline in its channelRegistered() implementation.</span></span><br><span class="line">       channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                   channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   promise.setFailure(regFuture.cause());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在doBind0() 方法中,调用的是 EventLoop的execute()  方法, 我们继续跟进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">      <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">          addTask(task);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          startThread();</span><br><span class="line">          addTask(task);</span><br><span class="line">          <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">              reject();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">          wakeup(inEventLoop);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>在 execute()  中主要是创建线程, 将线程添加到 EventLoop 的无锁化串行任务队列. 我们重点关注一下 startThread() 方法, 继续看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.get(<span class="keyword">this</span>) == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> oldState = STATE_UPDATER.get(SingleThreadEventExecutor.<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                                SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Check if confirmShutdown() was called at the end of the loop.</span></span><br><span class="line">                    <span class="keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="number">0</span>) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;Buggy &quot;</span> + EventExecutor.class.getSimpleName() + <span class="string">&quot; implementation; &quot;</span> +</span><br><span class="line">                                SingleThreadEventExecutor.class.getSimpleName() + <span class="string">&quot;.confirmShutdown() must be called &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;before run() implementation terminates.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// Run all remaining tasks and shutdown hooks.</span></span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            cleanup();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                            threadLock.release();</span><br><span class="line">                            <span class="keyword">if</span> (!taskQueue.isEmpty()) &#123;</span><br><span class="line">                                logger.warn(</span><br><span class="line">                                        <span class="string">&quot;An event executor terminated with &quot;</span> +</span><br><span class="line">                                                <span class="string">&quot;non-empty task queue (&quot;</span> + taskQueue.size() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现 startThread()   最终调用的是  SingleThreadEventExecutor.this.run()  方法, 这个this 就是 NioEventLoop 对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// &#x27;wakenUp.compareAndSet(false, true)&#x27; is always evaluated</span></span><br><span class="line">                    <span class="comment">// before calling &#x27;selector.wakeup()&#x27; to reduce the wake-up</span></span><br><span class="line">                    <span class="comment">// overhead. (Selector.wakeup() is an expensive operation.)</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// However, there is a race condition in this approach.</span></span><br><span class="line">                    <span class="comment">// The race condition is triggered when &#x27;wakenUp&#x27; is set to</span></span><br><span class="line">                    <span class="comment">// true too early.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// &#x27;wakenUp&#x27; is set to true too early if:</span></span><br><span class="line">                    <span class="comment">// 1) Selector is waken up between &#x27;wakenUp.set(false)&#x27; and</span></span><br><span class="line">                    <span class="comment">//    &#x27;selector.select(...)&#x27;. (BAD)</span></span><br><span class="line">                    <span class="comment">// 2) Selector is waken up between &#x27;selector.select(...)&#x27; and</span></span><br><span class="line">                    <span class="comment">//    &#x27;if (wakenUp.get()) &#123; ... &#125;&#x27;. (OK)</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// In the first case, &#x27;wakenUp&#x27; is set to true and the</span></span><br><span class="line">                    <span class="comment">// following &#x27;selector.select(...)&#x27; will wake up immediately.</span></span><br><span class="line">                    <span class="comment">// Until &#x27;wakenUp&#x27; is set to false again in the next round,</span></span><br><span class="line">                    <span class="comment">// &#x27;wakenUp.compareAndSet(false, true)&#x27; will fail, and therefore</span></span><br><span class="line">                    <span class="comment">// any attempt to wake up the Selector will fail, too, causing</span></span><br><span class="line">                    <span class="comment">// the following &#x27;selector.select(...)&#x27; call to block</span></span><br><span class="line">                    <span class="comment">// unnecessarily.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// To fix this problem, we wake up the selector again if wakenUp</span></span><br><span class="line">                    <span class="comment">// is true immediately after selector.select(...).</span></span><br><span class="line">                    <span class="comment">// It is inefficient in that it wakes up the selector for both</span></span><br><span class="line">                    <span class="comment">// the first case (BAD - wake-up required) and the second case</span></span><br><span class="line">                    <span class="comment">// (OK - no wake-up required).</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// fallthrough</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到似曾相似的代码, 上面的代码主要就是用一个死循环, 在不断的轮询 SelectionKey,select()  方法 主要用来解决JDK 的空轮训Bug, 而 processSelectedKeys()  就是针对不同的轮询事件 进行处理. 如果客户端有数据写入, 最终也会调用 AbstractNioMessageChannel 的 doReadMessages()方法, 总结一下:</p>
<ol>
<li>Netty 的selector 事件轮询 是从EventLoop 的 execute()  方法开始的 </li>
<li>在EventLoop 的 execute()  方法中, 会为每个任务创建一个线程, 并保存到无锁化串行任务队列</li>
<li>线程任务队列的每个任务实际调用的是EventLoop 的 run()  方法</li>
<li>在 run() 中 调用 processSelectedKeys() 处理轮询事件</li>
</ol>
<h2 id="8-Netty-解决JDK-空轮训Bug"><a href="#8-Netty-解决JDK-空轮训Bug" class="headerlink" title="8 Netty 解决JDK 空轮训Bug"></a>8 Netty 解决JDK 空轮训Bug</h2><p>各位应该早有耳闻 臭名昭著的 Java NIO epoll的bug, 它会导致 selector  空轮训, 最终导致CPU 100%. 官方声称在 JDK1.6 版本的 update18 修复了此问题, 但是知道JDK1.7 版本该问题仍然存在, 只不过该Bug 发生概率降低了一些而已, 它并没有被 根本解决。出现此bug 是因为当Selector 的轮询结果为空, 也没有 wakeup 或者新消息处理, 则发现空轮训, CPU使用率达到了100%. 我们来看下这个问题在issus的原始描述</p>
<blockquote>
<p>This is an issue with poll (and epoll) on Linux. If a file descriptor for a connected socket is polled with a request<br>event mask of 0, and if the connection is abruptly terminated (RST) then the poll wakes up with the POLLHUP (and<br>maybe POLLERR) bit set in the returned event set. The implication of this behaviour is that Selector will wakeup and<br>as the interest set for the SocketChannel is 0 it means there aren’t any selected events and the select method<br>returns 0.</p>
</blockquote>
<p>具体解释为: 在部分Linux的2.6的 kernel 中, poll 和epoll 对于突然中断的连接 socket 会对返回的 eventSet事件集合置为 POLLHUP，也可能是 POLLERR。 eventSet 事件集合发生了变化, 这就可能导致Selector 会被唤醒.</p>
<p>这是与操作系统机制有关系的, JDK 虽然仅仅是一个兼容各个操作系统平台的软件。但很遗憾在JDK5和JDK6 最初的版本中(严格意义上来讲, JDK版本都是) , 这个问题并没有解决，而将这个帽子抛给了操作系统方, 这也就是这个bug 最终一直到2013 年才最终修复的原因.</p>
<p>在Netty 中 最终的解决办法是: 创建一个新的Selector, 将可用的事件重新注册到新的Selector 中来终止空轮训. 回顾事件轮询的关键代码:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line"><span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"><span class="comment">//省略 select 的唤醒逻辑</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件轮询处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们有提到了 select() 方法解决JDK 空轮训的bug ,它到底是如何解决的呢? 下来我们来一探究竟, 进入select()  方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">          <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">              <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                      selector.selectNow();</span><br><span class="line">                      selectCnt = <span class="number">1</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span></span><br><span class="line">              <span class="comment">// Selector#wakeup. So we need to check task queue again before executing select operation.</span></span><br><span class="line">              <span class="comment">// If we don&#x27;t, the task might be pended until select operation was timed out.</span></span><br><span class="line">              <span class="comment">// It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span></span><br><span class="line">              <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                  selector.selectNow();</span><br><span class="line">                  selectCnt = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">              selectCnt ++;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                  <span class="comment">// - Selected something,</span></span><br><span class="line">                  <span class="comment">// - waken up by user, or</span></span><br><span class="line">                  <span class="comment">// - the task queue has a pending task.</span></span><br><span class="line">                  <span class="comment">// - a scheduled task is ready for processing</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                  <span class="comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span></span><br><span class="line">                  <span class="comment">// As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span></span><br><span class="line">                  <span class="comment">// also log it.</span></span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  <span class="comment">// See https://github.com/netty/netty/issues/2426</span></span><br><span class="line">                  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                      logger.debug(<span class="string">&quot;Selector.select() returned prematurely because &quot;</span> +</span><br><span class="line">                              <span class="string">&quot;Thread.currentThread().interrupt() was called. Use &quot;</span> +</span><br><span class="line">                              <span class="string">&quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  selectCnt = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">              <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                  <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">                  selectCnt = <span class="number">1</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                      selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                  <span class="comment">// The selector returned prematurely many times in a row.</span></span><br><span class="line">                  <span class="comment">// Rebuild the selector to work around the problem.</span></span><br><span class="line">                  logger.warn(</span><br><span class="line">                          <span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">                          selectCnt, selector);</span><br><span class="line"></span><br><span class="line">                  rebuildSelector();</span><br><span class="line">                  selector = <span class="keyword">this</span>.selector;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line">                  selector.selectNow();</span><br><span class="line">                  selectCnt = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              currentTimeNanos = time;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">              <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                  logger.debug(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">                          selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">              logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">&quot; raised by a Selector &#123;&#125; - JDK bug?&quot;</span>,</span><br><span class="line">                      selector, e);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到, Selector 每一次轮询都计数 selectCnt ++, 开始轮询会计时并赋值给 timeoutMillis, 轮询完成后悔计时赋值给 time. 这两个时间差会有一个时间差, 而这个时间差就是每次轮询所消耗的时间, 从上面的逻辑看出， 如果每次轮询消耗的时间为0 ，且重复次数超过512次， 则调用rebuildSelector();, 则重构Selector, 我们跟进到源码中就会发现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebuildSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!inEventLoop()) &#123;</span><br><span class="line">           execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   rebuildSelector();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line">       <span class="keyword">final</span> Selector newSelector;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (oldSelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           newSelector = openSelector();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.warn(<span class="string">&quot;Failed to create a new Selector.&quot;</span>, e);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Register all channels to the new Selector.</span></span><br><span class="line">       <span class="keyword">int</span> nChannels = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;</span><br><span class="line">                   Object a = key.attachment();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelector) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">                       key.cancel();</span><br><span class="line">                       SelectionKey newKey = key.channel().register(newSelector, interestOps, a);</span><br><span class="line">                       <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                           <span class="comment">// Update SelectionKey</span></span><br><span class="line">                           ((AbstractNioChannel) a).selectionKey = newKey;</span><br><span class="line">                       &#125;</span><br><span class="line">                       nChannels ++;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       logger.warn(<span class="string">&quot;Failed to re-register a Channel to the new Selector.&quot;</span>, e);</span><br><span class="line">                       <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                           AbstractNioChannel ch = (AbstractNioChannel) a;</span><br><span class="line">                           ch.unsafe().close(ch.unsafe().voidPromise());</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                           NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                           invokeChannelUnregistered(task, key, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">               <span class="comment">// Probably due to concurrent modification of the key set.</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       selector = newSelector;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// time to close the old selector as everything else is registered to the new one</span></span><br><span class="line">           oldSelector.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;Failed to close the old Selector.&quot;</span>, t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">&quot;Migrated &quot;</span> + nChannels + <span class="string">&quot; channel(s) to the new Selector.&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在rebuildSelector() 方法中, 主要做了三件事情:</p>
<ol>
<li>创建一个新的Selector</li>
<li>将原来的Selector中的注册事件全部取消</li>
<li>将可用的事件重新注册到Selector 中, 并激活</li>
</ol>
<h2 id="9-Netty-对Selector-中-KeySet-的优化"><a href="#9-Netty-对Selector-中-KeySet-的优化" class="headerlink" title="9. Netty 对Selector 中 KeySet 的优化"></a>9. Netty 对Selector 中 KeySet 的优化</h2><p>分析完Netty 对JDK 空轮训bug 的解决方案, 接下来我们再来看看一个很有意思的细节, Netty 对Selector 中存储SelectionKey 的HashSet 也做了优化。 在前面的Netty分析中, Netty 对Selector 有重构, 创建一个新的Selector 其实就是调用 openSelector()   方法, 来看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebuildSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!inEventLoop()) &#123;</span><br><span class="line">           execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   rebuildSelector();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line">       <span class="keyword">final</span> Selector newSelector;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (oldSelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           newSelector = openSelector();</span><br><span class="line">        <span class="comment">// 省略其他代码   </span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来进入 openSelector()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Selector selector;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          selector = provider.openSelector();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;failed to open a new selector&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (DISABLE_KEYSET_OPTIMIZATION) &#123;</span><br><span class="line">          <span class="keyword">return</span> selector;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">      Object maybeSelectorImplClass = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> Class.forName(</span><br><span class="line">                          <span class="string">&quot;sun.nio.ch.SelectorImpl&quot;</span>,</span><br><span class="line">                          <span class="keyword">false</span>,</span><br><span class="line">                          PlatformDependent.getSystemClassLoader());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                  <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">                  <span class="keyword">return</span> e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(maybeSelectorImplClass <span class="keyword">instanceof</span> Class) ||</span><br><span class="line">              <span class="comment">// ensure the current selector implementation is what we can instrument.</span></span><br><span class="line">              !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(selector.getClass())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (maybeSelectorImplClass <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">              Exception e = (Exception) maybeSelectorImplClass;</span><br><span class="line">              logger.trace(<span class="string">&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;</span>, selector, e);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> selector;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line"></span><br><span class="line">      Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;selectedKeys&quot;</span>);</span><br><span class="line">                  Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;publicSelectedKeys&quot;</span>);</span><br><span class="line"></span><br><span class="line">                  selectedKeysField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                  publicSelectedKeysField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                  selectedKeysField.set(selector, selectedKeySet);</span><br><span class="line">                  publicSelectedKeysField.set(selector, selectedKeySet);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                  <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                  <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                  <span class="comment">// JDK 9 can throw an inaccessible object exception here; since Netty compiles</span></span><br><span class="line">                  <span class="comment">// against JDK 7 and this exception was only added in JDK 9, we have to weakly</span></span><br><span class="line">                  <span class="comment">// check the type</span></span><br><span class="line">                  <span class="keyword">if</span> (<span class="string">&quot;java.lang.reflect.InaccessibleObjectException&quot;</span>.equals(e.getClass().getName())) &#123;</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">throw</span> e;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (maybeException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">          selectedKeys = <span class="keyword">null</span>;</span><br><span class="line">          Exception e = (Exception) maybeException;</span><br><span class="line">          logger.trace(<span class="string">&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;</span>, selector, e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          selectedKeys = selectedKeySet;</span><br><span class="line">          logger.trace(<span class="string">&quot;instrumented a special java.util.Set into: &#123;&#125;&quot;</span>, selector);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> selector;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的主要功能就是利用反射机制, 获取到JDK底层的 Selector 的 class 对象, 用反射方法从 class 对象中获取两个字段selectedKeys 和publicSelectedKeys, 这两个字段就是用来存储已注册事件的, 然后,将这两个对象 重新复制为Netty 创建的 SelectedSelectionKeySet, 是不是有种偷梁换柱的感觉呢?</p>
<p>我们先来看一下 selectedKeys 和publicSelectedKeys 到底是什么类型? 打开SelectorImpl 的源码, 看其构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="keyword">private</span> Set&lt;SelectionKey&gt; publicKeys;</span><br><span class="line"><span class="keyword">private</span> Set&lt;SelectionKey&gt; publicSelectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(var1);</span><br><span class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">&quot;1.4&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.publicKeys = <span class="keyword">this</span>.keys;</span><br><span class="line">        <span class="keyword">this</span>.publicSelectedKeys = <span class="keyword">this</span>.selectedKeys;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.publicKeys = Collections.unmodifiableSet(<span class="keyword">this</span>.keys);</span><br><span class="line">        <span class="keyword">this</span>.publicSelectedKeys = Util.ungrowableSet(<span class="keyword">this</span>.selectedKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现  selectedKeys 和publicSelectedKeys 就是HashSet, 下面我们再来看一下 Netty 创建 的 SelectedSelectionKeySet 对象的源代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey[] keysA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keysASize;</span><br><span class="line">    <span class="keyword">private</span> SelectionKey[] keysB;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keysBSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isA = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() &#123;</span><br><span class="line">        keysA = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">        keysB = keysA.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = keysASize;</span><br><span class="line">            keysA[size ++] = o;</span><br><span class="line">            keysASize = size;</span><br><span class="line">            <span class="keyword">if</span> (size == keysA.length) &#123;</span><br><span class="line">                doubleCapacityA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> size = keysBSize;</span><br><span class="line">            keysB[size ++] = o;</span><br><span class="line">            keysBSize = size;</span><br><span class="line">            <span class="keyword">if</span> (size == keysB.length) &#123;</span><br><span class="line">                doubleCapacityB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacityA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SelectionKey[] newKeysA = <span class="keyword">new</span> SelectionKey[keysA.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(keysA, <span class="number">0</span>, newKeysA, <span class="number">0</span>, keysASize);</span><br><span class="line">        keysA = newKeysA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacityB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SelectionKey[] newKeysB = <span class="keyword">new</span> SelectionKey[keysB.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(keysB, <span class="number">0</span>, newKeysB, <span class="number">0</span>, keysBSize);</span><br><span class="line">        keysB = newKeysB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SelectionKey[] flip() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">            isA = <span class="keyword">false</span>;</span><br><span class="line">            keysA[keysASize] = <span class="keyword">null</span>;</span><br><span class="line">            keysBSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> keysA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isA = <span class="keyword">true</span>;</span><br><span class="line">            keysB[keysBSize] = <span class="keyword">null</span>;</span><br><span class="line">            keysASize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> keysB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">            <span class="keyword">return</span> keysASize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> keysBSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;SelectionKey&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码篇幅不长, 但很精辟, SelectedSelectionKeySet  同样继承了 AbstractSet, 因此复制给  selectedKeys 和publicSelectedKeys  不存在类型转换异常的问题.  我们看到在 SelectedSelectionKeySet 中禁用了 remove(),contails()方法和iterator() 方法, 只保留了 add()  方法, 而且底层存储结构用的是数组 SelectionKey[] keys.  那么Netty 为什么这样设计呢? 主要目的还是简化我们在轮询事件时的操作, 不需要每次轮询时都要移除key.</p>
<h2 id="10-Handler-的添加过程"><a href="#10-Handler-的添加过程" class="headerlink" title="10 .Handler 的添加过程"></a>10 .Handler 的添加过程</h2><p>服务端handler 的添加过程和客户端的有点区别, 跟 EventLoopGroup 一样服务端的handler 也有两个, 一个是通过 handler() 方法设置的handler, 一个是通过 childHandler()  方法设置的 childHandler() ,通过前面的 bossGroup 和workerGroup 的分析, 其实我们可以大胆的猜测, handler 与 accept 过程有关, 即handler  负责处理客户端新连接接入的请求, 而 childHandler  就是负责和客户端连接的IO交互. 那么实际上是不是这样的呢？ 我们继续用代码来证明? 在前面我们已经了解到ServerBootstrap 中 重写了init()  方法, 在这个方法中也添加了 hanlder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">     <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">         channel.config().setOptions(options);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">     <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">             <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">             AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">             channel.attr(key).set(e.getValue());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">     <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">     <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">     <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">     <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">         currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">         currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">             ChannelHandler handler = config.handler();</span><br><span class="line">             <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 pipeline.addLast(handler);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// We add this handler via the EventLoop as the user may have used a ChannelInitializer as handler.</span></span><br><span class="line">             <span class="comment">// In this case the initChannel(...) method will only be called after this method returns. Because</span></span><br><span class="line">             <span class="comment">// of this we need to ensure we add our handler in a delayed fashion so all the users handler are</span></span><br><span class="line">             <span class="comment">// placed in front of the ServerBootstrapAcceptor.</span></span><br><span class="line">             ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                             currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的initChannel()  方法中,  首先通过 handler()  方法获取一个 handler, 如果获取到的hanlder 不为空, 则添加到 pipeline中, 然后接着, 添加了一个ServerBootstrapAcceptor 的实力。 那么这里的handler() 方法 返回的是哪个对象呢？其实它返回的 handler 字段, 而这个对象就是我们在服务端的启动代码中设置的</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.group(bossGroup, workerGroup)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>那么这个时候, pipeline 中的hanlder 情况如下:</p>
<p><img src="http://files.luyanan.com//img/20190928164210.png"></p>
<p>根据我们原来客户端代码的分析来, 我们指定 chanel  绑定到 eventLoop(在这里是指 NioServerSocketChanel 绑定到bossGroup) 后， 会在pipeline 中触发 fireChannelRegistered 事件 ,接着就会触发 对ChannelInitializer的 initChannel()<br>方法的调用. 因为在绑定完成后， 此时的 pipeline 的内容如下:</p>
<p><img src="http://files.luyanan.com//img/20190928164435.png"></p>
<p>在前面我们分析 bossGroup 和workerGroup 时, 已经知道了 ServerBootstrapAcceptor 的channelRead()  方法会为新建的Channel 设置handler 并注册到一个 eventLoop 中., 即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">           child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</span><br><span class="line">                       logger.warn(<span class="string">&quot;Unknown channel option: &quot;</span> + e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.warn(<span class="string">&quot;Failed to set a channel option: &quot;</span> + child, t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                       <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                           forceClose(child, future.cause());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               forceClose(child, t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>而这里的handler 就是我们在服务端启动代码中设置的handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;)</span><br></pre></td></tr></table></figure>

<p>后续的步骤我们基本上清楚了, 当客户端连接Channel 注册后, 就会触发 ChannelInitializer 的 initChannel()方法的调用, 最后我们来总结一下 服务端handler 和childHandler 的区别和联系</p>
<ol>
<li>在服务端 NioSocketChannel 的 pipeline 中添加的是 hanlder 和 ServerBootstrapAcceptor。</li>
<li>当有新的客户端连接请求时, 调用 用 ServerBootstrapAcceptor 的 channelRead()方法创建此连接的NioSocketChannel 并 添加 childHandler 到NioSocketChannel 对应的pileline 中, 并为此channel 绑定到  workerGroup 中的某个 eventLoop 中.</li>
<li>handler 是在 accept 阶段起作用的, 它处理客户端的连接请求.</li>
<li>childHandler 是在客户端连接建立后起作用, 他负责客户端连接的IO交互.</li>
</ol>
<p>最后来看一张图, 加深理解。 下图描述了服务端从启动初始化到有新连接接入的变化过程:</p>
<p><img src="http://files.luyanan.com//img/20190928165400.png"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/7.%20%E6%8F%AD%E5%BC%80Bootstrap%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/9.%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84EventLoop/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%AD%E5%BC%80ServerBootstrap-%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="nav-number">1.</span> <span class="nav-text">揭开ServerBootstrap 的神秘面纱</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1. 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-NioServerSocketChannel-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.</span> <span class="nav-text">2. NioServerSocketChannel 的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9C%8D%E5%8A%A1%E7%AB%AFChannel-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">3. 服务端Channel 的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ChannelPipeline-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">4. ChannelPipeline 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%9C%8D%E5%8A%A1%E7%AB%AFChannel-%E6%B3%A8%E5%86%8C%E5%88%B0Selector"><span class="nav-number">1.5.</span> <span class="nav-text">5. 服务端Channel 注册到Selector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-bossGroup-%E5%92%8CworkGroup"><span class="nav-number">1.6.</span> <span class="nav-text">6. bossGroup 和workGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%9C%8D%E5%8A%A1%E7%AB%AFSelector-%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.7.</span> <span class="nav-text">7. 服务端Selector 事件轮询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Netty-%E8%A7%A3%E5%86%B3JDK-%E7%A9%BA%E8%BD%AE%E8%AE%ADBug"><span class="nav-number">1.8.</span> <span class="nav-text">8 Netty 解决JDK 空轮训Bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Netty-%E5%AF%B9Selector-%E4%B8%AD-KeySet-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">1.9.</span> <span class="nav-text">9. Netty 对Selector 中 KeySet 的优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-Handler-%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">10 .Handler 的添加过程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">214</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
