<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="5. Spring核心之IOC源码解析再谈IOC与DI&amp;emsp;&amp;emsp;  IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。DI(DependencyInjec">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring IOC的 源码解析(5)">
<meta property="og:url" content="http://luyanan.com/Spring%20IOC%E7%9A%84%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(5)/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="5. Spring核心之IOC源码解析再谈IOC与DI&amp;emsp;&amp;emsp;  IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。DI(DependencyInjec">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com/0d9cf52d-aea4-4d59-a245-f82dc5f97ecf.jpg">
<meta property="og:image" content="http://files.luyanan.com/d28195b9-5ae9-4e38-9500-916325027b59.jpg">
<meta property="og:image" content="http://files.luyanan.com/37d6d18e-5b75-4c14-95d7-3629db9f1789.jpg">
<meta property="og:image" content="http://files.luyanan.com/76a9d526-f056-4512-882a-dccdd7d7f3a7.jpg">
<meta property="og:image" content="http://files.luyanan.com/0f7a099c-f5f4-4ad1-8cf6-058bd39099f5.png">
<meta property="og:image" content="http://files.luyanan.com/2fcddbb4-5ba6-4328-bc73-277078df6d5a.jpg">
<meta property="article:published_time" content="2021-03-12T02:15:06.316Z">
<meta property="article:modified_time" content="2021-03-12T02:15:06.316Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com/0d9cf52d-aea4-4d59-a245-f82dc5f97ecf.jpg">

<link rel="canonical" href="http://luyanan.com/Spring%20IOC%E7%9A%84%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(5)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring IOC的 源码解析(5) | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/Spring%20IOC%E7%9A%84%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring IOC的 源码解析(5)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 10:15:06" itemprop="dateCreated datePublished" datetime="2021-03-12T10:15:06+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="5-Spring核心之IOC源码解析"><a href="#5-Spring核心之IOC源码解析" class="headerlink" title="5. Spring核心之IOC源码解析"></a>5. Spring核心之IOC源码解析</h1><h3 id="再谈IOC与DI"><a href="#再谈IOC与DI" class="headerlink" title="再谈IOC与DI"></a>再谈IOC与DI</h3><p>&emsp;&emsp;  IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创<br>建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让<br>容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。<br>DI(DependencyInjection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就<br>是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。<br>先从我们自己设计这样一个视角来考虑：</p>
<ol>
<li>对象和对象的关系怎么表示？</li>
</ol>
<p>可以用xml，properties文件等语义化配置文件表示。<br>2. 描述对象关系的文件存放在哪里？</p>
<p>可能是classpath，filesystem，或者是URL网络资源，servletContext等。<br>回到正题，有了配置文件，还需要对配置文件解析。</p>
<ol start="3">
<li><p>不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？<br>在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。</p>
</li>
<li><p>如何对不同的配置文件进行解析？<br>需要对不同的配置文件语法，采用不同的解析器。</p>
</li>
</ol>
<h2 id="Spring核心容器类图"><a href="#Spring核心容器类图" class="headerlink" title="Spring核心容器类图"></a>Spring核心容器类图</h2><h3 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h3><p>&emsp;&emsp; Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即 IOC容器为开发者管理对象<br>间的依赖关系提供了很多便利和基础服务，在Spring中有许多的 IOC容器的实现供用户选择和使用，<br>其相互关系如下：</p>
<p><img src="http://files.luyanan.com/0d9cf52d-aea4-4d59-a245-f82dc5f97ecf.jpg" alt="image"></p>
<p>其中BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三<br>个重要的子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。<br>但是从类图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，它实现了所有的接口。</p>
<p>那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有它使用的场合，它<br>主要是为了区分在Spring内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。<br>例如ListableBeanFactory 接口表示这些 Bean是可列表化的，而 HierarchicalBeanFactory 表示的是<br>这些 Bean是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接<br>口定义Bean的自动装配规则。这三个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行<br>为。最基本的IOC 容器接口BeanFactory，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2017 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root interface for accessing a Spring bean container.</span></span><br><span class="line"><span class="comment"> * This is the basic client view of a bean container;</span></span><br><span class="line"><span class="comment"> * further interfaces such as &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * are available for specific purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is implemented by objects that hold a number of bean definitions,</span></span><br><span class="line"><span class="comment"> * each uniquely identified by a String name. Depending on the bean definition,</span></span><br><span class="line"><span class="comment"> * the factory will return either an independent instance of a contained object</span></span><br><span class="line"><span class="comment"> * (the Prototype design pattern), or a single shared instance (a superior</span></span><br><span class="line"><span class="comment"> * alternative to the Singleton design pattern, in which the instance is a</span></span><br><span class="line"><span class="comment"> * singleton in the scope of the factory). Which type of instance will be returned</span></span><br><span class="line"><span class="comment"> * depends on the bean factory configuration: the API is the same. Since Spring</span></span><br><span class="line"><span class="comment"> * 2.0, further scopes are available depending on the concrete application</span></span><br><span class="line"><span class="comment"> * context (e.g. &quot;request&quot; and &quot;session&quot; scopes in a web environment).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The point of this approach is that the BeanFactory is a central registry</span></span><br><span class="line"><span class="comment"> * of application components, and centralizes configuration of application</span></span><br><span class="line"><span class="comment"> * components (no more do individual objects need to read properties files,</span></span><br><span class="line"><span class="comment"> * for example). See chapters 4 and 11 of &quot;Expert One-on-One J2EE Design and</span></span><br><span class="line"><span class="comment"> * Development&quot; for a discussion of the benefits of this approach.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that it is generally better to rely on Dependency Injection</span></span><br><span class="line"><span class="comment"> * (&quot;push&quot; configuration) to configure application objects through setters</span></span><br><span class="line"><span class="comment"> * or constructors, rather than use any form of &quot;pull&quot; configuration like a</span></span><br><span class="line"><span class="comment"> * BeanFactory lookup. Spring&#x27;s Dependency Injection functionality is</span></span><br><span class="line"><span class="comment"> * implemented using this BeanFactory interface and its subinterfaces.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Normally a BeanFactory will load bean definitions stored in a configuration</span></span><br><span class="line"><span class="comment"> * source (such as an XML document), and use the &#123;<span class="doctag">@code</span> org.springframework.beans&#125;</span></span><br><span class="line"><span class="comment"> * package to configure the beans. However, an implementation could simply return</span></span><br><span class="line"><span class="comment"> * Java objects it creates as necessary directly in Java code. There are no</span></span><br><span class="line"><span class="comment"> * constraints on how the definitions could be stored: LDAP, RDBMS, XML,</span></span><br><span class="line"><span class="comment"> * properties file, etc. Implementations are encouraged to support references</span></span><br><span class="line"><span class="comment"> * amongst beans (Dependency Injection).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In contrast to the methods in &#123;<span class="doctag">@link</span> ListableBeanFactory&#125;, all of the</span></span><br><span class="line"><span class="comment"> * operations in this interface will also check parent factories if this is a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HierarchicalBeanFactory&#125;. If a bean is not found in this factory instance,</span></span><br><span class="line"><span class="comment"> * the immediate parent factory will be asked. Beans in this factory instance</span></span><br><span class="line"><span class="comment"> * are supposed to override beans of the same name in any parent factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanNameAware&#x27;s &#123;<span class="doctag">@code</span> setBeanName&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanClassLoaderAware&#x27;s &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanFactoryAware&#x27;s &#123;<span class="doctag">@code</span> setBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EnvironmentAware&#x27;s &#123;<span class="doctag">@code</span> setEnvironment&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EmbeddedValueResolverAware&#x27;s &#123;<span class="doctag">@code</span> setEmbeddedValueResolver&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ResourceLoaderAware&#x27;s &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationEventPublisherAware&#x27;s &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;MessageSourceAware&#x27;s &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationContextAware&#x27;s &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ServletContextAware&#x27;s &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom init-method definition</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;DisposableBean&#x27;s &#123;<span class="doctag">@code</span> destroy&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom destroy-method definition</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 13 April 2001</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware#setBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware#setBeanClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware#setBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ResourceLoaderAware#setResourceLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.MessageSourceAware#setMessageSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware#setApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware#setServletContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean#destroy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">	 * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">	 * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">	<span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">	 * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">	 * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean definition</span></span><br><span class="line"><span class="comment">	 * with the specified name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">	 * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">	 * required type. This means that ClassCastException can&#x27;t be thrown on casting</span></span><br><span class="line"><span class="comment">	 * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match. Can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * of the actual class, or &#123;<span class="doctag">@code</span> null&#125; for any match. For example, if the value</span></span><br><span class="line"><span class="comment">	 * is &#123;<span class="doctag">@code</span> Object.class&#125;, this method will succeed whatever the class of the</span></span><br><span class="line"><span class="comment">	 * returned instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">	 * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">	 * the affected bean isn&#x27;t a prototype</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">	 * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">	 * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">	 * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">	 * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">	 * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">	 * the affected bean isn&#x27;t a prototype</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">	 * instance with the given name?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">	 * canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">	 * be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">	 * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">	 * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">	 * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">	 * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">	 * return the same instance?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">	 * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">	 * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">	 * check for independent instances.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">	 * independent instances?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">	 * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">	 * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">	 * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">	 * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">	 * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; if it doesn&#x27;t match or cannot be determined yet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">	 * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">	 * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; if it doesn&#x27;t match or cannot be determined yet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">	 * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">	 * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">	 * All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">	 * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">	 * being the first element in the array.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。<br>正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</p>
<p>&emsp;&emsp;而要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多IOC 容器<br>的 实 现 。 比 如 GenericApplicationContext ， ClasspathXmlApplicationContext 等 。</p>
<p>&emsp;&emsp;ApplicationContext是Spring 提供的一个高级的IOC 容器，它除了能够提供IOC 容器的基本功能<br>外，还为用户提供了以下的附加服务。从ApplicationContext接口的实现，我们看出其特点：</p>
<ol>
<li>支持信息源，可以实现国际化。（实现MessageSource接口）</li>
<li>访问资源。(实现ResourcePatternResolver接口，后面章节会讲到)</li>
<li>支持应用事件。(实现ApplicationEventPublisher接口)</li>
</ol>
<h3 id="2、BeanDefinition"><a href="#2、BeanDefinition" class="headerlink" title="2、BeanDefinition"></a>2、BeanDefinition</h3><p>&emsp;&emsp; SpringIOC 容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring 实现中是<br>以BeanDefinition来描述的，其继承体系如下：</p>
<p><img src="http://files.luyanan.com/d28195b9-5ae9-4e38-9500-916325027b59.jpg" alt="image"></p>
<h3 id="3、BeanDefinitionReader"><a href="#3、BeanDefinitionReader" class="headerlink" title="3、BeanDefinitionReader"></a>3、BeanDefinitionReader</h3><p>Bean的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵<br>活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过<br>BeanDefintionReader来完成，最后看看Spring中BeanDefintionReader的类结构图：<br><img src="http://files.luyanan.com/37d6d18e-5b75-4c14-95d7-3629db9f1789.jpg" alt="image"></p>
<h3 id="Web-IOC容器初体验"><a href="#Web-IOC容器初体验" class="headerlink" title="Web IOC容器初体验"></a>Web IOC容器初体验</h3><p>&emsp;&emsp;  我们还是从大家最熟悉的DispatcherServlet开始，我们最先想到的还是DispatcherServlet 的init()<br>方法。我们发现在DispatherServlet 中并没有找到init()方法。但是经过探索，往上追索在其父类<br>HttpServletBean中找到了我们想要的init()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Map config parameters onto bean properties of this servlet, and</span></span><br><span class="line"><span class="comment">	 * invoke subclass initialization.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException if bean properties are invalid (or required</span></span><br><span class="line"><span class="comment">	 * properties are missing), or if subclass initialization fails.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Initializing servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//定位资源</span></span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">				<span class="comment">//加载配置信息</span></span><br><span class="line">				ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">				bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">		initServletBean();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27; configured successfully&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在init()方法中，真正完成初始化容器动作的逻辑其实在initServletBean()方法中，我们继续跟进<br>initServletBean()中的代码在FrameworkServlet 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Overridden method of &#123;<span class="doctag">@link</span> HttpServletBean&#125;, invoked after any bean properties</span></span><br><span class="line"><span class="comment">	 * have been set. Creates this servlet&#x27;s WebApplicationContext.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		getServletContext().log(<span class="string">&quot;Initializing Spring FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.info(<span class="string">&quot;FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: initialization started&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">			initFrameworkServlet();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">			<span class="keyword">this</span>.logger.info(<span class="string">&quot;FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: initialization completed in &quot;</span> +</span><br><span class="line">					elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 在上面的代码中终于看到了我们似曾相识的代码initWebAppplicationContext()，继续跟进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize and publish the WebApplicationContext for this servlet.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@link</span> #createWebApplicationContext&#125; for actual creation</span></span><br><span class="line"><span class="comment"> * of the context. Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the WebApplicationContext instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #FrameworkServlet(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextConfigLocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先从ServletContext中获得父容器WebAppliationContext</span></span><br><span class="line">	WebApplicationContext rootContext =</span><br><span class="line">			WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">	<span class="comment">//声明子容器</span></span><br><span class="line">	WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立父、子容器之间的关联关系</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">		wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">		<span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">			<span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">				<span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">				<span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">				<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">					<span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">					cwac.setParent(rootContext);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//这个方法里面调用了AbatractApplication的refresh()方法</span></span><br><span class="line">				<span class="comment">//模板方法，规定IOC初始化基本流程</span></span><br><span class="line">				configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先去ServletContext中查找Web容器的引用是否存在，并创建好默认的空IOC容器</span></span><br><span class="line">	<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">		<span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">		<span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">		<span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">		wac = findWebApplicationContext();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//给上一步创建好的IOC容器赋值</span></span><br><span class="line">	<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">		wac = createWebApplicationContext(rootContext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//触发onRefresh方法</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">		<span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">		<span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">		<span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">		onRefresh(wac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">		<span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">		String attrName = getServletContextAttributeName();</span><br><span class="line">		getServletContext().setAttribute(attrName, wac);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Published WebApplicationContext of servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">					<span class="string">&quot;&#x27; as ServletContext attribute with name [&quot;</span> + attrName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the WebApplicationContext for this servlet, either a default</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.web.context.support.XmlWebApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> #setContextClass custom context class&#125;, if set.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation expects custom contexts to implement the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.web.context.ConfigurableWebApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * interface. Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Do not forget to register this servlet instance as application listener on the</span></span><br><span class="line"><span class="comment"> * created context (for triggering its &#123;<span class="doctag">@link</span> #onRefresh callback&#125;, and to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.ConfigurableApplicationContext#refresh()&#125;</span></span><br><span class="line"><span class="comment"> * before returning the context instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent the parent ApplicationContext to use, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the WebApplicationContext for this servlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.support.XmlWebApplicationContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">				<span class="string">&quot;&#x27; will try to create custom WebApplicationContext context of class &#x27;&quot;</span> +</span><br><span class="line">				contextClass.getName() + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot;, using parent context [&quot;</span> + parent + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">				<span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">				<span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">				<span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ConfigurableWebApplicationContext wac =</span><br><span class="line">			(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">	wac.setEnvironment(getEnvironment());</span><br><span class="line">	wac.setParent(parent);</span><br><span class="line">	String configLocation = getContextConfigLocation();</span><br><span class="line">	<span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">		wac.setConfigLocation(configLocation);</span><br><span class="line">	&#125;</span><br><span class="line">	configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">		<span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">		<span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">			wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Generate default id...</span></span><br><span class="line">			wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">					ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">&#x27;/&#x27;</span> + getServletName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wac.setServletContext(getServletContext());</span><br><span class="line">	wac.setServletConfig(getServletConfig());</span><br><span class="line">	wac.setNamespace(getNamespace());</span><br><span class="line">	wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span></span><br><span class="line">	<span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">	<span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">	ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">	<span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">		((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	postProcessWebApplicationContext(wac);</span><br><span class="line">	applyInitializers(wac);</span><br><span class="line">	wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，在configAndRefreshWebApplicationContext()方法中，调用refresh()方<br>法，这个是真正启动IOC 容器的入口，后面会详细介绍。IOC 容器初始化以后，最后调用了<br>DispatcherServlet的onRefresh()方法，在onRefresh()方法中又是直接调用initStrategies()方法初始<br>化SpringMVC的九大组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//初始化策略</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//多文件上传的组件</span></span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		<span class="comment">//初始化本地语言环境</span></span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		<span class="comment">//初始化模板处理器</span></span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		<span class="comment">//handlerMapping</span></span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">		<span class="comment">//初始化参数适配器</span></span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		<span class="comment">//初始化异常拦截器</span></span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		<span class="comment">//初始化视图预处理器</span></span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		<span class="comment">//初始化视图转换器</span></span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基于Xml的IOC容器的初始化"><a href="#基于Xml的IOC容器的初始化" class="headerlink" title="基于Xml的IOC容器的初始化"></a>基于Xml的IOC容器的初始化</h2><p>&emsp;&emsp; IOC 容器的初始化包括BeanDefinition的Resource定位、加载和注册这三个基本的过程。我们以<br>ApplicationContext 为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为 Web 项目</p>
<p>中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext<br>等，其继承体系如下图所示：</p>
<p><img src="http://files.luyanan.com/76a9d526-f056-4512-882a-dccdd7d7f3a7.jpg" alt="image"></p>
<p>ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于Bean的查找<br>可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring<br>应用提供了一个共享的Bean定义环境。</p>
<h3 id="1、寻找入口"><a href="#1、寻找入口" class="headerlink" title="1、寻找入口"></a>1、寻找入口</h3><p>&emsp;&emsp; 还有一个我们用的比较多的ClassPathXmlApplicationContext，通过main()方法启动:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>先看其构造函数的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new ClassPathXmlApplicationContext, loading the definitions</span></span><br><span class="line"><span class="comment"> * from the given XML file and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configLocation resource location</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if context creation failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实际调用的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new ClassPathXmlApplicationContext with the given parent,</span></span><br><span class="line"><span class="comment"> * loading the definitions from the given XML files.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configLocations array of resource locations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> refresh whether to automatically refresh the context,</span></span><br><span class="line"><span class="comment"> * loading all bean definitions and creating all singletons.</span></span><br><span class="line"><span class="comment"> * Alternatively, call refresh manually after further configuring the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent the parent context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if context creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">super</span>(parent);</span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还 有 像 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext 、<br>XmlWebApplicationContext等都继承自父容器AbstractApplicationContext主要用到了装饰器模式<br>和策略模式，最终都是调用refresh()方法。 </p>
<h3 id="2、获得配置路径"><a href="#2、获得配置路径" class="headerlink" title="2、获得配置路径"></a>2、获得配置路径</h3><p>&emsp;&emsp;  通 过 分 析 ClassPathXmlApplicationContext 的 源 代 码 可 以 知 道 ， 在 创 建<br>ClassPathXmlApplicationContext容器时，构造方法做以下两项重要工作：</p>
<p>首先，调用父类容器的构造方法(super(parent)方法)为容器设置好Bean资源加载器。</p>
<p>然 后 ， 再 调 用 父 类 AbstractRefreshableConfigApplicationContext 的<br>setConfigLocations(configLocations)方法设置Bean配置信息的定位路径。<br>通 过 追 踪 ClassPathXmlApplicationContext 的 继 承 体 系 ， 发 现 其 父 类 的 父 类<br>AbstractApplicationContext中初始化IOC容器所做的主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Name of the MessageSource bean in the factory.</span></span><br><span class="line"><span class="comment">	 * If none is supplied, message resolution is delegated to the parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> MessageSource</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_SOURCE_BEAN_NAME = <span class="string">&quot;messageSource&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Name of the LifecycleProcessor bean in the factory.</span></span><br><span class="line"><span class="comment">	 * If none is supplied, a DefaultLifecycleProcessor is used.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.context.LifecycleProcessor</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIFECYCLE_PROCESSOR_BEAN_NAME = <span class="string">&quot;lifecycleProcessor&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Name of the ApplicationEventMulticaster bean in the factory.</span></span><br><span class="line"><span class="comment">	 * If none is supplied, a default SimpleApplicationEventMulticaster is used.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.context.event.ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = <span class="string">&quot;applicationEventMulticaster&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态初始化块，在整个容器创建过程中只执行一次</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">// Eagerly load the ContextClosedEvent class to avoid weird classloader issues</span></span><br><span class="line">		<span class="comment">// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)</span></span><br><span class="line">		<span class="comment">//为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容</span></span><br><span class="line">		<span class="comment">//器关闭事件(ContextClosedEvent)类</span></span><br><span class="line">		ContextClosedEvent.class.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new AbstractApplicationContext with no parent.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new AbstractApplicationContext with the given parent context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent context</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		setParent(parent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the ResourcePatternResolver to use for resolving location patterns</span></span><br><span class="line"><span class="comment">	 * into Resource instances. Default is a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver&#125;,</span></span><br><span class="line"><span class="comment">	 * supporting Ant-style location patterns.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Can be overridden in subclasses, for extended resolution strategies,</span></span><br><span class="line"><span class="comment">	 * for example in a web environment.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;Do not call this when needing to resolve a location pattern.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">	 * Call the context&#x27;s &#123;<span class="doctag">@code</span> getResources&#125; method instead, which</span></span><br><span class="line"><span class="comment">	 * will delegate to the ResourcePatternResolver.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the ResourcePatternResolver for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//获取一个Spring Source的加载器用于读入Spring Bean定义资源文件</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//AbstractApplicationContext继承DefaultResourceLoader，因此也是一个资源加载器</span></span><br><span class="line">		<span class="comment">//Spring资源加载器，其getResource(String location)方法用于载入资源</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> AbstractApplicationContext 的默认构造方法中有调用 PathMatchingResourcePatternResolver 的<br>构造方法创建Spring资源加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new PathMatchingResourcePatternResolver.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ClassLoader access will happen via the thread context class loader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resourceLoader the ResourceLoader to load root directories and</span></span><br><span class="line"><span class="comment"> * actual resources with</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(resourceLoader, <span class="string">&quot;ResourceLoader must not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//设置Spring的资源加载器</span></span><br><span class="line">	<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在设置容器的资源加载器之后，接下来 ClassPathXmlApplicationContext 执行setConfigLocations()<br>方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean配置信息的<br>定位，该方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the config locations for this application context in init-param style,</span></span><br><span class="line"><span class="comment"> * i.e. with distinct locations separated by commas, semicolons or whitespace.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If not set, the implementation may use a default as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//处理单个资源文件路径为一个字符串的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;</span></span><br><span class="line">	<span class="comment">//即多个资源文件路径之间用” ,; \t\n”分隔，解析成数组形式</span></span><br><span class="line">	setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the config locations for this application context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If not set, the implementation may use a default as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析Bean定义资源文件的路径，处理多个资源文件字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(<span class="meta">@Nullable</span> String... locations)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">			<span class="comment">// resolvePath为同一个类中将字符串解析为路径的方法</span></span><br><span class="line">			<span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean配置信息，<br>也可以使用字符串数组，即下面两种方式都是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;a.xml,b.xml&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>多个资源文件路径之间可以是用” , ; \t\n”等分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a.xml&quot;</span>,<span class="string">&quot;b.xml&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>至此，SpringIOC 容器在初始化时将配置的Bean配置信息定位为Spring封装的Resource。 </p>
<h3 id="3、开始启动"><a href="#3、开始启动" class="headerlink" title="3、开始启动"></a>3、开始启动</h3><p>&emsp;&emsp;   SpringIOC 容器对 Bean配置资源的载入是从 refresh()函数开始的，refresh()是一个模板方法，规定了<br>IOC 容器的启动流程，有些逻辑要交给其子类去实现。它对 Bean 配置资源进行载入<br>ClassPathXmlApplicationContext 通过调用其父类 AbstractApplicationContext 的 refresh()函数启<br>动整个IOC 容器对Bean定义的载入过程，现在我们来详细看看refresh()中的逻辑处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			<span class="comment">//1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			<span class="comment">//2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从</span></span><br><span class="line">			<span class="comment">//子类的refreshBeanFactory()方法启动</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			<span class="comment">//3、为BeanFactory配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				<span class="comment">//4、为容器的某些子类指定特殊的BeanPost事件处理器</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				<span class="comment">//5、调用所有注册的BeanFactoryPostProcessor的Bean</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				<span class="comment">//6、为BeanFactory注册BeanPost事件处理器.</span></span><br><span class="line">				<span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				<span class="comment">//7、初始化信息源，和国际化相关.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				<span class="comment">//8、初始化容器事件传播器.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				<span class="comment">//9、调用子类的某些特殊Bean初始化方法</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				<span class="comment">//10、为事件传播器注册事件监听器.</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				<span class="comment">//11、初始化所有剩余的单例Bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				<span class="comment">//12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				<span class="comment">//13、销毁已创建的Bean</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">				<span class="comment">//14、取消refresh操作，重置容器的同步标识。</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				<span class="comment">//15、重设公共缓存</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>refresh()方法主要为 IOC 容器 Bean 的生命周期管理提供条件，Spring IOC 容器载入 Bean 配置信息<br>从 其 子 类 容 器 的 refreshBeanFactory() 方 法 启 动 ， 所 以 整 个 refresh() 中<br>“ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();”这句以后代码的<br>都是注册容器的信息源和生命周期事件，我们前面说的载入就是从这句代码开始启动。</p>
<p>refresh()方法的主要作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和<br>关闭，以保证在refresh之后使用的是新建立起来的 IOC容器。它类似于对IOC 容器的重启，在新建立<br>好的容器中对容器进行初始化，对Bean配置资源进行载入。 </p>
<h3 id="4、创建容器"><a href="#4、创建容器" class="headerlink" title="4、创建容器"></a>4、创建容器</h3><p>obtainFreshBeanFactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入Bean配置<br>信息的过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory()方法，容器真正调用的是 其子类 AbstractRefreshableApplicationContext 实现的 refreshBeanFactory()方法，方法的源 码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation performs an actual refresh of this context&#x27;s underlying</span></span><br><span class="line"><span class="comment"> * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> * initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建IOC容器</span></span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		<span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		<span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">			<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans并关闭beanFactory，接着<br>创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义。 </p>
<h3 id="5、载入配置路径"><a href="#5、载入配置路径" class="headerlink" title="5、载入配置路径"></a>5、载入配置路径</h3><p>AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调<br>用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext<br>的主要源码如下：</p>
<p>loadBeanDefinitions() 方 法 同 样 是 抽 象 方 法 ， 是 由 其 子 类 实 现 的 ， 也 即 在<br>AbstractXmlApplicationContext中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the bean definitions via an XmlBeanDefinitionReader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//实现父类抽象的载入Bean定义方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">	<span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源</span></span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">	<span class="comment">// resource loading environment.</span></span><br><span class="line">	<span class="comment">//为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的</span></span><br><span class="line">	<span class="comment">//祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器</span></span><br><span class="line">	beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//为Bean读取器设置SAX xml解析器</span></span><br><span class="line">	beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">	<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">	<span class="comment">//当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制</span></span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	<span class="comment">//Bean读取器真正实现加载的方法</span></span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the bean definition reader used for loading the bean</span></span><br><span class="line"><span class="comment"> * definitions of this context. Default implementation is empty.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be overridden in subclasses, e.g. for turning off XML validation</span></span><br><span class="line"><span class="comment"> * or using a different XmlBeanDefinitionParser implementation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reader the bean definition reader used by this context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader#setDocumentReaderClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">	reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the bean definitions with the given XmlBeanDefinitionReader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The lifecycle of the bean factory is handled by the &#123;<span class="doctag">@link</span> #refreshBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * method; hence this method is just supposed to load and/or register bean definitions.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reader the XmlBeanDefinitionReader to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of bean registration errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the required XML document isn&#x27;t found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConfigLocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getResourcePatternResolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Xml Bean读取器加载Bean定义资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">//获取Bean定义资源的定位</span></span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line">		<span class="comment">//的Bean定义资源</span></span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源</span></span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line">		<span class="comment">//的Bean定义资源</span></span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of Resource objects, referring to the XML bean definition</span></span><br><span class="line"><span class="comment"> * files that this context should be built with.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation returns &#123;<span class="doctag">@code</span> null&#125;. Subclasses can override</span></span><br><span class="line"><span class="comment"> * this to provide pre-built Resource objects rather than location Strings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an array of Resource objects, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConfigLocations()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法</span></span><br><span class="line"><span class="comment">//该方法在ClassPathXmlApplicationContext中进行实现，对于我们</span></span><br><span class="line"><span class="comment">//举例分析源码的FileSystemXmlApplicationContext没有使用该方法</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] getConfigResources() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 XmlBean 读取器的其中一种策略 XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader调<br>用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions()方法读取Bean配置资源。<br>由于我们使用ClassPathXmlApplicationContext 作为例子分析，因此getConfigResources 的返回值<br>为null，因此程序执行reader.loadBeanDefinitions(configLocations)分支。 </p>
<h3 id="6、分配路径处理策略"><a href="#6、分配路径处理策略" class="headerlink" title="6、分配路径处理策略"></a>6、分配路径处理策略</h3><p>在XmlBeanDefinitionReader的抽象父类AbstractBeanDefinitionReader中定义了载入过程。</p>
<p>AbstractBeanDefinitionReader的loadBeanDefinitions()方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified resource location.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The location can also be a location pattern, provided that the</span></span><br><span class="line"><span class="comment"> * ResourceLoader of this bean definition reader is a ResourcePatternResolver.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> location the resource location, to be loaded with the ResourceLoader</span></span><br><span class="line"><span class="comment"> * (or ResourcePatternResolver) of this bean definition reader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> actualResources a Set to be filled with the actual Resource objects</span></span><br><span class="line"><span class="comment"> * that have been resolved during the loading process. May be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * to indicate that the caller is not interested in those Resource objects.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getResourceLoader()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions(org.springframework.core.io.Resource)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions(org.springframework.core.io.Resource[])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//获取在IoC容器初始化过程中设置的资源加载器</span></span><br><span class="line">	ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">	<span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">&quot;Cannot import bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">		<span class="comment">// Resource pattern matching available.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源</span></span><br><span class="line">			<span class="comment">//加载多个指定位置的Bean定义资源文件</span></span><br><span class="line">			Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			<span class="comment">//委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能</span></span><br><span class="line">			<span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">			<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">					actualResources.add(resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">		<span class="comment">//将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源</span></span><br><span class="line">		<span class="comment">//加载单个指定位置的Bean定义资源文件</span></span><br><span class="line">		Resource resource = resourceLoader.getResource(location);</span><br><span class="line">		<span class="comment">//委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能</span></span><br><span class="line">		<span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">		<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">			actualResources.add(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> loadCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载方法，调用loadBeanDefinitions(String);</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(location);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp; AbstractRefreshableConfigApplicationContext 的 loadBeanDefinitions(Resource…resources)方<br>法实际上是调用AbstractBeanDefinitionReader的loadBeanDefinitions()方法。<br>从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码分析可以看出该方法就做了<br>两件事：</p>
<p>首先，调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。</p>
<p>其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions()方法。在<br>loadBeanDefinitions()方法中调用了 AbstractApplicationContext的 getResources()方法，跟进去之<br>后发现 getResources()方法其实定义在 ResourcePatternResolver 中，此时，我们有必要来看一下<br>ResourcePatternResolver的全类图：</p>
<p><img src="http://files.luyanan.com/0f7a099c-f5f4-4ad1-8cf6-058bd39099f5.png" alt="image"></p>
<p>从上面可以看到 ResourceLoader 与 ApplicationContext 的继承关系，可以看出其实际调用的是<br>DefaultResourceLoader 中 的 getSource() 方 法 定 位 Resource ， 因 为<br>ClassPathXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了<br>ClassPathXmlApplicationContext中来。</p>
<h3 id="7、解析配置文件路径"><a href="#7、解析配置文件路径" class="headerlink" title="7、解析配置文件路径"></a>7、解析配置文件路径</h3><p>XmlBeanDefinitionReader 通 过 调 用 ClassPathXmlApplicationContext 的 父 类<br>DefaultResourceLoader的getResource()方法获取要加载的资源，其源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Resource的具体实现方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">			Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> resource;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象</span></span><br><span class="line">		<span class="keyword">if</span> (location.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">				<span class="comment">// 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象</span></span><br><span class="line">				URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">				<span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">				<span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">				<span class="comment">//如果既不是classpath标识，又不是URL标识的Resource定位，则调用</span></span><br><span class="line">				<span class="comment">//容器本身的getResourceByPath方法获取Resource</span></span><br><span class="line">				<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> DefaultResourceLoader 提供了 getResourceByPath()方法的实现，就是为了处理既不是 classpath<br>标识，又不是URL标识的Resource定位这种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a Resource handle for the resource at the given path.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation supports class path locations. This should</span></span><br><span class="line"><span class="comment"> * be appropriate for standalone implementations but can be overridden,</span></span><br><span class="line"><span class="comment"> * e.g. for implementations targeted at a Servlet container.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path the path to the resource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the corresponding Resource handle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ClassPathResource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.support.FileSystemXmlApplicationContext#getResourceByPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ClassPathContextResource(path, getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在 ClassPathResource中完成了对整个路径的解析。这样，就可以从类路径上对 IOC 配置文件进行加<br>载，当然我们可以按照这个逻辑从任何地方加载，在 Spring中我们看到它提供的各种资源抽象，比如<br>ClassPathResource、URLResource、FileSystemResource等来供我们使用。上面我们看到的是定位</p>
<p>Resource 的一个过程，而这只是加载过程的一部分。例如 FileSystemXmlApplication 容器就重写了<br>getResourceByPath()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">		path = path.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FileSystemContextResource(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过子类的覆盖，巧妙地完成了将类路径变为文件路径的转换。</p>
<h3 id="8、开始读取配置内容"><a href="#8、开始读取配置内容" class="headerlink" title="8、开始读取配置内容"></a>8、开始读取配置内容</h3><p>继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文件<br>的资源定义以后的载入过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//XmlBeanDefinitionReader加载资源的入口方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//将读入的XML资源进行特殊编码处理</span></span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment"> * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这里是载入XML形式Bean定义资源文件方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">		currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将资源文件转为InputStream的IO流</span></span><br><span class="line">		InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//从InputStream中得到XML的解析源</span></span><br><span class="line">			InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//这里是具体的读取过程</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//关闭从Resource中得到的IO流</span></span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//从特定XML文件中实际载入Bean定义资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将XML文件转换为DOM对象，解析过程由documentLoader实现</span></span><br><span class="line">		Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">//这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则</span></span><br><span class="line">		<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 通过源码分析，载入 Bean配置信息的最后一步是将Bean配置信息转换为Document对象，该过程由<br>documentLoader()方法实现。 </p>
<h3 id="9、准备文档对象"><a href="#9、准备文档对象" class="headerlink" title="9、准备文档对象"></a>9、准备文档对象</h3><p>DocumentLoader将Bean配置资源转换成Document对象的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Load the &#123;<span class="doctag">@link</span> Document&#125; at the supplied &#123;<span class="doctag">@link</span> InputSource&#125; using the standard JAXP-configured</span></span><br><span class="line"><span class="comment">	 * XML parser.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//使用标准的JAXP将载入的Bean定义资源转换成document对象</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">			ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建文件解析器工厂</span></span><br><span class="line">		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建文档解析器</span></span><br><span class="line">		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">		<span class="comment">//解析Spring的Bean定义资源</span></span><br><span class="line">		<span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create the &#123;<span class="doctag">@link</span> DocumentBuilderFactory&#125; instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> validationMode the type of validation: &#123;<span class="doctag">@link</span> XmlValidationModeDetector#VALIDATION_DTD DTD&#125;</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@link</span> XmlValidationModeDetector#VALIDATION_XSD XSD&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> namespaceAware whether the returned factory is to provide support for XML namespaces</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the JAXP DocumentBuilderFactory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ParserConfigurationException if we failed to build a proper DocumentBuilderFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建文档解析工厂</span></span><br><span class="line">		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">		factory.setNamespaceAware(namespaceAware);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置解析XML的校验</span></span><br><span class="line">		<span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">			factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">				<span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">				factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">					ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(</span><br><span class="line">							<span class="string">&quot;Unable to validate using XSD: Your JAXP provider [&quot;</span> + factory +</span><br><span class="line">							<span class="string">&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot;</span> +</span><br><span class="line">							<span class="string">&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;</span>);</span><br><span class="line">					pcex.initCause(ex);</span><br><span class="line">					<span class="keyword">throw</span> pcex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 上面的解析过程是调用 JavaEE 标准的 JAXP 标准进行处理。至此 SpringIOC 容器根据定位的 Bean 配 置信息，将其加载读入并转换成为 Document 对象过程完成。接下来我们要继续分析 Spring IOC 容器 将载入的 Bean 配置信息转换为 Document 对象之后，是如何将其解析为 SpringIOC 管理的 Bean 对象 并将其注册到容器中的。</p>
<h3 id="10、分配解析策略"><a href="#10、分配解析策略" class="headerlink" title="10、分配解析策略"></a>10、分配解析策略</h3><p> XmlBeanDefinitionReader 类中的 doLoadBeanDefinition()方法是从特定 XML 文件中实际载入 Bean 配置资源的方法，该方法在载入 Bean 配置资源之后将其转换为 Document 对象，接下来调用 registerBeanDefinitions() 启 动 Spring IOC 容 器 对 Bean 定 义 的 解 析 过 程 ， registerBeanDefinitions()方法源码如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析</span></span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">//获得容器中注册的Bean数量</span></span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,</span></span><br><span class="line">	<span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">//统计解析的Bean数量</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>} Bean配置资源的载入解析分为以下两个过程：<br>首先，通过调用 XML解析器将 Bean 配置信息转换得到 Document对象，但是这些 Document对象<br>并没有按照Spring的Bean规则进行解析。这一步是载入的过程<br>其次，在完成通用的 XML解析之后，按照 Spring Bean 的定义规则对 Document 对象进行解析，其<br>解 析 过 程 是 在 接 口 BeanDefinitionDocumentReader 的 实 现 类<br>DefaultBeanDefinitionDocumentReader中实现。</p>
<h3 id="11、将配置载入内存"><a href="#11、将配置载入内存" class="headerlink" title="11、将配置载入内存"></a>11、将配置载入内存</h3><p>BeanDefinitionDocumentReader 接 口 通 过 registerBeanDefinitions() 方 法 调 用 其 实 现 类<br>DefaultBeanDefinitionDocumentReader对Document对象进行解析，解析的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获得XML描述符</span></span><br><span class="line">	<span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">	logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">	<span class="comment">//获得Document的根元素</span></span><br><span class="line">	Element root = doc.getDocumentElement();</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，</span></span><br><span class="line">	<span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素</span></span><br><span class="line">	BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">	<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">							<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span></span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	<span class="comment">//从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line">	parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">	<span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span></span><br><span class="line">	postProcessXml(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建BeanDefinitionParserDelegate，用于完成真正的解析过程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">	<span class="comment">//BeanDefinitionParserDelegate初始化Document根元素</span></span><br><span class="line">	delegate.initDefaults(root, parentDelegate);</span><br><span class="line">	<span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间</span></span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		<span class="comment">//获取Bean定义的Document对象根元素的所有子节点</span></span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			<span class="comment">//获得Document节点是XML元素节点</span></span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				<span class="comment">//Bean定义的Document的元素节点使用的是Spring默认的XML命名空间</span></span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					<span class="comment">//使用Spring的Bean规则解析元素节点</span></span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点</span></span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="li