<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Dubbo 服务发布源码分析Dubbo 对于Spring 的扩展最早我们使用spring 的配置来实现dubbo 服务的发布, 方便大家的同时也意味着Dubbo 里面和Spring 肯定有那种说不清的关系.  Spring 的标签扩展在Spring中定义了两个接口,">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo之服务发现发布源码分析">
<meta property="og:url" content="http://luyanan.com/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8F%91%E5%B8%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="Dubbo 服务发布源码分析Dubbo 对于Spring 的扩展最早我们使用spring 的配置来实现dubbo 服务的发布, 方便大家的同时也意味着Dubbo 里面和Spring 肯定有那种说不清的关系.  Spring 的标签扩展在Spring中定义了两个接口,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20191127134642.png">
<meta property="og:image" content="http://files.luyanan.com//img/20191127142152.png">
<meta property="article:published_time" content="2021-03-02T05:42:51.776Z">
<meta property="article:modified_time" content="2021-03-02T05:42:51.776Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Python, Rust, C++, Go, 爬虫, 深度学习, 服务研发, 对象存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20191127134642.png">

<link rel="canonical" href="http://luyanan.com/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8F%91%E5%B8%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dubbo之服务发现发布源码分析 | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8F%91%E5%B8%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dubbo之服务发现发布源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-02 13:42:51" itemprop="dateCreated datePublished" datetime="2021-03-02T13:42:51+08:00">2021-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Dubbo-服务发布源码分析"><a href="#Dubbo-服务发布源码分析" class="headerlink" title="Dubbo 服务发布源码分析"></a>Dubbo 服务发布源码分析</h1><h2 id="Dubbo-对于Spring-的扩展"><a href="#Dubbo-对于Spring-的扩展" class="headerlink" title="Dubbo 对于Spring 的扩展"></a>Dubbo 对于Spring 的扩展</h2><p>最早我们使用spring 的配置来实现dubbo 服务的发布, 方便大家的同时也意味着Dubbo 里面和Spring 肯定有那种说不清的关系. </p>
<h3 id="Spring-的标签扩展"><a href="#Spring-的标签扩展" class="headerlink" title="Spring 的标签扩展"></a>Spring 的标签扩展</h3><p>在Spring中定义了两个接口, </p>
<ul>
<li> NamespaceHandler : 注册一堆 BeanDefinitionParser，利用他们来进行解析 </li>
<li> BeanDefinitionParser : 用于解析每个element 的内容</li>
</ul>
<p>Spring 默认会加载jar 包下的<code>META-INF/spring.handlers</code> 文件寻找对应的 NamespaceHandler。  Dubbo-config 模块下的dubbo-config-spring</p>
<p><img src="http://files.luyanan.com//img/20191127134642.png"></p>
<h3 id="Dubbo的接入实现"><a href="#Dubbo的接入实现" class="headerlink" title="Dubbo的接入实现"></a>Dubbo的接入实现</h3><p>Dubbo 中Spring 的扩展就是使用Spring的自定义类型, 所以同样有 NamespaceHandler、BeanDefinitionParser . 而 NamespaceHandler  是 DubboNamespaceHandler . </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;application&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;module&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;registry&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;config-center&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConfigCenterBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;metadata-report&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MetadataReportConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;monitor&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;metrics&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MetricsConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;provider&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;consumer&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;protocol&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;annotation&quot;</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> BeanDefinitionParser  全部都使用了  DubboBeanDefinitionParser , 如果我们想看 <code>dubbo:service</code>的配置, 就直接看  <code>DubboBeanDefinitionParser(ServiceBean.class, true)</code></p>
<p>这里面主要做了一件事情, 把不同的配置分别转换为Spring 容器中的Bean 对象. </p>
<ul>
<li> application  对应 ApplicationConfig </li>
<li> registry 对应 RegistryConfig </li>
<li> monitor 对应 MonitorConfig </li>
<li> provider 对应 ProviderConfig </li>
<li> consumer 对应 ConsumerConfig </li>
</ul>
<p>我们仔细看, 发现涉及到服务发布和服务调用的解析, 使用的是  ServiceBean 和 referenceBean . 并不是config 结尾的, 这两个类稍微特殊些, 当然它同时也继承了  ServiceConfig 和 ReferenceConfig . </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure>

<h3 id="DubboBeanDefinitionParser"><a href="#DubboBeanDefinitionParser" class="headerlink" title="DubboBeanDefinitionParser"></a>DubboBeanDefinitionParser</h3><p>这里面是实现具体配置文件解析的入口, 它重写了parse方法, 对Spring 的配置进行解析. 我们关注一下ServiceBean的解析, 实际就是解析<code>dubbo:service</code> 这个标签中对应的属性. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class="line">            String className = element.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (className != <span class="keyword">null</span> &amp;&amp; className.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                RootBeanDefinition classDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">                classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">                classDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">                parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;ref&quot;</span>, <span class="keyword">new</span> BeanDefinitionHolder(classDefinition, id + <span class="string">&quot;Impl&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ServiceBean-的实现"><a href="#ServiceBean-的实现" class="headerlink" title="ServiceBean 的实现"></a>ServiceBean 的实现</h3><p>ServiceBean 这个类, 分别实现了InitializingBean, DisposableBean,        ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware,        ApplicationEventPublisherAware.</p>
<h4 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h4><p>接口为bean 提供了初始化方法的方式, 它只包括 <code>afterPropertiesSet</code>方法, 凡是继承该接口的类, 在初始化bean 的时候会执行该方法, 被重写的方法为  <code>afterPropertiesSet</code></p>
<h4 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h4><p>被重写的方法为 destroy ， bean 被销毁的时候, sring容器会自动执行 <code>destroy</code> 方法, 比如释放资源. </p>
<h4 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h4><p>实现了这个接口的Bean，当Spring 的容器初始化的时候, 会自动将  ApplicationContext 注入进来. </p>
<h4 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h4><p> ApplicationEvent  事件监听, Spring 容器启动会会发一个事件通知,  被重写的方法为 <code>onApplicationEvent</code>, <code>onApplicationEvent</code> 方法传入的对象是 ContextRefreshedEvent , 这个对象是Spring 的上下文被刷新或者加载完毕后触发的. 因此服务就是在Spring 的上下文刷新后进行导出操作的. </p>
<h4 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h4><p>获取自身初始化时, 本身的bean 的id属性,被重写的方法为 <code>setBeanName</code></p>
<h4 id="ApplicationEventPublisherAware"><a href="#ApplicationEventPublisherAware" class="headerlink" title="ApplicationEventPublisherAware"></a>ApplicationEventPublisherAware</h4><p>这是一个异步事件发送器, 被重写的方法为 <code>setApplicationEventPublisher</code>, 简单来说, 在spring中提供了类似于消息队列的异步事件解耦功能. (典型的观察者模式. )</p>
<h4 id="Spring-事件发送监听由3个部分组成"><a href="#Spring-事件发送监听由3个部分组成" class="headerlink" title="Spring 事件发送监听由3个部分组成."></a>Spring 事件发送监听由3个部分组成.</h4><ol>
<li> .ApplicationEvent :表示事件本身, 自定义事件需要继承该类. </li>
<li> ApplicationEventPublisherAware :  事件发送器, 需要实现该接口。 </li>
<li> ApplicationListener : 事件监听器接口. </li>
</ol>
<p><img src="http://files.luyanan.com//img/20191127142152.png"></p>
<h3 id="ServiceBean-中服务暴露服务"><a href="#ServiceBean-中服务暴露服务" class="headerlink" title="ServiceBean 中服务暴露服务."></a>ServiceBean 中服务暴露服务.</h3><p>在ServiceBean中,我们暂且只需要关注 两个方法, 分别是</p>
<ul>
<li>在初始化bean的时候会执行该方法  afterPropertiesSet </li>
<li>spring 容器启动后悔发送一个事件通知  onApplicationEvent </li>
</ul>
<h4 id="afterPropertiesSet"><a href="#afterPropertiesSet" class="headerlink" title="afterPropertiesSet"></a>afterPropertiesSet</h4><p>我们发现这个方法里面, 就是把dubbo中配置的 application、registry、service、protocol  等信息加载到对应的config 实体类中, 便于后续的使用. </p>
<h4 id="onApplicationEvent"><a href="#onApplicationEvent" class="headerlink" title="onApplicationEvent"></a>onApplicationEvent</h4><p>spring 容器启动后, 会受到这样一个事件通知, 这里面做了两件事情. </p>
<ul>
<li>判断服务是否已经发布过. </li>
<li>如果没有发布, 则调用export 接口进行服务发布的流程(这里就是入口)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 入口</span></span><br><span class="line">           export();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p> serviceBean  中重写了export.方法. 实现了一个事件的发布, 并且调用了<code>super.export()</code> , 也就是调用父类的 <code>export</code>  方法. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.export();</span><br><span class="line">       <span class="comment">// Publish ServiceBeanExportedEvent</span></span><br><span class="line">       publishExportEvent();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ServiceConfig-配置类"><a href="#ServiceConfig-配置类" class="headerlink" title="ServiceConfig  配置类"></a>ServiceConfig  配置类</h3><p>先整体来看一下这个类的作用,从名字来看, 它应该和其他所有的config 类一样去实现对配置文件中的service 的配置信息的存储. 实际上, 这个类并不单纯, 所有的配置它都放在一个 AbstractServiceConfig  的抽象类,自己实现了对于服务发布之前要做的操作逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 检查并且更新配置信息</span></span><br><span class="line">      checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前的服务是否需要发布, 通过配置实现 :@Service(export = false)</span></span><br><span class="line">      <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查是否需要延时发布, 通过配置 @Service(delay=1000)实现, 单位是毫秒</span></span><br><span class="line">      <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">          delayExportExecutor.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果没有配置delay , 则直接调用doExport 进行发布</span></span><br><span class="line">          doExport();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doExport"><a href="#doExport" class="headerlink" title="doExport"></a>doExport</h4><p>这里仍然是在实现发布前的各种判断, 比如刷新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; has already unexported!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 服务是否已经发布过</span></span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 设置发布的状态</span></span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// path 表示服务路径,默认使用interfaceName</span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(path)) &#123;</span><br><span class="line">           path = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line">       doExportUrls();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doExportUrls"><a href="#doExportUrls" class="headerlink" title="doExportUrls"></a>doExportUrls</h4><ol>
<li>记载所有配置的注册中心地址</li>
<li>遍历所有配置的协议. protocol</li>
<li>针对每种协议发布一个对应协议的服务. </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 加载所有配置的注册中心地址, 组装成一个url</span></span><br><span class="line">      <span class="comment">// //(registry://ip:port/org.apache.dubbo.registry.RegistryService 的东西)</span></span><br><span class="line">      List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">          <span class="comment">// group和version 组成一个pathkey(serviceName)</span></span><br><span class="line">          String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), group, version);</span><br><span class="line">          <span class="comment">//ApplicationModel 用来存储 ProviderModel, 发布的服务的元数据, 后续会用到</span></span><br><span class="line">          ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(pathKey, ref, interfaceClass);</span><br><span class="line">          ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class="line">          doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="doExportUrlsFor1Protocol"><a href="#doExportUrlsFor1Protocol" class="headerlink" title="doExportUrlsFor1Protocol"></a>doExportUrlsFor1Protocol</h4><p>发布指定协议的服务, 我们以Dubbo 为例, 由于代码太多, 就不全部贴出来 . </p>
<ol>
<li>前面的一大串if else 代码, 是为了把当前服务下配置的<a href="dubbo:method">dubbo:method</a> 参数进行解析, 保存到map 集合中. </li>
<li>获取当前服务需要暴露的ip和端口号</li>
<li>把解析到的所有数据, 组装成一个URL,大概是  <code>dubbo://192.168.9.110:20880/com.example.ISayHelloService</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">          <span class="comment">// 以上都是解析&lt;dubbo:method&gt;和&lt;dubbo:service&gt; 中配置参数的代码,</span></span><br><span class="line">       <span class="comment">// export service</span></span><br><span class="line">       <span class="comment">// 获取当前服务发布的目标id和port</span></span><br><span class="line">       String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">       Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">       <span class="comment">// 组装URL</span></span><br><span class="line">       URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这里是通过ConfiguratorFactory 去实现动态改变配置的功能,</span></span><br><span class="line">       <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">               .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">           url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                   .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果scope ！=null, 则发布服务, 默认 scope 为null, 如果scope 不为none, 判断是否为local或者remote, 从而发布</span></span><br><span class="line">       <span class="comment">// local 或者remote服务, 默认两个都会发布 .</span></span><br><span class="line">       String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">       <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">       <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">           <span class="comment">// injvm 发布到本地</span></span><br><span class="line">           <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">               exportLocal(url);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">           <span class="comment">// 发布远程服务</span></span><br><span class="line">           <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!isOnlyInJvm() &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                       <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                       <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                       URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                       <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                           logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                       String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                       <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                           registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                       DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                       Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                       exporters.add(exporter);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                   DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                   Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                   exporters.add(exporter);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">                * ServiceData Store</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   metadataReportService.publishProvider(url);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h4><p>服务只是injvm 的服务, 提供一种消费者和提供者都在一个jvm 内的调用方式. 使用injvm 协议, 只是一个伪协议, 它不开启端口,不发起远程调用, 只是JVM内部直接关联(通过集合的方法保存了发布的服务信息),但执行Dubbo的Filter 链. 简单来说, 就是你本地的dubbo服务调用, 都依托于dubbo 的标准来进行, 这样可以享受到dubbo 的一些配置服务. </p>
<h4 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h4><p>表示根据配置的注册中心进行远程发布, 遍历多个注册中心, 进行协议的发布. </p>
<ol>
<li>incoker 是一个代理类, 它是dubbo 的核心模型, 其他模型都是向它靠拢, 或转换成它. 它代表一个可执行体, 可向它发起invoke 调用, 他有可能是一个本地的实现, 也有可能是一个远程的实现, 也有可能是一个集群实现. </li>
<li><code> DelegateProviderMetaDataInvoker</code>, 因为2.7 引入了元数据, 所以这里对invoker 进行了委托, 把invoker 交给了 DelegateProviderMetaDataInvoker  来处理 </li>
<li>调用 protocol.export(invoker) 来发布这个代理. </li>
<li>添加到  exporters  集合中. </li>
</ol>
</blockquote>
<h4 id="protocol-export"><a href="#protocol-export" class="headerlink" title="protocol.export"></a>protocol.export</h4><p><code> protocol.export</code> 这个protocol 是什么呢? 找到定义出发现它是一个自适应扩展点, 打开Protocol 这个扩展点, 又可以看到他是一个在方法层面上的自适应扩展， 意味着它实现了对于export 这个方法的适配, 也就意味着Protocol 是一个动态代理类,  <code>Protocol$Adaptive</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<p>这个动态代理类, 会根据url 中配置的 protocol name 来实现对应协议的适配. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy()of interface org.apache.dubbo.rpc.Protocol is not adaptive method !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort()of interface org.apache.dubbo.rpc.Protocol is not adaptive method !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.</span></span><br><span class="line"><span class="function">            RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">                org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys ([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys ([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么在当前的场景中, protocol 会调用谁呢?  目前发布的invoker(URL), 实际上是一个 registry://协议, 所以 Protocol$Adaptive，会通过 getExtension(extName)得到一个 RegistryProtocol </p>
<h4 id="RegistryProtocol-export"><a href="#RegistryProtocol-export" class="headerlink" title="RegistryProtocol.export"></a>RegistryProtocol.export</h4><p>很明显, 这个RegistryProtocol 是用来实现服务注册的, 则里面会有很多处理逻辑. </p>
<ol>
<li>实现对应协议的服务发布</li>
<li>实现服务注册</li>
<li>订阅服务重写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">      <span class="comment">// 这里获取的是zookeeper 注册中心的url zookeeper://ip:port</span></span><br><span class="line">      URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">      <span class="comment">// url to export locally</span></span><br><span class="line">      <span class="comment">//  这里是获得服务提供者的url   dubbo://ip:port</span></span><br><span class="line">      URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Subscribe the override data</span></span><br><span class="line">      <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">      <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">      <span class="comment">//  subscription information to cover.</span></span><br><span class="line">      <span class="comment">// 订阅 override数据, 在admin 控制台可以针对服务进行治理, 比如修改权重、修改路由机制等, 当有注册中心由此服务的覆盖配置注册进行的时候,</span></span><br><span class="line">      <span class="comment">// 推送消息给提供者, 重新暴露服务.</span></span><br><span class="line">      <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">      <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">      overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">      providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">      <span class="comment">//export invoker</span></span><br><span class="line">      <span class="comment">// 这里交给具体的协议去暴露服务</span></span><br><span class="line">      <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// url to registry</span></span><br><span class="line">      <span class="comment">// 根据invoker 中的url 获取registry实例 , zookeeperRegistry</span></span><br><span class="line">      <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">      <span class="comment">// 获取要注册到注册中心的url : dubbo://ip:port</span></span><br><span class="line">      <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">      ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">              registryUrl, registeredProviderUrl);</span><br><span class="line">      <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">      <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 是否配置了注册中心, 如果是,则需要配置</span></span><br><span class="line">      <span class="keyword">if</span> (register) &#123;</span><br><span class="line">          <span class="comment">// 注册到注册中心的URL</span></span><br><span class="line">          register(registryUrl, registeredProviderUrl);</span><br><span class="line">          providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册中心的订阅</span></span><br><span class="line">      <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">      registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">      exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">      exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">      <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">      <span class="comment">// 保存每次export 都返回一个新的exporter 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="doLocalExport"><a href="#doLocalExport" class="headerlink" title="doLocalExport"></a>doLocalExport</h4><p>先通过doLocalExport 来暴露一个服务, 本质上应该是启动一个通信服务, 主要的步骤是将本地ip和20880 端口打开, 进行监听。 </p>
<p> originInvoker : 应该是 registry://ip:port/com.alibaba.dubbo.registry.RegistryService  </p>
<p>key:  从 originInvoker 中获得发布协议的 url: dubbo://ip:port/… </p>
<p> bounds: 一个 prviderUrl 服务 export 之后，缓存到 bounds 中，所以一个 providerUrl 只会对应一个 exporter  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;</span><br><span class="line">     String key = getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;</span><br><span class="line">         <span class="comment">// 对原有的 invoker 委托给了invokerDelegate</span></span><br><span class="line">         Invoker&lt;?&gt; invokerDelegate = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(originInvoker, providerUrl);</span><br><span class="line">         <span class="comment">// 将invoke 转换成了exporter 并且启动netty 服务</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> InvokerDelegete : 是  RegistryProtocol 的一个静态内部类, 该类是一个 originInvoker  的委托类, 该类存储了 originInvoker ,其父类  InvokerWrapper  还会存储 providerUrl，InvokerWrapper 会调用  originInvoker  的invoke方法, 也会销毁invoke. 可以管理invoke的生命周期. </p>
<h4 id="DubboProtocol-export"><a href="#DubboProtocol-export" class="headerlink" title="DubboProtocol.export"></a>DubboProtocol.export</h4><p>基于动态代理的适配, 很自然的就过渡到了 DubboProtocol 这个协议类, 但是实际上是 DubboProtocol 吗? </p>
<p>这里并不是获取一个单纯的 DubboProtocol  扩展点, 而是会通过Wrapper 对Protocol 进行装饰, 装饰器分别为  QosProtocolWrapper/ProtocolListenerWrapper/ProtocolFilterWrapper/DubboProtocol . </p>
<p>为什么是这样呢? 我们再来看看SPI的代码</p>
<h5 id="Wrapper-包装"><a href="#Wrapper-包装" class="headerlink" title="Wrapper 包装"></a>Wrapper 包装</h5><p>在 <code>ExtensionLoader.loadClass</code>   这个方法中, 有一段这样的判断, 如果当前这个类是一个Wrapper 包装类, 也及时这个wrapper 中有构造方法, 参数是当前被加载的扩展点的类型, 则把这个wrapper 类加入到  cacheWrapperClass  缓存中., </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">           cacheWrapperClass(clazz);</span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheWrapperClass</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cachedWrapperClasses == <span class="keyword">null</span>) &#123;</span><br><span class="line">           cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       cachedWrapperClasses.add(clazz);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以在dubbo 的配置文件中找到三个wrapper</p>
<ol>
<li> QosprotocolWrapper，  如果当前配置了注册中心, 则会启动一个QosServer, qos 是dubbo 的在线运维命令, dubbo2.5.8 版本重构了telnet模块, 提供了新的telnet 命令支持, 新版本的telnet 端口与dubbo 协议的端口是不同的端口, 默认的为22222</li>
<li> ProtocolFilterWrapper  对invoker 进行filter 包装, 实现请求的过滤. </li>
<li> ProtocolListenerWrapper 用于服务export 时候插入监听机制. </li>
</ol>
<blockquote>
<p> qos=org.apache.dubbo.qos.protocol.QosProtocolWrapper filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper </p>
</blockquote>
<p>接着, 在 <code>getExtension-&gt;createExtension</code> 方法中, 会对  cacheWrapperClass  集合进行判断, 如果集合不为空, 则进行包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                   instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



<h4 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h4><p>这是一个过滤器的包装, 使用责任链模式, 对invoker 进行包装. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建责任链, 基于激活扩展点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>我们看如下文件:</p>
<blockquote>
<p> /dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter  </p>
</blockquote>
<p>默认提供了非常多的过滤器, 然后基于条件激活扩展点, 来对invoker 进行包装, 从而实现在远程调用的到时候, 会经过这些filter 进行过滤. </p>
<h4 id="DubboProtocol-export-1"><a href="#DubboProtocol-export-1" class="headerlink" title="DubboProtocol.export"></a>DubboProtocol.export</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">      <span class="comment">// 获取服务标识, 理解成服务坐标也行, 由服务组名, 服务名,服务版本号以及端口组成,比如:</span></span><br><span class="line">      <span class="comment">// //$&#123;group&#125;/com.example.ISayHelloService:$&#123;version&#125;:20880</span></span><br><span class="line">      URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// export service.</span></span><br><span class="line">      String key = serviceKey(url);</span><br><span class="line">      <span class="comment">// 创建DubboExporter</span></span><br><span class="line">      DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">      <span class="comment">// 将 key,exporter    键值对放入缓存中</span></span><br><span class="line">      exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">      Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">      Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">          String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">          <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                  logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                          <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动服务</span></span><br><span class="line">      openServer(url);</span><br><span class="line">      optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> exporter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="openServer"><a href="#openServer" class="headerlink" title="openServer"></a>openServer</h4><p>去开启一个服务, 并且放入缓存中-&gt; 在同一台机器上(单网卡上), 同一个端口上仅允许启动一个服务器实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// find server.</span></span><br><span class="line">      <span class="comment">// 获取 host:port,并将其作为服务器实例的key, 用于标识当前的服务器实例.</span></span><br><span class="line">      String key = url.getAddress();</span><br><span class="line">      <span class="comment">//client can export a service which&#x27;s only for server to invoke</span></span><br><span class="line">      <span class="comment">// client 也可以暴露一个只有server 可以调用的服务</span></span><br><span class="line">      <span class="keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">          <span class="comment">// 是否在serverMap 中缓存了</span></span><br><span class="line">          ExchangeServer server = serverMap.get(key);</span><br><span class="line">          <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                  server = serverMap.get(key);</span><br><span class="line">                  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      serverMap.put(key, createServer(url));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// server supports reset, use together with override</span></span><br><span class="line">              <span class="comment">// 服务已经创建, 则根据url 中配置 重置服务器. </span></span><br><span class="line">              server.reset(url);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="createServer"><a href="#createServer" class="headerlink" title="createServer"></a>createServer</h4><p>创建服务, 开启心跳检测,默认使用netty, 组装url . </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 组装url, 在url 中添加心跳时间,编解码参数</span></span><br><span class="line">       url = URLBuilder.from(url)</span><br><span class="line">               <span class="comment">// send readonly event when server closes, it&#x27;s enabled by default</span></span><br><span class="line">               <span class="comment">// 当服务关闭后, 发送一个只读的事件, 默认是开启状态.</span></span><br><span class="line">               .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">               <span class="comment">// 启动心跳配置</span></span><br><span class="line">               <span class="comment">// enable heartbeat by default</span></span><br><span class="line">               .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class="line">               .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">               .build();</span><br><span class="line">       String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 通过SPI检测是否存在server 参数所代表的Transporter 扩展, 不存在则抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported server type: &quot;</span> + str + <span class="string">&quot;, url: &quot;</span> + url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建ExchangeServer</span></span><br><span class="line">       ExchangeServer server;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           server = Exchangers.bind(url, requestHandler);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Fail to start server(url: &quot;</span> + url + <span class="string">&quot;) &quot;</span> + e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       str = url.getParameter(CLIENT_KEY);</span><br><span class="line">       <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">           <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported client type: &quot;</span> + str);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> server;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Exchangers-bind"><a href="#Exchangers-bind" class="headerlink" title="Exchangers.bind"></a>Exchangers.bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handler == null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取exchange, 默认为HeaderExchanger。</span></span><br><span class="line">       <span class="comment">// 调用 HeaderExchanger 的bind方法 创建ExchangeServer 实例. </span></span><br><span class="line">       url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">&quot;exchange&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HeaderExchanger-bind"><a href="#HeaderExchanger-bind" class="headerlink" title="HeaderExchanger.bind"></a>HeaderExchanger.bind</h4><p>这里面包含多个逻辑:</p>
<ol>
<li>  new DecodeHandler(new HeaderExchangeHandler(handler)) </li>
<li> Transporters.bind </li>
<li> new HeaderExchangeServer  </li>
</ol>
<p>目前我们只需要关心  transporters.bind  方法即可: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Transporters-bind"><a href="#Transporters-bind" class="headerlink" title="Transporters.bind"></a>Transporters.bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handlers == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果handler 的元素数量大于1, 则创建ChannelHandlerDispatcher 分发器</span></span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取自适应Transporter 实例, 并调用实例方法</span></span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTransporter"><a href="#getTransporter" class="headerlink" title="getTransporter"></a>getTransporter</h4><p>getTransporter 是一个自适应扩展点, 它针对bind方法添加了自适应注解, 意味着 bind方法的具体实现, 会基于<code>Transporter$Adaptive</code> 方法进行适配, 那么在这里面默认的通讯协议是netty, 所以它会采用netty4 的实现, 也就是 <code>org.apache.dubbo.remoting.transport.netty4.NettyTransporter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transporter <span class="title">getTransporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="NettyTransporter-bind"><a href="#NettyTransporter-bind" class="headerlink" title="NettyTransporter.bind"></a>NettyTransporter.bind</h4><p>创建一个  nettyserver </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="nettyserver"><a href="#nettyserver" class="headerlink" title="nettyserver"></a>nettyserver</h4><p>初始化一个 nettyserver , 并且从url中获取相应的ip/port, 然后调用 <code>doOpen()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(url, handler);</span><br><span class="line">       localAddress = getUrl().toInetSocketAddress();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取ip和端口号</span></span><br><span class="line">       String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">       <span class="keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">       <span class="keyword">if</span> (url.getParameter(ANYHOST_KEY, <span class="keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">           bindIp = ANYHOST_VALUE;</span><br><span class="line">       &#125;</span><br><span class="line">       bindAddress = <span class="keyword">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class="line">       <span class="keyword">this</span>.accepts = url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);</span><br><span class="line">       <span class="keyword">this</span>.idleTimeout = url.getParameter(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 调用模板方法 doOpen 启动服务器</span></span><br><span class="line">           doOpen();</span><br><span class="line">           <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Start &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; bind &quot;</span> + getBindAddress() + <span class="string">&quot;, export &quot;</span> + getLocalAddress());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>, <span class="string">&quot;Failed to bind &quot;</span> + getClass().getSimpleName()</span><br><span class="line">                   + <span class="string">&quot; on &quot;</span> + getLocalAddress() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//fixme replace this with better method</span></span><br><span class="line">       DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class="line">       executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="doOpen"><a href="#doOpen" class="headerlink" title="doOpen()"></a>doOpen()</h4><p>开启Netty服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">&quot;NettyServerBoss&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">        workerGroup = <span class="keyword">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class="line">                <span class="keyword">new</span> DefaultThreadFactory(<span class="string">&quot;NettyServerWorker&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyServerHandler.getChannels();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">FIXME:</span> should we use getTimeout()?</span></span><br><span class="line">                        <span class="keyword">int</span> idleTimeout = UrlUtils.getIdleTimeout(getUrl());</span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        ch.pipeline()<span class="comment">//.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                                .addLast(<span class="string">&quot;decoder&quot;</span>, adapter.getDecoder())</span><br><span class="line">                                .addLast(<span class="string">&quot;encoder&quot;</span>, adapter.getEncoder())</span><br><span class="line">                                .addLast(<span class="string">&quot;server-idle-handler&quot;</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, idleTimeout, MILLISECONDS))</span><br><span class="line">                                .addLast(<span class="string">&quot;handler&quot;</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后大家要注意, 这里用到了一个handler 来处理客户端传过来的请求. </p>
<p> nettyServerHandler </p>
<p> NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); </p>
<p>这个handler 是一个链路, 它的正确组成应该是: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultiMessageHandler(heartbeatHandler(AllChannelHandler(DecodeHandler(HeaderExchangeHeadler(dubboProtocol</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后续接收到的请求, 会一层一层的处理, 比较繁琐. </p>
<h3 id="invoker-是什么"><a href="#invoker-是什么" class="headerlink" title="invoker  是什么?"></a>invoker  是什么?</h3><p>从前面的分析来看, 服务的发布分为三个阶段.</p>
<ol>
<li>第一个阶段会创建一个invoker</li>
<li>第二个阶段会把经过一系列处理的invoker(各种包装),在 DubboProtocol  中保存到 exporterMap  中.</li>
<li>第三个节点把dubbo协议的url 地址注册到注册中心</li>
</ol>
<p>invoker 是Dubbo 领域一个非常重要的概念, 和<code>ExtensionLoader</code> 的重要性是一样的, 如果invoker 没有搞懂, 不算看懂了Dubbo的源码. 我们继续回到 ServiceConfig  的 export 的代码, 这段代码是还没有分析过的, 以这个作为入口来分析我们前面export出去的invoker 到底是什么东西? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="proxyFactory-getInvoker"><a href="#proxyFactory-getInvoker" class="headerlink" title="proxyFactory.getInvoker"></a>proxyFactory.getInvoker</h4><p>这是一个代理工厂, 用来生成 invoker, 从它的定义来看, 它是一个自适应扩展点, 看到这样的扩展点,我们几乎可以不假思索的想到它会存在一个动态适配类. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h4><p>这个方法的简单解读为: 它是一个SPI 扩展点, 并且默认的扩展实现为 <code>javassit</code>, 这个接口中有三个方法, 并且都加了 <code>@Adaptive</code> 自适应扩展点, 所以如果调用 getInvoker 方法, 应该会返回一个 <code>ProxyFactory$Adaptive </code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ProxyFactory-Adaptive"><a href="#ProxyFactory-Adaptive" class="headerlink" title="ProxyFactory$Adaptive"></a>ProxyFactory$Adaptive</h4><p>这个自适应扩展点, 做了两件事情: </p>
<ol>
<li>通过 <code>ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName)</code>  获取一个指定名称的扩展点</li>
<li> 在 dubbo-rpc-api/resources/META-INF/com.alibaba.dubbo.rpc.ProxyFactory 中，定义了 javassis=JavassisProxyFactory </li>
<li> 调用 JavassisProxyFactory 的 getInvoker 方法 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([proxy])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0, <span class="keyword">boolean</span> arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.</span></span><br><span class="line"><span class="function">            rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([proxy])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">getInvoker</span><span class="params">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg2 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg2;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([proxy])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JavassistProxyFactory-getInvoker"><a href="#JavassistProxyFactory-getInvoker" class="headerlink" title="JavassistProxyFactory.getInvoker"></a>JavassistProxyFactory.getInvoker</h4><p> javassist : 是一个动态类库, 用来实现动态代理. </p>
<p> proxy : 接口的实现,   com.example.SayHelloServiceImpl </p>
<p>  type : 接口全称:  com.example.ISayHelloService </p>
<p>url: 协议地址: registry://….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="javassist-生成的动态代理代码"><a href="#javassist-生成的动态代理代码" class="headerlink" title="javassist 生成的动态代理代码"></a>javassist 生成的动态代理代码</h4><p>通过断点的方式( Wrapper 258),在  <code>Wrapper.getWrapper 中的 makeWrapper</code> 会创建一个动态代码, 核心的方法 invokeMethod 代码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">      com.ISayHelloService w;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          w = ((com.ISayHelloService) $<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;sayHello&quot;</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3.</span>length == <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.dubbo.common.bytecode.NoSuchMethodException(<span class="string">&quot;Not found method \&quot;&quot;</span> + $<span class="number">2</span> + <span class="string">&quot;\&quot; in class com.ISayHelloService.&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>构建好代理类后, 返回一个 AbstractproxyInvoker ,并且实现了 doInvoke  方法, 这个方法似乎看到了dubbo 消费者调用过来的时候触发的影子,  因为 wrapper.invokeMethod 本质上就是触发上面动态代理类的方法 invokeMethod.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>所以简单总结一下 invoke 本质上应该是一个代理, 经过层层包装最终进行了发布, 当消费者发起请求的时候, 会获得这个invoker 进行调用. </p>
<p>最终发布触发的invoker, 也不是一个单纯的代理, 也是经过多层包装的. </p>
<blockquote>
<p> InvokerDelegate(DelegateProviderMetaDataInvoker(AbstractProxyInvoker())) </p>
</blockquote>
<h2 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h2><p>关于服务发布这一条线分析完成后,再来了解一下服务注册的过程, 希望大家还记得我们之所以走到这一步,是因为我们在 RegistryProtocol 这个类中, 看到了服务发布的流程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 这里获取的是zookeeper 注册中心的url zookeeper://ip:port</span></span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="comment">// url to export locally</span></span><br><span class="line">       <span class="comment">//  这里是获得服务提供者的url   dubbo://ip:port</span></span><br><span class="line">       URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Subscribe the override data</span></span><br><span class="line">       <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">       <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">       <span class="comment">//  subscription information to cover.</span></span><br><span class="line">       <span class="comment">// 订阅 override数据, 在admin 控制台可以针对服务进行治理, 比如修改权重、修改路由机制等, 当有注册中心由此服务的覆盖配置注册进行的时候,</span></span><br><span class="line">       <span class="comment">// 推送消息给提供者, 重新暴露服务.</span></span><br><span class="line">       <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">       <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">       overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">       <span class="comment">//export invoker</span></span><br><span class="line">       <span class="comment">// 这里交给具体的协议去暴露服务</span></span><br><span class="line">       <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// url to registry</span></span><br><span class="line">       <span class="comment">// 根据invoker 中的url 获取registry实例 , zookeeperRegistry</span></span><br><span class="line">       <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">       <span class="comment">// 获取要注册到注册中心的url : dubbo://ip:port</span></span><br><span class="line">       <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">               registryUrl, registeredProviderUrl);</span><br><span class="line">       <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">       <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 是否配置了注册中心, 如果是,则需要配置</span></span><br><span class="line">       <span class="keyword">if</span> (register) &#123;</span><br><span class="line">           <span class="comment">// 注册到注册中心的URL</span></span><br><span class="line">           register(registryUrl, registeredProviderUrl);</span><br><span class="line">           providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 注册中心的订阅</span></span><br><span class="line">       <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">       registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">       exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">       <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">       <span class="comment">// 保存每次export 都返回一个新的exporter 实例</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务注册核心代码"><a href="#服务注册核心代码" class="headerlink" title="服务注册核心代码"></a>服务注册核心代码</h3><p>从export 方法中抽离出来的部分代码, 就是服务注册的流程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据invoker 中的url 获取registry实例 , zookeeperRegistry</span></span><br><span class="line">      <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">      <span class="comment">// 获取要注册到注册中心的url : dubbo://ip:port</span></span><br><span class="line">      <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">      ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">              registryUrl, registeredProviderUrl);</span><br><span class="line">      <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">      <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 是否配置了注册中心, 如果是,则需要配置</span></span><br><span class="line">      <span class="keyword">if</span> (register) &#123;</span><br><span class="line">          <span class="comment">// 注册到注册中心的URL</span></span><br><span class="line">          register(registryUrl, registeredProviderUrl);</span><br><span class="line">          providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="getRegistry"><a href="#getRegistry" class="headerlink" title="getRegistry"></a>getRegistry</h3><ol>
<li>把url 转换为对应配置的注册中心的具体协议</li>
<li>根据具体的协议,从 registryFactory  中获取指定的注册中心实现</li>
</ol>
<p>那么这个 registryFactory  具体是怎么赋值的呢? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将url 转换为配置的具体协议, 比如 zookeeper://ip:port, 这样后续获取的注册中心就是基于zk的实现</span></span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="keyword">return</span> registryFactory.getRegistry(registryUrl);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在 RegistryProtocol  中存在这样一段代码, 很明显这是通过依赖注入来实现扩展点的. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistryFactory</span><span class="params">(RegistryFactory registryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryFactory = registryFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>根据扩展点的加载规则, 我们可以先看看  /META-INF/dubbo/internal 路径下找到 RegistryFactory 的配置文件, 这个factory 有多个扩展点的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dubbo&#x3D;org.apache.dubbo.registry.dubbo.DubboRegistryFactory</span><br><span class="line">multicast&#x3D;org.apache.dubbo.registry.multicast.MulticastRegistryFactory</span><br><span class="line">zookeeper&#x3D;org.apache.dubbo.registry.zookeeper.ZookeeperRegistryFactory</span><br><span class="line">redis&#x3D;org.apache.dubbo.registry.redis.RedisRegistryFactory</span><br><span class="line">consul&#x3D;org.apache.dubbo.registry.consul.ConsulRegistryFactory</span><br><span class="line">etcd3&#x3D;org.apache.dubbo.registry.etcd.EtcdRegistryFactory</span><br></pre></td></tr></table></figure>



<p>接着, 找到 RegistryFactory  的实现, 发现它里面有一个自适应的方法, 根据url 中protocol 传入的值进行适配. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to the registry</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Connecting the registry needs to support the contract: &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. When the check=false is set, the connection is not checked, otherwise the exception is thrown when disconnection &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. Support username:password authority authentication on URL.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. Support the backup=10.20.153.10 candidate registry cluster address.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. Support file=registry.cache local disk file cache.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. Support the timeout=1000 request timeout setting.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 6. Support session=60000 session timeout or expiration settings.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registry address, is not allowed to be empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Registry reference, never return empty value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;&quot;protocol&quot;&#125;)</span></span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegistryFactory-Adaptive"><a href="#RegistryFactory-Adaptive" class="headerlink" title="RegistryFactory$Adaptive"></a>RegistryFactory$Adaptive</h3><p>由于前面的代码中, url 中的protocol 已经改成了zookeeper, 那么这个时候根据zookeeper 获取的spi 扩展点应该是<code>ZookeeperRegistryFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">registry</span>.<span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> org.apache.dubbo.registry.<span class="function">Registry <span class="title">getRegistry</span><span class="params">(org.apache.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line"> org.apache.dubbo.common.URL url = arg0;</span><br><span class="line"> String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol() );</span><br><span class="line"> <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.registr</span></span><br><span class="line"><span class="string">y.RegistryFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line"> org.apache.dubbo.registry.RegistryFactory extension = (org.apache.dubbo.registry.RegistryFactory)Exten</span><br><span class="line">sionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line"> <span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h3><p>这个方法中并没有 getRegistry  方法,而是在父类  <code>AbstractRegistryFactory</code></p>
<ul>
<li>从缓存 REGISTRIES  中, 根据key 获取对应的Registry</li>
<li>如果不存在, 则创建 Registry</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Registry getRegistry(URL url) &#123;</span><br><span class="line">        url &#x3D; URLBuilder.from(url)</span><br><span class="line">                .setPath(RegistryService.class.getName())</span><br><span class="line">                .addParameter(INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">                .removeParameters(EXPORT_KEY, REFER_KEY)</span><br><span class="line">                .build();</span><br><span class="line">        String key &#x3D; url.toServiceStringWithoutResolving();</span><br><span class="line">        &#x2F;&#x2F; Lock the registry access process to ensure a single instance of the registry</span><br><span class="line">        LOCK.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry &#x3D; REGISTRIES.get(key);</span><br><span class="line">            if (registry !&#x3D; null) &#123;</span><br><span class="line">                return registry;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;create registry by spi&#x2F;ioc</span><br><span class="line">            &#x2F;&#x2F;  创建注册中心</span><br><span class="line">            registry &#x3D; createRegistry(url);</span><br><span class="line">            if (registry &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Can not create registry &quot; + url);</span><br><span class="line">            &#125;</span><br><span class="line">            REGISTRIES.put(key, registry);</span><br><span class="line">            return registry;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; Release the lock</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="createRegistry"><a href="#createRegistry" class="headerlink" title="createRegistry"></a>createRegistry</h3><p>创建一个 zookeeperRegistry，把 url和zookeepertransporter  作为参数传入. </p>
<p>zookeepertransporter   这个属性也是基于依赖注入来赋值的, 具体的流程就不在分析了, 这个的值应该是  CuratorZookeeperTransporter , 表示具体使用什么框架来和zk 产生连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h3><p>这个方法中使用了 CuratorZookeeperTransport  来实现zk 的连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(url);</span><br><span class="line">      <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registry address == null&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取group 的名称</span></span><br><span class="line">      String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">      <span class="keyword">if</span> (!group.startsWith(PATH_SEPARATOR)) &#123;</span><br><span class="line">          group = PATH_SEPARATOR + group;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.root = group;</span><br><span class="line">      <span class="comment">// 产生一个zookeeper 连接</span></span><br><span class="line">      zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">      <span class="comment">// 添加zookeeper 状态变化事件</span></span><br><span class="line">      zkClient.addStateListener(state -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  recover();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  logger.error(e.getMessage(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="registry-register-registedProviderUrl"><a href="#registry-register-registedProviderUrl" class="headerlink" title="registry.register(registedProviderUrl);"></a>registry.register(registedProviderUrl);</h3><p>继续往下分析, 会调用 <code>registry.register(registedProviderUrl); </code> 去将 dubbo:// 的协议注册到zookeeper 上. </p>
<p>这个方法会调用  FailbackRegistry 类中的 register ,为什么呢? 因为  ZookeeperRegistry  这个类中并没有registry 这个方法, 但是它的父类 FailbackRegistry  中存在 registry方法, 而这个类又重写了  AbstractRegistry  类中的registry 方法, 所以我们可以直接定位到 FailbackRegistry  这个类中的registry  方法中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">      Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">      registry.register(registeredProviderUrl);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="FailbackRegistry-register"><a href="#FailbackRegistry-register" class="headerlink" title="FailbackRegistry.register"></a>FailbackRegistry.register</h4><ul>
<li> FailbackRegistry  从名字来看, 是一个失败重试机制. </li>
<li>调用父类的 registry方法, 将当前url 添加到缓存集合中. </li>
</ul>
<p>调用 doRegister  这个方法, 这个方法很明显, 是一个抽象方法, 会由 <code>ZookeeperRegistry</code> 的子类实现. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.register(url);</span><br><span class="line">      removeFailedRegistered(url);</span><br><span class="line">      removeFailedUnregistered(url);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// Sending a registration request to the server side</span></span><br><span class="line">          <span class="comment">// 调用子类实现真正的服务注册, 把url 注册到zk上.</span></span><br><span class="line">          doRegister(url);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          Throwable t = e;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">          <span class="comment">// 如果开启了启动时检测, 则直接抛出异常</span></span><br><span class="line">          <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                  &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                  &amp;&amp; !CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">          <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">          <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">              <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                  t = t.getCause();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + getUrl().getAddress() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              logger.error(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">          <span class="comment">// 将失败了的注册请求记录到失败列表, 定时重试</span></span><br><span class="line">          addFailedRegistered(url);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="ZookeeperRegistry-doRegister"><a href="#ZookeeperRegistry-doRegister" class="headerlink" title="ZookeeperRegistry.doRegister"></a>ZookeeperRegistry.doRegister</h4><p>最终调用curator 的客户端把服务地址注册到zk 上去. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Dubbo%E4%B9%8BSPI%E6%9C%BA%E5%88%B6/" rel="prev" title="Dubbo之SPI机制">
      <i class="fa fa-chevron-left"></i> Dubbo之SPI机制
    </a></div>
      <div class="post-nav-item">
    <a href="/Dubbo%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" rel="next" title="Dubbo性能调优">
      Dubbo性能调优 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Dubbo-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">Dubbo 服务发布源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dubbo-%E5%AF%B9%E4%BA%8ESpring-%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.1.</span> <span class="nav-text">Dubbo 对于Spring 的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E7%9A%84%E6%A0%87%E7%AD%BE%E6%89%A9%E5%B1%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">Spring 的标签扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo%E7%9A%84%E6%8E%A5%E5%85%A5%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">Dubbo的接入实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DubboBeanDefinitionParser"><span class="nav-number">1.1.3.</span> <span class="nav-text">DubboBeanDefinitionParser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceBean-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">ServiceBean 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InitializingBean"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">InitializingBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DisposableBean"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">DisposableBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationContextAware"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">ApplicationContextAware</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationListener"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">ApplicationListener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanNameAware"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">BeanNameAware</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationEventPublisherAware"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">ApplicationEventPublisherAware</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E4%BA%8B%E4%BB%B6%E5%8F%91%E9%80%81%E7%9B%91%E5%90%AC%E7%94%B13%E4%B8%AA%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">Spring 事件发送监听由3个部分组成.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceBean-%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.5.</span> <span class="nav-text">ServiceBean 中服务暴露服务.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#afterPropertiesSet"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">afterPropertiesSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onApplicationEvent"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">onApplicationEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#export"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">export</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceConfig-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="nav-number">1.1.6.</span> <span class="nav-text">ServiceConfig  配置类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#doExport"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">doExport</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doExportUrls"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">doExportUrls</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doExportUrlsFor1Protocol"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">doExportUrlsFor1Protocol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Local"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">Local</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remote"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">Remote</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protocol-export"><span class="nav-number">1.1.6.6.</span> <span class="nav-text">protocol.export</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RegistryProtocol-export"><span class="nav-number">1.1.6.7.</span> <span class="nav-text">RegistryProtocol.export</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doLocalExport"><span class="nav-number">1.1.6.8.</span> <span class="nav-text">doLocalExport</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboProtocol-export"><span class="nav-number">1.1.6.9.</span> <span class="nav-text">DubboProtocol.export</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Wrapper-%E5%8C%85%E8%A3%85"><span class="nav-number">1.1.6.9.1.</span> <span class="nav-text">Wrapper 包装</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ProtocolFilterWrapper"><span class="nav-number">1.1.6.10.</span> <span class="nav-text">ProtocolFilterWrapper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboProtocol-export-1"><span class="nav-number">1.1.6.11.</span> <span class="nav-text">DubboProtocol.export</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#openServer"><span class="nav-number">1.1.6.12.</span> <span class="nav-text">openServer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createServer"><span class="nav-number">1.1.6.13.</span> <span class="nav-text">createServer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exchangers-bind"><span class="nav-number">1.1.6.14.</span> <span class="nav-text">Exchangers.bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HeaderExchanger-bind"><span class="nav-number">1.1.6.15.</span> <span class="nav-text">HeaderExchanger.bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Transporters-bind"><span class="nav-number">1.1.6.16.</span> <span class="nav-text">Transporters.bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getTransporter"><span class="nav-number">1.1.6.17.</span> <span class="nav-text">getTransporter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NettyTransporter-bind"><span class="nav-number">1.1.6.18.</span> <span class="nav-text">NettyTransporter.bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nettyserver"><span class="nav-number">1.1.6.19.</span> <span class="nav-text">nettyserver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOpen"><span class="nav-number">1.1.6.20.</span> <span class="nav-text">doOpen()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#invoker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.7.</span> <span class="nav-text">invoker  是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#proxyFactory-getInvoker"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">proxyFactory.getInvoker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ProxyFactory"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">ProxyFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ProxyFactory-Adaptive"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">ProxyFactory$Adaptive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavassistProxyFactory-getInvoker"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">JavassistProxyFactory.getInvoker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-%E7%94%9F%E6%88%90%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">javassist 生成的动态代理代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">服务注册流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">服务注册核心代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getRegistry"><span class="nav-number">1.2.2.</span> <span class="nav-text">getRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryFactory-Adaptive"><span class="nav-number">1.2.3.</span> <span class="nav-text">RegistryFactory$Adaptive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistryFactory"><span class="nav-number">1.2.4.</span> <span class="nav-text">ZookeeperRegistryFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createRegistry"><span class="nav-number">1.2.5.</span> <span class="nav-text">createRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistry"><span class="nav-number">1.2.6.</span> <span class="nav-text">ZookeeperRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#registry-register-registedProviderUrl"><span class="nav-number">1.2.7.</span> <span class="nav-text">registry.register(registedProviderUrl);</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FailbackRegistry-register"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">FailbackRegistry.register</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZookeeperRegistry-doRegister"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">ZookeeperRegistry.doRegister</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/luyanan0718" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luyanan0718" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/luyanan0718@163.com" title="E-Mail → luyanan0718@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://luyanan.com/" title="https:&#x2F;&#x2F;luyanan.com">Site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
