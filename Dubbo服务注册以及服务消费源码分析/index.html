<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg">
  <link rel="mask-icon" href="/images/logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyanan.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Dubbo 服务注册以及服务消费源码分析Invoker 是什么?服务的发布分为三个阶段:   第一个阶段会创造一个 invoker 第二个阶段会把经历过一系列处理的 invoker(各种包装), 在 在DubboProtocol 中保存到 exporterMap 中.  第三个阶段把dubbo协议的url 注册到注册中心上去.   我们来简单看看invoker 到底是一个啥东西?">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo服务注册以及服务消费源码分析">
<meta property="og:url" content="http://luyanan.com/Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="程序员报社">
<meta property="og:description" content="Dubbo 服务注册以及服务消费源码分析Invoker 是什么?服务的发布分为三个阶段:   第一个阶段会创造一个 invoker 第二个阶段会把经历过一系列处理的 invoker(各种包装), 在 在DubboProtocol 中保存到 exporterMap 中.  第三个阶段把dubbo协议的url 注册到注册中心上去.   我们来简单看看invoker 到底是一个啥东西?">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://files.luyanan.com//img/20191202141521.png">
<meta property="article:published_time" content="2021-03-12T02:17:43.931Z">
<meta property="article:modified_time" content="2021-03-12T02:17:43.931Z">
<meta property="article:author" content="luyanan">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://files.luyanan.com//img/20191202141521.png">

<link rel="canonical" href="http://luyanan.com/Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dubbo服务注册以及服务消费源码分析 | 程序员报社</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="程序员报社" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员报社</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员报社</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://luyanan.com/Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="luyanan">
      <meta itemprop="description" content="程序员报社">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员报社">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dubbo服务注册以及服务消费源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 10:17:43" itemprop="dateCreated datePublished" datetime="2021-03-12T10:17:43+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Dubbo-服务注册以及服务消费源码分析"><a href="#Dubbo-服务注册以及服务消费源码分析" class="headerlink" title="Dubbo 服务注册以及服务消费源码分析"></a>Dubbo 服务注册以及服务消费源码分析</h1><h2 id="Invoker-是什么"><a href="#Invoker-是什么" class="headerlink" title="Invoker 是什么?"></a>Invoker 是什么?</h2><p>服务的发布分为三个阶段: </p>
<ol>
<li>第一个阶段会创造一个 invoker</li>
<li>第二个阶段会把经历过一系列处理的 invoker(各种包装), 在 在DubboProtocol 中保存到 <code>exporterMap</code> 中.</li>
<li> 第三个阶段把dubbo协议的url 注册到注册中心上去. </li>
</ol>
<p>我们来简单看看invoker 到底是一个啥东西? </p>
<p>incoker 是Dubbo 领域模型中非常重要的一个概念, 和 <code>ExtensionLoader</code> 的重要性是一样的, 如果invoker 没有搞懂, 那么不算是看懂了Dubbo 的源码. 我们继续回到  <code>ServiceConfig</code>中<code>export</code> 的代码,以这个作为入口来分析前面 export出去的invoker 到底是什么东西? </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                 DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                 Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                 exporters.add(exporter);</span><br></pre></td></tr></table></figure>



<h3 id="ProxyFacotory-getInvoker"><a href="#ProxyFacotory-getInvoker" class="headerlink" title="ProxyFacotory.getInvoker"></a>ProxyFacotory.getInvoker</h3><p>这是一个代理工程, 用来生成invoker, 从它的定义来看, 它是一个自适用扩展点, 看到这样的扩展点, 我们几乎可以不假思索的想到它会存在这样一个动态适配类. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>



<h3 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h3><p>这个方法的简单解读为: 它是一个SPI扩展点, 并且默认的扩展实现是<code>javassist</code>, 这个接口中有三个方法, 而且都是加了 <code>@Adaptive</code> 的自适应扩展点, 所以如果调用<code>getInvoker()</code> 方法, 应该会返回一个 <code>ProxyFactory$Adaptive</code>. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ProxyFactory-Adaptive"><a href="#ProxyFactory-Adaptive" class="headerlink" title="ProxyFactory$Adaptive"></a>ProxyFactory$Adaptive</h3><p>这个自适用扩展点, 做了两件事情. </p>
<ul>
<li>通过 <code>ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName)</code> 获取了一个指定名称的扩展点. </li>
<li>在 <code>dubbo-rpc-api/resources/META-INF/com.alibaba.dubbo.rpc.ProxyFactory</code> 中定义了  <code>javassis=JavassisProxyFactory</code>,调用JavassisProxyFactory` 的getInvoker方法. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([proxy])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0, <span class="keyword">boolean</span> arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.</span></span><br><span class="line"><span class="function">            rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([proxy])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">getInvoker</span><span class="params">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg2 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg2;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([proxy])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="JavassistProxyFactory-getInvoker"><a href="#JavassistProxyFactory-getInvoker" class="headerlink" title="JavassistProxyFactory.getInvoker"></a>JavassistProxyFactory.getInvoker</h3><p>javassist 是一个动态类库, 用来实现动态代理的. </p>
<p>proxy: 接口的实现 <code>com.dubbo.spring.server.UserApiImpl</code></p>
<p>type: 接口全称: <code>com.dubbo.spring.userApi</code></p>
<p>url: 协议地址: registry://…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span></span><br><span class="line">     <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="javassist生成的动态代理代码"><a href="#javassist生成的动态代理代码" class="headerlink" title="javassist生成的动态代理代码"></a>javassist生成的动态代理代码</h3><p>通过断点的方式(Wrapper258行), 在 <code>Wrapper.getWrapper</code> 中的 <code>makeWrappe</code>, 会创建一个动态代理, 核心的方法: <code>invokeMethod</code> 代码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">com.dubbo.spring.userApi w;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">w = ((com.dubbo.spring.userApi) $<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;sayHello&quot;</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3.</span>length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ($w) w.info((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> org.apache.dubbo.common.bytecode.NoSuchMethodException(<span class="string">&quot;Not</span></span><br><span class="line"><span class="string">found method \&quot;&quot;</span> + $<span class="number">2</span> + <span class="string">&quot;\&quot; in class</span></span><br><span class="line"><span class="string">com.dubbo.spring.userApi.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>构建好了代理类后, 返回一个 <code>AbstractproxyInvoker</code>, 它返回了一个 <code>doInvoker</code> 方法, 这个方法似乎看到了dubbo 消费者调用过来的时候触发的影子, 因为 <code>wrapper.invokeMethod</code> 本质上就是触发上面动态代理类的方法 <code>invokeMethod</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes,</span><br><span class="line">arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以, 简单总结一下 invoke 本质上应该是一个代理, 经过层层包装后 最终进行了发布. 当消费者发起请求的时候, 会获取到这个invoke 进行调用. </p>
<p>最终发布出去的invoke , 也不是一个单纯的代理, 也是经过层层包装的. </p>
<blockquote>
<p>InvokerDelegate(DelegateProviderMetaDataInvoker(AbstractProxyInvoker()))</p>
</blockquote>
<h2 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程."></a>服务注册流程.</h2><p>关于服务发布这一条线完成之后, 再来了解一下服务注册的过程, 希望大家还记得我们之所以走到这一步, 是因为我们在 <code>RegistryProtoco</code> 这个类中, 看到了服务发布的流程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 这里获取的是zookeeper 注册中心的url zookeeper://ip:port</span></span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="comment">// url to export locally</span></span><br><span class="line">       <span class="comment">//  这里是获得服务提供者的url   dubbo://ip:port</span></span><br><span class="line">       URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Subscribe the override data</span></span><br><span class="line">       <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">       <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">       <span class="comment">//  subscription information to cover.</span></span><br><span class="line">       <span class="comment">// 订阅 override数据, 在admin 控制台可以针对服务进行治理, 比如修改权重、修改路由机制等, 当有注册中心由此服务的覆盖配置注册进行的时候,</span></span><br><span class="line">       <span class="comment">// 推送消息给提供者, 重新暴露服务.</span></span><br><span class="line">       <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">       <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">       overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">       <span class="comment">//export invoker</span></span><br><span class="line">       <span class="comment">// 这里交给具体的协议去暴露服务</span></span><br><span class="line">       <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// url to registry</span></span><br><span class="line">       <span class="comment">// 根据invoker 中的url 获取registry实例 , zookeeperRegistry</span></span><br><span class="line">       <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">       <span class="comment">// 获取要注册到注册中心的url : dubbo://ip:port</span></span><br><span class="line">       <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">               registryUrl, registeredProviderUrl);</span><br><span class="line">       <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">       <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 是否配置了注册中心, 如果是,则需要配置</span></span><br><span class="line">       <span class="keyword">if</span> (register) &#123;</span><br><span class="line">           <span class="comment">// 注册到注册中心的URL</span></span><br><span class="line">           register(registryUrl, registeredProviderUrl);</span><br><span class="line">           providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 注册中心的订阅</span></span><br><span class="line">       <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">       registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">       exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">       <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">       <span class="comment">// 保存每次export 都返回一个新的exporter 实例</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务注册核心代码"><a href="#服务注册核心代码" class="headerlink" title="服务注册核心代码"></a>服务注册核心代码</h3><p>从export 方法中处理出来的部分代码, 就是服务注册的流程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url to registry</span></span><br><span class="line">      <span class="comment">// 根据invoker 中的url 获取registry实例 , zookeeperRegistry</span></span><br><span class="line">      <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">      <span class="comment">// 获取要注册到注册中心的url : dubbo://ip:port</span></span><br><span class="line">      <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">      ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">              registryUrl, registeredProviderUrl);</span><br><span class="line">      <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">      <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 是否配置了注册中心, 如果是,则需要配置</span></span><br><span class="line">      <span class="keyword">if</span> (register) &#123;</span><br><span class="line">          <span class="comment">// 注册到注册中心的URL</span></span><br><span class="line">          register(registryUrl, registeredProviderUrl);</span><br><span class="line">          providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h3 id="getRegistry"><a href="#getRegistry" class="headerlink" title="getRegistry"></a>getRegistry</h3><ol>
<li>将url转换为对应配置的注册中心的具体协议. </li>
<li>根据具体协议, 从registryFactory 中获取指定的注册中心实现. </li>
</ol>
<p>那么这个 registryFactory 具体是怎么赋值的呢? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将url 转换为配置的具体协议, 比如 zookeeper://ip:port, 这样后续获取的注册中心就是基于zk的实现</span></span><br><span class="line">     URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">     <span class="keyword">return</span> registryFactory.getRegistry(registryUrl);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>在 RegistryProtoco 中存在这样一段代码, 很明显这是通过依赖注入来实现的扩展点. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistryFactory</span><span class="params">(RegistryFactory registryFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.registryFactory = registryFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照扩展点的加载规则, 我们可以先看看  <code>/META-INF/dubbo/internal</code> 路径下找到 RegistryFactory的配置文件, 这个歌factory 有多个扩展点的实现. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.registry.dubbo.DubboRegistryFactory</span><br><span class="line">multicast=org.apache.dubbo.registry.multicast.MulticastRegistryFactory</span><br><span class="line">zookeeper=org.apache.dubbo.registry.zookeeper.ZookeeperRegistryFactory</span><br><span class="line">redis=org.apache.dubbo.registry.redis.RedisRegistryFactory</span><br><span class="line">consul=org.apache.dubbo.registry.consul.ConsulRegistryFactory</span><br><span class="line">etcd3=org.apache.dubbo.registry.etcd.EtcdRegistryFactory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着, 找到RegistryFactory 的实现, 发现它里面有个自适应的方法, 根据url 中的protocol 传入的值进行适配. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to the registry</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Connecting the registry needs to support the contract: &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. When the check=false is set, the connection is not checked, otherwise the exception is thrown when disconnection &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. Support username:password authority authentication on URL.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. Support the backup=10.20.153.10 candidate registry cluster address.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. Support file=registry.cache local disk file cache.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. Support the timeout=1000 request timeout setting.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 6. Support session=60000 session timeout or expiration settings.&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registry address, is not allowed to be empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Registry reference, never return empty value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;&quot;protocol&quot;&#125;)</span></span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegistryFactory-Adaptive"><a href="#RegistryFactory-Adaptive" class="headerlink" title="RegistryFactory$Adaptive"></a>RegistryFactory$Adaptive</h3><p>由于在前面的代码中, url 中的protocol 已经改成了 zookeeper, 那么这个时候根据zookeeper 获取的spi 扩展点应该是 <code>ZookeeperRegistryFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">registry</span>.<span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> org.apache.dubbo.registry.Registry</span><br><span class="line">getRegistry(org.apache.dubbo.common.URL arg0) &#123;</span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> :</span><br><span class="line">url.getProtocol() );</span><br><span class="line"><span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get</span></span><br><span class="line"><span class="string">extension (org.apache.dubbo.registry.RegistryFactory) name from url (&quot;</span> +</span><br><span class="line">url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">org.apache.dubbo.registry.RegistryFactory extension =</span><br><span class="line">(org.apache.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(or</span><br><span class="line">g.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line"><span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h3><p>而这个类中并没有 <code>getRegistry</code> 方法, 而是在他的父类 <code>AbstractRegistryFactory</code>. </p>
<ul>
<li>从缓存REGISTRIES</li>
<li>如果不存在, 则创建 Registry. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       url = URLBuilder.from(url)</span><br><span class="line">               .setPath(RegistryService.class.getName())</span><br><span class="line">               .addParameter(INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">               .removeParameters(EXPORT_KEY, REFER_KEY)</span><br><span class="line">               .build();</span><br><span class="line">       String key = url.toServiceStringWithoutResolving();</span><br><span class="line">       <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">       LOCK.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Registry registry = REGISTRIES.get(key);</span><br><span class="line">           <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> registry;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//create registry by spi/ioc</span></span><br><span class="line">           <span class="comment">//  创建注册中心</span></span><br><span class="line">           registry = createRegistry(url);</span><br><span class="line">           <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not create registry &quot;</span> + url);</span><br><span class="line">           &#125;</span><br><span class="line">           REGISTRIES.put(key, registry);</span><br><span class="line">           <span class="keyword">return</span> registry;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// Release the lock</span></span><br><span class="line">           LOCK.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="createRegistry-url"><a href="#createRegistry-url" class="headerlink" title="createRegistry(url)"></a>createRegistry(url)</h3><p>创建一个 ZookeeperRegistry, 把url 和zookeepertransporter 作为参数传入. </p>
<p>zookeepeTransporter 这个属性也是基于依赖注入来赋值的, 具体流程就不再进行分析,这个的值应该是 <code>CuratorZookeeperTransporter</code>,表示具体是使用说明框架来和zk 产生连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h3><p>这个方法中使用 <code>CuratorZookeeperTransport</code> 来实现zk 的连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(url);</span><br><span class="line">       <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registry address == null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取group 的名称</span></span><br><span class="line">       String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">       <span class="keyword">if</span> (!group.startsWith(PATH_SEPARATOR)) &#123;</span><br><span class="line">           group = PATH_SEPARATOR + group;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.root = group;</span><br><span class="line">       <span class="comment">// 产生一个zookeeper 连接</span></span><br><span class="line">       zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">       <span class="comment">// 添加zookeeper 状态变化事件</span></span><br><span class="line">       zkClient.addStateListener(state -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   recover();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   logger.error(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegistryProtocolregistry-register-registedProviderUrl"><a href="#RegistryProtocolregistry-register-registedProviderUrl" class="headerlink" title="RegistryProtocolregistry.register(registedProviderUrl);"></a>RegistryProtocolregistry.register(registedProviderUrl);</h3><p>继续往下分析 会调用  <code>egistry.register(registedProviderUrl)</code> 去将dubbo:// 的协议地址去注册到zookeeper 上. </p>
<p>这个方法会调用  <code>FailbackRegistry</code> 类中的 registry, 为什么呢? 因为ZookeeperRegisry 这个类中并没有registry这个方法, 但是它的父类 FailbackRegistry 中存在这个方法, 而这个类又重写了 <code>AbstractRegistry</code> 类中的 registry 方法, 所以我们可以直接定位到 FailbackRegistry  这个类中的registry方法中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">     Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">     registry.register(registeredProviderUrl);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="FailbackRegistry-register"><a href="#FailbackRegistry-register" class="headerlink" title="FailbackRegistry.register"></a>FailbackRegistry.register</h3><ul>
<li>FailbackRegistry 从名字来看, 是一个失败重试机制. </li>
<li>调用父类的registry方法, 将当前url 添加到缓存集合中. </li>
</ul>
<p>调用doRegister 方法, 这个方法是一个抽象方法, 会由 ZookeeperRegistry 子类实现. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.register(url);</span><br><span class="line">       removeFailedRegistered(url);</span><br><span class="line">       removeFailedUnregistered(url);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// Sending a registration request to the server side</span></span><br><span class="line">           <span class="comment">// 调用子类实现真正的服务注册, 把url 注册到zk上.</span></span><br><span class="line">           doRegister(url);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Throwable t = e;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">           <span class="comment">// 如果开启了启动时检测, 则直接抛出异常</span></span><br><span class="line">           <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                   &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                   &amp;&amp; !CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">           <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">           <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">               <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                   t = t.getCause();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + getUrl().getAddress() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">           <span class="comment">// 将失败了的注册请求记录到失败列表, 定时重试</span></span><br><span class="line">           addFailedRegistered(url);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ZookeeperRegistry-doRegister"><a href="#ZookeeperRegistry-doRegister" class="headerlink" title="ZookeeperRegistry.doRegister"></a>ZookeeperRegistry.doRegister</h3><p>最终调用curator 的客户端将服务地址注册到zk中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="服务消费"><a href="#服务消费" class="headerlink" title="服务消费"></a>服务消费</h2><h3 id="思考服务消费应该要具备的逻辑"><a href="#思考服务消费应该要具备的逻辑" class="headerlink" title="思考服务消费应该要具备的逻辑"></a>思考服务消费应该要具备的逻辑</h3><p>如果要实现服务的消费, 需要实现以下需求:</p>
<ol>
<li>生成远程服务的代理. </li>
<li>获取目标服务的url 地址</li>
<li>实现远程网络通信. </li>
<li>实现负载均衡</li>
<li>实现集群容错. </li>
</ol>
<p><img src="http://files.luyanan.com//img/20191202141521.png"></p>
<h3 id="服务的消费"><a href="#服务的消费" class="headerlink" title="服务的消费"></a>服务的消费</h3><p>消费端的代码是从下面这段代码开始的</p>
<blockquote>
<p>&lt;dubbo:reference id=”xxxService” interface=”xxx.xxx.Service”/&gt;</p>
</blockquote>
<p>注解的方式的初始化入口是:</p>
<blockquote>
<p>ReferenceAnnotationBeanPostProcessor-&gt;ReferenceBeanInvocationHandler.init- &gt;ReferenceConfig.get() 获得一个远程代理类</p>
</blockquote>
<h3 id="ReferenceConfig-get"><a href="#ReferenceConfig-get" class="headerlink" title="ReferenceConfig.get"></a>ReferenceConfig.get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 修改和检查配置</span></span><br><span class="line">      checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="string">&quot;) has already destroyed!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前接口的远程代理引用为空, 则进行初始化.</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">          init();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ref;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>初始化的过程, 和服务发布的过程类似, 会有很多的判断以及参数的组装, 我们只需要关注 createProxy, 创建代理类的方法. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    ...</span><br><span class="line">      ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">       String serviceKey = URL.buildKey(interfaceName, group, version);</span><br><span class="line">       ApplicationModel.initConsumerModel(serviceKey, buildConsumerModel(serviceKey, attributes));</span><br><span class="line">       initialized = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="createProxy-map"><a href="#createProxy-map" class="headerlink" title="createProxy(map)"></a>createProxy(map)</h3><p>代码比较长, 但是逻辑相对比较清晰. </p>
<ol>
<li>判断是否为本地调用, 如果是, 则使用injvm 协议进行调用. </li>
<li>判断是否为点对点调用, 如果是则将url 保存到url 集合中, 如果url 为1, 进入步骤4, 如果urls&gt;1, 则执行5</li>
<li>如果是配置了注册中心, 遍历注册中心, 把url 添加到urls 集合中, url 为1, 进入步骤4, 如果urls &gt;1, 执行步骤5. </li>
<li>直联构建 invoker</li>
<li>构建 invokers集合, 通过cluster合并多个invoker</li>
<li>最后调用 proxyFactory  生成代理类. </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否在用一个jvm 进程中调用.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Using injvm service &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls.clear(); <span class="comment">// reference retry init will add url to urls, lead to OOM</span></span><br><span class="line">            <span class="comment">// 如果url 不为空, 说明是点对点通信.</span></span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span></span><br><span class="line">                String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">                <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                        URL url = URL.valueOf(u);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                            url = url.setPath(interfaceName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 检测url 协议是否为registry, 若是, 表明用户想使用指定的注册中心.</span></span><br><span class="line">                        <span class="keyword">if</span> (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                            <span class="comment">// 将map 转换为查询字符串, 并作为refer 参数的值添加到url 中.</span></span><br><span class="line">                            urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 合并url, 移除服务提供者的一些配置(这些配置来源于用户配置的url属性. )</span></span><br><span class="line">                            <span class="comment">// 比如线程池相关配置,并保留服务提供者的部分配置, 比如版本、group、时间戳等.</span></span><br><span class="line">                            <span class="comment">// 最后将合并后的配置设置为url, 查询字符串.</span></span><br><span class="line">                            urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center&#x27;s configuration</span></span><br><span class="line">                <span class="comment">// if protocols not injvm checkRegistry</span></span><br><span class="line">                <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                    <span class="comment">// 校验注册中心的配置以及是否有必要从配置中心组装url, 这里的代码实现和服务端类似.</span></span><br><span class="line">                    <span class="comment">// 也是根据注册中心进行解析得到URL, 这里的URL 肯定也是: registry://ip:port/org.apache.dubbo.service.RegsitryService</span></span><br><span class="line">                    checkRegistry();</span><br><span class="line">                    List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                            URL monitorUrl = loadMonitor(u);</span><br><span class="line">                            <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果没有配置注册中心, 则报错.</span></span><br><span class="line">                    <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果值只配置了一个注册中心或者一个服务提供者,直接使用REF_PROTOCOL.refer</span></span><br><span class="line">            <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">                URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 遍历urls 生成多个invoker</span></span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                    <span class="keyword">if</span> (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                        registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果registryURL 不为空, 构建静态directory</span></span><br><span class="line">                <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">                    <span class="comment">// use RegistryAwareCluster only when register&#x27;s CLUSTER is available</span></span><br><span class="line">                    <span class="comment">// 使用RegistryAwareCluster</span></span><br><span class="line">                    URL u = registryURL.addParameter(CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">                    <span class="comment">// The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker</span></span><br><span class="line">                    <span class="comment">// 通过 Cluster将多个invoker合并</span></span><br><span class="line">                    <span class="comment">//RegistryAwareClusterInvoker(StaticDirectory) -&gt;</span></span><br><span class="line">                    <span class="comment">//FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker</span></span><br><span class="line">                    invoker = CLUSTER.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">                    invoker = CLUSTER.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 检查invoker 的有效性. </span></span><br><span class="line">        <span class="keyword">if</span> (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to check the status of the service &quot;</span> + interfaceName + <span class="string">&quot;. No provider available for the service &quot;</span> + (group == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : group + <span class="string">&quot;/&quot;</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;:&quot;</span> + version) + <span class="string">&quot; from the url &quot;</span> + invoker.getUrl() + <span class="string">&quot; to the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Refer dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; from url &quot;</span> + invoker.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">         * ServiceData Store</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            URL consumerURL = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="number">0</span>, map.get(INTERFACE_KEY), map);</span><br><span class="line">            metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create service proxy</span></span><br><span class="line">        <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="REF-PROTOCOL-refer-interfaceClass-url"><a href="#REF-PROTOCOL-refer-interfaceClass-url" class="headerlink" title="REF_PROTOCOL.refer(interfaceClass, url)"></a>REF_PROTOCOL.refer(interfaceClass, url)</h3><p>这里通过指定的协议来调用refer 生成一个invoker 对象, invoker 前面讲过, 它是一个代理对象, 那么在当前的消费端而言, invoker 主要用于执行远程调用. </p>
<p>这个protocol , 又是一个自适应扩展点, 它得到的是一个 <code>Protocol$Adaptive</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Protocol refprotocol =</span><br><span class="line">ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码中, 根据当前的协议url, 得到一个指定的扩展点,传递进来的参数中, 协议地址为 <code>registry://</code>, 所以我们可以直接定位到 REF_PROTOCOL.refer 代码. </p>
<h3 id="Protocol-Adaptive中的refer方法"><a href="#Protocol-Adaptive中的refer方法" class="headerlink" title="Protocol$Adaptive中的refer方法"></a>Protocol$Adaptive中的refer方法</h3><p>根据当前的协议扩展名registry,  获取一个被包装过 的RegistryProtocol</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0,</span></span></span><br><span class="line"><span class="function"><span class="params">org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> :</span><br><span class="line">url.getProtocol() );</span><br><span class="line"><span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get</span></span><br><span class="line"><span class="string">extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="string">&quot;)</span></span><br><span class="line"><span class="string">use keys([protocol])&quot;</span>);</span><br><span class="line">org.apache.dubbo.rpc.Protocol extension =</span><br><span class="line">(org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dub</span><br><span class="line">bo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line"><span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="RegistryProtocol-refer"><a href="#RegistryProtocol-refer" class="headerlink" title="RegistryProtocol.refer"></a>RegistryProtocol.refer</h3><p>这里面的代码逻辑比较简单. </p>
<ul>
<li>组装注册中心协议的url</li>
<li>判断是否配置  legroup, 如果有，则 <code>cluster=getMergeableCluster()</code>, 构建invoker. </li>
<li>doRefer 构建invoker</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 根据配置的协议, 生成注册中心的url : zookeeper://</span></span><br><span class="line">       url = URLBuilder.from(url)</span><br><span class="line">               .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))</span><br><span class="line">               .removeParameter(REGISTRY_KEY)</span><br><span class="line">               .build();</span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span></span><br><span class="line">       <span class="comment">// 判断group参数, 根据group 决定 cluster 的类型</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="doRefer"><a href="#doRefer" class="headerlink" title="doRefer"></a>doRefer</h3><p>doRefer 里面就稍微复杂一些, 涉及到比较多的东西, 我们先关注主线. </p>
<ul>
<li>构建一个RegistryDirectory</li>
<li>构建一个 consumer://协议的地址注册到注册中心</li>
<li>订阅 zookeeper 中节点的变化. </li>
<li>调用  cluster.join方法. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// RegistryDirectory 初始化</span></span><br><span class="line">       RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">       directory.setRegistry(registry);</span><br><span class="line">       directory.setProtocol(protocol);</span><br><span class="line">       <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">       <span class="comment">// 注册consumer://协议的url</span></span><br><span class="line">       URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">       <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">           registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">       &#125;</span><br><span class="line">       directory.buildRouterChain(subscribeUrl);</span><br><span class="line">       <span class="comment">// 订阅事件监听</span></span><br><span class="line">       directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">               PROVIDERS_CATEGORY + <span class="string">&quot;,&quot;</span> + CONFIGURATORS_CATEGORY + <span class="string">&quot;,&quot;</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构建 invoker</span></span><br><span class="line">       Invoker invoker = cluster.join(directory);</span><br><span class="line">       ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="Cluster是什么"><a href="#Cluster是什么" class="headerlink" title="Cluster是什么"></a>Cluster是什么</h3><p>我们只关注一下  invoker 这个代理类的创建过程, 其他的就暂不关心.</p>
<blockquote>
<p>Invoker invoker = cluster.join(directory);</p>
</blockquote>
<p>cluster 其实是在  RegistryProtocol 中通过set方法完成依赖注入的, 并且, 它还是一个被包装的. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCluster</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>cluster   扩展点的定义, 由于它是一个自适应扩展点, 那么就会动态生成一个  <code>Cluster$Adaptive</code> 的动态代理类. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(FailoverCluster.NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge the directory invokers to a virtual invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cluster invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Cluster-Adaptive"><a href="#Cluster-Adaptive" class="headerlink" title="Cluster$Adaptive"></a>Cluster$Adaptive</h3><p>在动态适配的类中会基于extName, 选择一个合适的扩展点进行适配, 由于默认情况下 <code>cluster:failover</code>,所以<code>getExtension(&quot;failover&quot;)</code>  理论情况下会返回 <code>FailOverCluster</code>. 但实际上, 这里做了包装 <code>MockClusterWrapper（FailOverCluster）</code>. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">cluster</span>.<span class="title">Cluster</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> org.apache.dubbo.rpc.Invoker</span><br><span class="line">join(org.apache.dubbo.rpc.cluster.Directory arg0) <span class="keyword">throws</span></span><br><span class="line">org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span></span><br><span class="line">IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.cluster.Directory argument ==</span></span><br><span class="line"><span class="string">null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span></span><br><span class="line">IllegalArgumentException(<span class="string">&quot;org.apache.dubbo.rpc.cluster.Directory argument</span></span><br><span class="line"><span class="string">getUrl() == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">String extName = url.getParameter(<span class="string">&quot;cluster&quot;</span>, <span class="string">&quot;failover&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get</span></span><br><span class="line"><span class="string">extension (org.apache.dubbo.rpc.cluster.Cluster) name from url (&quot;</span> +</span><br><span class="line">url.toString() + <span class="string">&quot;) use keys([cluster])&quot;</span>);</span><br><span class="line">org.apache.dubbo.rpc.cluster.Cluster extension =</span><br><span class="line">(org.apache.dubbo.rpc.cluster.Cluster)ExtensionLoader.getExtensionLoader(org.apa</span><br><span class="line">che.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class="line"><span class="keyword">return</span> extension.join(arg0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="cluster-join"><a href="#cluster-join" class="headerlink" title="cluster.join"></a>cluster.join</h3><p>所以再回到 doRefer 方法, 下面这段代码, 实际上调用 <code>MockClusterWrapper(FailOverCluster.join)</code>. </p>
<blockquote>
<p>Invoker invoker = cluster.join(directory);</p>
</blockquote>
<p>所以这里返回的invoker, 应该是 <code>MockClusterWrapper(FailOverCluster（directory）)</code>. </p>
<p>接着回到<code>ReferenceConfig.createProxy</code> 方法中的最后一行. </p>
<h3 id="proxyFactory-getProxy"><a href="#proxyFactory-getProxy" class="headerlink" title="proxyFactory.getProxy"></a>proxyFactory.getProxy</h3><p>拿到invoker 之后, 会调用获取一个动态代理类. </p>
<blockquote>
<p>return (T) proxyFactory.getProxy(invoker); </p>
</blockquote>
<p>这里的proxyFactory 又是一个自适应扩展点, 所以会进入下面的方法. </p>
<h3 id="JavassistProxyFactory-getProxy"><a href="#JavassistProxyFactory-getProxy" class="headerlink" title="JavassistProxyFactory.getProxy"></a>JavassistProxyFactory.getProxy</h3><p>通过这个方法 生成了一个动态代理类, 并且对invoker 做了一层处理, <code>InvokerInvocationHandler</code> 意味着后续发起服务调用的时候, 会由 InvokerInvocationHandler 来进行处理. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="proxy-getProxy"><a href="#proxy-getProxy" class="headerlink" title="proxy.getProxy"></a>proxy.getProxy</h3><p>在 proxy.getProxy 这个方法中会生成一个动态代理类, 通过debug 的形式可以看到动态代理类的原貌, 在getProxy这个方法位置增加一个断点. </p>
<blockquote>
<p>proxy = (Proxy) pc.newInstance();</p>
</blockquote>
<p>然后在debug 窗口, 找到ccp 这个变量 -&gt; mMethods。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">info</span><span class="params">(java.lang.String arg0)</span></span>&#123;</span><br><span class="line">Object[] args = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">args[<span class="number">0</span>] = ($w)$<span class="number">1</span>;</span><br><span class="line">Object ret = handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], args);</span><br><span class="line"><span class="keyword">return</span> (java.lang.String)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>从这个info方法可以看到, 我们通过. </p>
<p>@Reference 注入的一个对象实例本质上就是一个动态代理类, 通过调用这个类中的方法, 会触发  <code>handler.invoke()</code>, 而这个handler 就是InvokerInvocationHandler</p>
<h2 id="网络连接的建立"><a href="#网络连接的建立" class="headerlink" title="网络连接的建立"></a>网络连接的建立</h2><p>前面分析的逻辑中, 只讲到了动态代理类的生成, 那么目标服务地址信息以及网络通信的建立在哪里实现呢? 我们继续回到 <code>RegistryProtocol.refer</code> 这个方法中. </p>
<p>这里我们暂且关注 <code>directory.subscribe</code> 这个方法, 它是实现服务目标订阅的. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// RegistryDirectory 初始化</span></span><br><span class="line">       RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">       directory.setRegistry(registry);</span><br><span class="line">       directory.setProtocol(protocol);</span><br><span class="line">       <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">       <span class="comment">// 注册consumer://协议的url</span></span><br><span class="line">       URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">       <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">           registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">       &#125;</span><br><span class="line">       directory.buildRouterChain(subscribeUrl);</span><br><span class="line">       <span class="comment">// 订阅事件监听</span></span><br><span class="line">       directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">               PROVIDERS_CATEGORY + <span class="string">&quot;,&quot;</span> + CONFIGURATORS_CATEGORY + <span class="string">&quot;,&quot;</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构建 invoker</span></span><br><span class="line">       Invoker invoker = cluster.join(directory);</span><br><span class="line">       ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="RegistryDirectory-subscribe"><a href="#RegistryDirectory-subscribe" class="headerlink" title="RegistryDirectory.subscribe"></a>RegistryDirectory.subscribe</h3><p>订阅注册中心指定节点的变化, 如果发生变化, 则通知RegistryDirectory. Directory其实和服务的注册以及服务的发现有非常大的关联. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//  设置 consumerUrl</span></span><br><span class="line">      setConsumerUrl(url);</span><br><span class="line">      <span class="comment">// 把当前RegistryDirectory作为listener，去监听zk上节点的变化</span></span><br><span class="line">      CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(<span class="keyword">this</span>);</span><br><span class="line">      serviceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">      <span class="comment">// 订阅, 这里的registry 是zookeeperRegistry</span></span><br><span class="line">      registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的registry 是ZookeeperRegistry, 会监听并获取路径下的节点, 监听的路径是: </p>
<p>/dubbo/org.apache.dubbo.demo.DemoService/providers 、/dubbo/org.apache.dubbo.demo.DemoService/configurators、/dubbo/org.apache.dubbo.de mo.DemoService/routers 节点下面的子节点变动</p>
<h3 id="FailbackRegistry-subscribe"><a href="#FailbackRegistry-subscribe" class="headerlink" title="FailbackRegistry.subscribe"></a>FailbackRegistry.subscribe</h3><p>listener为RegistryDirectory , 后续要用到, 移除失效的listener, 调用doSubscribe 进行订阅. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Sending a subscription request to the server side</span></span><br><span class="line">            doSubscribe(url, listener);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            List&lt;URL&gt; urls = getCacheUrls(url);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(urls)) &#123;</span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to subscribe &quot;</span> + url + <span class="string">&quot;, Using cached list: &quot;</span> + urls + <span class="string">&quot; from cache file: &quot;</span> + getUrl().getParameter(FILE_KEY, System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/dubbo-registry-&quot;</span> + url.getHost() + <span class="string">&quot;.cache&quot;</span>) + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">                <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                        &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">                <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                        t = t.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to subscribe &quot;</span> + url + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Failed to subscribe &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            addFailedSubscribed(url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ZookeeperRegistry-doSubscribe"><a href="#ZookeeperRegistry-doSubscribe" class="headerlink" title="ZookeeperRegistry.doSubscribe"></a>ZookeeperRegistry.doSubscribe</h3><p>这个方法是订阅, 逻辑实现比较多, 可以分为两段来看, 这里的实现把所有的service层发起的订阅以及指定的service层发起的订阅分开处理, 所有service 层类似于监控中心发起的订阅. 指定的service层 发起的订阅可以看做是服务消费者的订阅. 我们只需要关心指定的service层发起的订阅即可. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">              String root = toRootPath();</span><br><span class="line">              ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">              <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                  listeners = zkListeners.get(url);</span><br><span class="line">              &#125;</span><br><span class="line">              ChildListener zkListener = listeners.get(listener);</span><br><span class="line">              <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">                      <span class="keyword">for</span> (String child : currentChilds) &#123;</span><br><span class="line">                          child = URL.decode(child);</span><br><span class="line">                          <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                              anyServices.add(child);</span><br><span class="line">                              subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,</span><br><span class="line">                                      Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">                  zkListener = listeners.get(listener);</span><br><span class="line">              &#125;</span><br><span class="line">              zkClient.create(root, <span class="keyword">false</span>);</span><br><span class="line">              List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br><span class="line">              <span class="keyword">if</span> (CollectionUtils.isNotEmpty(services)) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">                      service = URL.decode(service);</span><br><span class="line">                      anyServices.add(service);</span><br><span class="line">                      subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,</span><br><span class="line">                              Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">              <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                  ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">                  <span class="comment">// 如果该路径没有添加到 listener, 则创建一个map 来放置listener</span></span><br><span class="line">                  <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                      listeners = zkListeners.get(url);</span><br><span class="line">                  &#125;</span><br><span class="line">                  ChildListener zkListener = listeners.get(listener);</span><br><span class="line">                  <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 如果没有添加过对于子节点的listener, 则创建, 通知服务变化, 回调NotifyListener</span></span><br><span class="line">                      listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                      zkListener = listeners.get(listener);</span><br><span class="line">                  &#125;</span><br><span class="line">                  zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">// 添加path 节点的当前节点以及子节点监听, 并且获取子节点信息</span></span><br><span class="line">                  <span class="comment">//  也就是 dubbo://ip:port/</span></span><br><span class="line">                  List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line">                  <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//  调用notify 进行通知, 对已经可用的列表进行通知. </span></span><br><span class="line">              notify(url, listener, urls);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to subscribe &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="FailbackRegistry-notify"><a href="#FailbackRegistry-notify" class="headerlink" title="FailbackRegistry.notify"></a>FailbackRegistry.notify</h3><p>调用 FailbackRegistry.notify, 对参数进行判断, 然后调用 <code>AbstractRegistry.notify</code> 方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify url == null&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify listener == null&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         doNotify(url, listener, urls);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">         <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">         addFailedNotified(url, listener, urls);</span><br><span class="line">         logger.error(<span class="string">&quot;Failed to notify for subscribe &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="AbstractRegistry-notify"><a href="#AbstractRegistry-notify" class="headerlink" title="AbstractRegistry.notify"></a>AbstractRegistry.notify</h3><p>这里面会针对每一个 category, 调用 <code>listener.notify</code> 进行通知, 然后更新本地的缓存文件. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify listener == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((CollectionUtils.isEmpty(urls))</span><br><span class="line">                &amp;&amp; !ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Ignore empty notify urls for subscribe url &quot;</span> + url);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Notify urls for subscribe url &quot;</span> + url + <span class="string">&quot;, urls: &quot;</span> + urls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// keep every provider&#x27;s category.</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);</span><br><span class="line">                List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">            <span class="comment">// We will update our cache file after each notification.</span></span><br><span class="line">            <span class="comment">// When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>消费端的listener 是最开始传递过来的RegistryDirectory,  所以这里会触发 的RegistryDirectory.notify().</p>
<h3 id="RegistryDirectory-notify"><a href="#RegistryDirectory-notify" class="headerlink" title="RegistryDirectory.notify"></a>RegistryDirectory.notify</h3><p>invoke 的网络连接以及后续的配置变更, 都会调用 notify 方法. </p>
<p>urls:  zk的path 数据, 这里表示的是  dubbo://</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对url 列表进行校验、过滤、然后分成 config、router、provider 3个分组map</span></span><br><span class="line">       Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">               .filter(Objects::nonNull)</span><br><span class="line">               .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">               .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">               .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                   <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                       <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                       <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                       <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">               &#125;));</span><br><span class="line"></span><br><span class="line">       List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">       <span class="keyword">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="keyword">this</span>.configurators);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果route 路由节点变化, 则重新将route 下的数据生成route</span></span><br><span class="line">       List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">       toRouters(routerURLs).ifPresent(<span class="keyword">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// providers</span></span><br><span class="line">       <span class="comment">// 获取 provider URL, 然后调用refreshOverrideAndInvoker 进行刷新</span></span><br><span class="line">       List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">       refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="refreshOverrideAndInvoker"><a href="#refreshOverrideAndInvoker" class="headerlink" title="refreshOverrideAndInvoker"></a>refreshOverrideAndInvoker</h3><ul>
<li>逐个调用注册中心里面的配置, 覆盖原来的url, 组成最新的url 放入到overrideDirectoryUrl 存储. </li>
<li>根据 provider  urls , 重新刷新  invoker</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">     overrideDirectoryUrl();</span><br><span class="line">     refreshInvoker(urls);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="refreshInvoker"><a href="#refreshInvoker" class="headerlink" title="refreshInvoker"></a>refreshInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">       Assert.notNull(invokerUrls, <span class="string">&quot;invokerUrls should not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">               &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">               &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">           <span class="comment">// 如果是空协议, 则直接返回 不允许访问.</span></span><br><span class="line">           <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>; <span class="comment">// Forbid to access</span></span><br><span class="line">           <span class="keyword">this</span>.invokers = Collections.emptyList();</span><br><span class="line">           routerChain.setInvokers(<span class="keyword">this</span>.invokers);</span><br><span class="line">           destroyAllInvokers(); <span class="comment">// Close all invokers</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">           <span class="keyword">if</span> (invokerUrls == Collections.&lt;URL&gt;emptyList()) &#123;</span><br><span class="line">               invokerUrls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">               invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">               <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);<span class="comment">//Cached invoker urls, convenient for comparison</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果url为空, 则直接返回.</span></span><br><span class="line">           <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 根据 invokerUrls 生成新的 invoker</span></span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * If the calculation is wrong, it is not processed.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 1. The protocol configured by the client is inconsistent with the protocol of the server.</span></span><br><span class="line"><span class="comment">            *    eg: consumer protocol = dubbo, provider only has other protocol services(rest).</span></span><br><span class="line"><span class="comment">            * 2. The registration center is not robust and pushes illegal specification data.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isEmptyMap(newUrlInvokerMap)) &#123;</span><br><span class="line">               logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;urls to invokers error .invokerUrls.size :&quot;</span> + invokerUrls.size() + <span class="string">&quot;, invoker.size :0. urls :&quot;</span> + invokerUrls</span><br><span class="line">                       .toString()));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 转换为list</span></span><br><span class="line">           List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">           <span class="comment">// pre-route and build cache, notice that route cache should build on original Invoker list.</span></span><br><span class="line">           <span class="comment">// toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.</span></span><br><span class="line">           routerChain.setInvokers(newInvokers);</span><br><span class="line">           <span class="comment">//  如果服务配置了分组,则把分组下的provider 包装成StaticDirectory, 组成一个invoker.</span></span><br><span class="line">           <span class="comment">// 实际上就是 按照group 进行合并.</span></span><br><span class="line">           <span class="keyword">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">           <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//  旧的url是否在新map 里面存在,不存在, 就销毁url 对应的invoker</span></span><br><span class="line">               destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;destroyUnusedInvokers error. &quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="toInvokers"><a href="#toInvokers" class="headerlink" title="toInvokers"></a>toInvokers</h3><p>这个方法中有比较长的判断和处理逻辑, 我们只需要关心invoker 是什么时候初始化的就行, 这里用到了 <code>protocol.refer</code> 来构建一个 invoker  . </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url,</span><br><span class="line">providerUrl);</span><br></pre></td></tr></table></figure>

<p>构建完成之后, 会保存在<code>Map&gt; urlInvokerMap</code>  这个集合中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">       Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       String queryProtocols = <span class="keyword">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">       <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">           <span class="comment">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br><span class="line">           <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">               String[] acceptProtocols = queryProtocols.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                       accept = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">               logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported protocol &quot;</span> + providerUrl.getProtocol() +</span><br><span class="line">                       <span class="string">&quot; in notified url: &quot;</span> + providerUrl + <span class="string">&quot; from registry &quot;</span> + getUrl().getAddress() +</span><br><span class="line">                       <span class="string">&quot; to consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot;, supported protocol: &quot;</span> +</span><br><span class="line">                       ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">           String key = url.toFullString(); <span class="comment">// The parameter urls are sorted</span></span><br><span class="line">           <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">// Repeated url</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           keys.add(key);</span><br><span class="line">           <span class="comment">// Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span></span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">           Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">           <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                       enabled = !url.getParameter(DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       enabled = url.getParameter(ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                       invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.error(<span class="string">&quot;Failed to refer invoker for interface:&quot;</span> + serviceType + <span class="string">&quot;,url:(&quot;</span> + url + <span class="string">&quot;)&quot;</span> + t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                   newUrlInvokerMap.put(key, invoker);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               newUrlInvokerMap.put(key, invoker);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.clear();</span><br><span class="line">       <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="protocol-refer"><a href="#protocol-refer" class="headerlink" title="protocol.refer"></a>protocol.refer</h3><p>调用指定的协议来进行远程引用, protocol 是一个 <code>Protocol$Adaptive</code>,而真正的实现是: <code>ProtocolListenerWrapper(ProtocolFilterWrapper(QosProtocolWrapper(DubboProtocol.refer)</code>. 我们直接进入<code>DubboProtocol.refer</code>  方法. </p>
<h3 id="DubboProtocol-refer"><a href="#DubboProtocol-refer" class="headerlink" title="DubboProtocol.refer"></a>DubboProtocol.refer</h3><ul>
<li>优化序列化</li>
<li>构建DubboInvoker</li>
</ul>
<p>在构建 DubboInvoker 时, 会构建一个ExchangeClient, 通过 <code>getClients(url)</code>  方法, 这里基本可以猜到是的服务的通信建立. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">      optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create rpc invoker.</span></span><br><span class="line">      DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">      invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> invoker;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="getClients"><a href="#getClients" class="headerlink" title="getClients"></a>getClients</h3><p>这里面是获取客户端连接的方法. </p>
<ul>
<li>判断是否为共享连接, 默认是共享一个连接进行通信. </li>
<li>是否配置了多个连接通道  conections, 默认只有一个. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">       <span class="comment">// whether to share connection</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> useShareConnect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> connections = url.getParameter(CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">       List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class="line">       <span class="comment">//   如果配置连接数, 则默认为共享连接. </span></span><br><span class="line">       <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">           useShareConnect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * The xml configuration should have a higher priority than properties.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) <span class="keyword">null</span>);</span><br><span class="line">           connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY,</span><br><span class="line">                   DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">           shareClients = getSharedClient(url, connections);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (useShareConnect) &#123;</span><br><span class="line">               clients[i] = shareClients.get(i);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               clients[i] = initClient(url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> clients;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="getSharedClient"><a href="#getSharedClient" class="headerlink" title="getSharedClient"></a>getSharedClient</h3><p>获取一个共享连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title">getSharedClient</span><span class="params">(URL url, <span class="keyword">int</span> connectNum)</span> </span>&#123;</span><br><span class="line">      String key = url.getAddress();</span><br><span class="line">      List&lt;ReferenceCountExchangeClient&gt; clients = referenceClientMap.get(key);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  检查当前的key ,检查连接是否已经创建过并且可用, 如果是, 则直接返回并且增加连接的个数的统计.</span></span><br><span class="line">      <span class="keyword">if</span> (checkClientCanUse(clients)) &#123;</span><br><span class="line">          batchClientRefIncr(clients);</span><br><span class="line">          <span class="keyword">return</span> clients;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果连接已经关闭或者连接没有被创建.</span></span><br><span class="line">      locks.putIfAbsent(key, <span class="keyword">new</span> Object());</span><br><span class="line">      <span class="keyword">synchronized</span> (locks.get(key)) &#123;</span><br><span class="line">          clients = referenceClientMap.get(key);</span><br><span class="line">          <span class="comment">// dubbo check</span></span><br><span class="line">          <span class="comment">// 在创建l连接之前, 在做一次检查, 防止连接并发创建.</span></span><br><span class="line">          <span class="keyword">if</span> (checkClientCanUse(clients)) &#123;</span><br><span class="line">              batchClientRefIncr(clients);</span><br><span class="line">              <span class="keyword">return</span> clients;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  连接数必须大于等于1</span></span><br><span class="line">          <span class="comment">// connectNum must be greater than or equal to 1</span></span><br><span class="line">          connectNum = Math.max(connectNum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If the clients is empty, then the first initialization is</span></span><br><span class="line">          <span class="comment">// 如果当前消费者还没有和服务端产生连接, 则初始化.</span></span><br><span class="line">          <span class="keyword">if</span> (CollectionUtils.isEmpty(clients)) &#123;</span><br><span class="line">              clients = buildReferenceCountExchangeClientList(url, connectNum);</span><br><span class="line">              <span class="comment">// 创建clients 之后, 保存到map中.</span></span><br><span class="line">              referenceClientMap.put(key, clients);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果clients 不为空, 则从clients 数组中进行遍历.</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.size(); i++) &#123;</span><br><span class="line">                  ReferenceCountExchangeClient referenceCountExchangeClient = clients.get(i);</span><br><span class="line">                  <span class="comment">// If there is a client in the list that is no longer available, create a new one to replace him.</span></span><br><span class="line">                  <span class="comment">// 如果集合中存在一个连接但是这个连接处于closed 状态, 则重新构建一个进行替换</span></span><br><span class="line">                  <span class="keyword">if</span> (referenceCountExchangeClient == <span class="keyword">null</span> || referenceCountExchangeClient.isClosed()) &#123;</span><br><span class="line">                      clients.set(i, buildReferenceCountExchangeClient(url));</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 增加个数 </span></span><br><span class="line">                  referenceCountExchangeClient.incrementAndGetCount();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * I understand that the purpose of the remove operation here is to avoid the expired url key</span></span><br><span class="line"><span class="comment">           * always occupying this memory space.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          locks.remove(key);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> clients;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="buildReferenceCountExchangeClientList"><a href="#buildReferenceCountExchangeClientList" class="headerlink" title="buildReferenceCountExchangeClientList"></a>buildReferenceCountExchangeClientList</h3><p>根据连接配置, 来构建指定个数的连接, 默认为1. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title">buildReferenceCountExchangeClientList</span><span class="params">(URL url, <span class="keyword">int</span> connectNum)</span> </span>&#123;</span><br><span class="line">    List&lt;ReferenceCountExchangeClient&gt; clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectNum; i++) &#123;</span><br><span class="line">        clients.add(buildReferenceCountExchangeClient(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build a single client</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReferenceCountExchangeClient <span class="title">buildReferenceCountExchangeClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    ExchangeClient exchangeClient = initClient(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="initClient"><a href="#initClient" class="headerlink" title="initClient"></a>initClient</h3><p>终于进入到初始化客户端连接的方法, 猜测应该是根据url中配置的参数进行远程通信的构建. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// client type setting.</span></span><br><span class="line">      <span class="comment">//  获得连接类型</span></span><br><span class="line">      String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));</span><br><span class="line">      <span class="comment">// 添加默认序列化方式</span></span><br><span class="line">      url = url.addParameter(CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">      <span class="comment">// enable heartbeat by default</span></span><br><span class="line">     <span class="comment">// 设置心跳时间</span></span><br><span class="line">      url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// BIO is not allowed since it has severe performance issue.</span></span><br><span class="line">      <span class="comment">// 判断str是否存在于扩展点中, 如果不存在则直接报错.</span></span><br><span class="line">      <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported client type: &quot;</span> + str + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                  <span class="string">&quot; supported client type is &quot;</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="string">&quot; &quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ExchangeClient client;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// connection should be lazy</span></span><br><span class="line">          <span class="comment">// 是否需要延迟创建连接, 注意, 这里的requestHandler 是一个适配器. </span></span><br><span class="line">          <span class="keyword">if</span> (url.getParameter(LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">              client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              client = Exchangers.connect(url, requestHandler);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Fail to create remoting client for service(&quot;</span> + url + <span class="string">&quot;): &quot;</span> + e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Exchangers-connect"><a href="#Exchangers-connect" class="headerlink" title="Exchangers.connect"></a>Exchangers.connect</h3><p>创建客户端连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handler == null&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">&quot;exchange&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="HeaderExchange-connect"><a href="#HeaderExchange-connect" class="headerlink" title="HeaderExchange.connect"></a>HeaderExchange.connect</h3><p>主要关注 transporters.connect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="NettyTransport-connect"><a href="#NettyTransport-connect" class="headerlink" title="NettyTransport.connect"></a>NettyTransport.connect</h3><p>使用netty 构建一个客户端连接. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们讲到了 <code>RegistryProtocol.refer</code>  过程中有一个关键步骤, 即在监听到服务提供者url时触发<code>RegistryDirectory.notify()</code> 方法 </p>
<p><code>RegistryDirectory.notify()</code>  方法调用 <code>refreshInvoker()</code>  方法将服务提供者urls 转换为对应的远程  invoker, 最终会调用到 <code>DubboProtocol.refer()</code>  方法对应的DubboInvoker. </p>
<p>DubboInvoker的构造方法中有一项入参 <code>ExchangeClient[] clients</code> , 即对应本文中要讲的网络客户端client, DubboInvoker 就是通过调用 <code>client.request()</code>  方法完成网络通信的请求发送和响应接收功能. </p>
<p>client 的具体生成过程就是通过DubboProtocol 的 <code>initClient(URL url) </code> 方法 创建了一个HeaderExchangeClient. </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Dubbo%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" rel="prev" title="Dubbo性能调优">
      <i class="fa fa-chevron-left"></i> Dubbo性能调优
    </a></div>
      <div class="post-nav-item">
    <a href="/Dubbo%E6%BA%90%E7%A0%81%E4%B9%8B%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E4%BB%A5%E5%8F%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="next" title="Dubbo源码之服务通信以及负载均衡">
      Dubbo源码之服务通信以及负载均衡 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Dubbo-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">Dubbo 服务注册以及服务消费源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Invoker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.</span> <span class="nav-text">Invoker 是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ProxyFacotory-getInvoker"><span class="nav-number">1.1.1.</span> <span class="nav-text">ProxyFacotory.getInvoker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProxyFactory"><span class="nav-number">1.1.2.</span> <span class="nav-text">ProxyFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProxyFactory-Adaptive"><span class="nav-number">1.1.3.</span> <span class="nav-text">ProxyFactory$Adaptive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavassistProxyFactory-getInvoker"><span class="nav-number">1.1.4.</span> <span class="nav-text">JavassistProxyFactory.getInvoker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javassist%E7%94%9F%E6%88%90%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.5.</span> <span class="nav-text">javassist生成的动态代理代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">服务注册流程.</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">服务注册核心代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getRegistry"><span class="nav-number">1.2.2.</span> <span class="nav-text">getRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryFactory-Adaptive"><span class="nav-number">1.2.3.</span> <span class="nav-text">RegistryFactory$Adaptive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistryFactory"><span class="nav-number">1.2.4.</span> <span class="nav-text">ZookeeperRegistryFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createRegistry-url"><span class="nav-number">1.2.5.</span> <span class="nav-text">createRegistry(url)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistry"><span class="nav-number">1.2.6.</span> <span class="nav-text">ZookeeperRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryProtocolregistry-register-registedProviderUrl"><span class="nav-number">1.2.7.</span> <span class="nav-text">RegistryProtocolregistry.register(registedProviderUrl);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FailbackRegistry-register"><span class="nav-number">1.2.8.</span> <span class="nav-text">FailbackRegistry.register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistry-doRegister"><span class="nav-number">1.2.9.</span> <span class="nav-text">ZookeeperRegistry.doRegister</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9"><span class="nav-number">1.3.</span> <span class="nav-text">服务消费</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E5%BA%94%E8%AF%A5%E8%A6%81%E5%85%B7%E5%A4%87%E7%9A%84%E9%80%BB%E8%BE%91"><span class="nav-number">1.3.1.</span> <span class="nav-text">思考服务消费应该要具备的逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B6%88%E8%B4%B9"><span class="nav-number">1.3.2.</span> <span class="nav-text">服务的消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReferenceConfig-get"><span class="nav-number">1.3.3.</span> <span class="nav-text">ReferenceConfig.get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init"><span class="nav-number">1.3.4.</span> <span class="nav-text">init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createProxy-map"><span class="nav-number">1.3.5.</span> <span class="nav-text">createProxy(map)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#REF-PROTOCOL-refer-interfaceClass-url"><span class="nav-number">1.3.6.</span> <span class="nav-text">REF_PROTOCOL.refer(interfaceClass, url)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protocol-Adaptive%E4%B8%AD%E7%9A%84refer%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.7.</span> <span class="nav-text">Protocol$Adaptive中的refer方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryProtocol-refer"><span class="nav-number">1.3.8.</span> <span class="nav-text">RegistryProtocol.refer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#doRefer"><span class="nav-number">1.3.9.</span> <span class="nav-text">doRefer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.10.</span> <span class="nav-text">Cluster是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster-Adaptive"><span class="nav-number">1.3.11.</span> <span class="nav-text">Cluster$Adaptive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-join"><span class="nav-number">1.3.12.</span> <span class="nav-text">cluster.join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proxyFactory-getProxy"><span class="nav-number">1.3.13.</span> <span class="nav-text">proxyFactory.getProxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavassistProxyFactory-getProxy"><span class="nav-number">1.3.14.</span> <span class="nav-text">JavassistProxyFactory.getProxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proxy-getProxy"><span class="nav-number">1.3.15.</span> <span class="nav-text">proxy.getProxy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">1.4.</span> <span class="nav-text">网络连接的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryDirectory-subscribe"><span class="nav-number">1.4.1.</span> <span class="nav-text">RegistryDirectory.subscribe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FailbackRegistry-subscribe"><span class="nav-number">1.4.2.</span> <span class="nav-text">FailbackRegistry.subscribe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistry-doSubscribe"><span class="nav-number">1.4.3.</span> <span class="nav-text">ZookeeperRegistry.doSubscribe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FailbackRegistry-notify"><span class="nav-number">1.4.4.</span> <span class="nav-text">FailbackRegistry.notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractRegistry-notify"><span class="nav-number">1.4.5.</span> <span class="nav-text">AbstractRegistry.notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryDirectory-notify"><span class="nav-number">1.4.6.</span> <span class="nav-text">RegistryDirectory.notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#refreshOverrideAndInvoker"><span class="nav-number">1.4.7.</span> <span class="nav-text">refreshOverrideAndInvoker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#refreshInvoker"><span class="nav-number">1.4.8.</span> <span class="nav-text">refreshInvoker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toInvokers"><span class="nav-number">1.4.9.</span> <span class="nav-text">toInvokers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-refer"><span class="nav-number">1.4.10.</span> <span class="nav-text">protocol.refer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DubboProtocol-refer"><span class="nav-number">1.4.11.</span> <span class="nav-text">DubboProtocol.refer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getClients"><span class="nav-number">1.4.12.</span> <span class="nav-text">getClients</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getSharedClient"><span class="nav-number">1.4.13.</span> <span class="nav-text">getSharedClient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buildReferenceCountExchangeClientList"><span class="nav-number">1.4.14.</span> <span class="nav-text">buildReferenceCountExchangeClientList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initClient"><span class="nav-number">1.4.15.</span> <span class="nav-text">initClient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchangers-connect"><span class="nav-number">1.4.16.</span> <span class="nav-text">Exchangers.connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HeaderExchange-connect"><span class="nav-number">1.4.17.</span> <span class="nav-text">HeaderExchange.connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NettyTransport-connect"><span class="nav-number">1.4.18.</span> <span class="nav-text">NettyTransport.connect</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="luyanan"
      src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">luyanan</p>
  <div class="site-description" itemprop="description">程序员报社</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/luyanan0718" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luyanan0718" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/luyanan0718@163.com" title="E-Mail → luyanan0718@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://luyanan.com/" title="https:&#x2F;&#x2F;luyanan.com">Site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyanan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-haru"},"display":{"position":"right","width":150,"height":300},"mobile":null});</script></body>
</html>
